#define KILL_TYPE_big_boss 18
#define SFALL_SC_EVALUATION  (true) // short - circuit evaluation

#define is_event_allowed(eventType) (eventType == EVENT_TYPE_DRUG orElse eventType == EVENT_TYPE_WITHDRAWAL orElse eventType == EVENT_TYPE_POISON orElse eventType == EVENT_TYPE_RADIATION)
#define is_event_has_free_proc(eventType) (eventType == EVENT_TYPE_DRUG orElse eventType == EVENT_TYPE_WITHDRAWAL orElse eventType == EVENT_TYPE_RADIATION orElse eventType == EVENT_TYPE_SCRIPT orElse eventType == EVENT_TYPE_GSOUND_SFX_EVENT)
#define is_event_real_timed(eventType) (eventType >= EVENT_TYPE_FLARE orElse eventType == EVENT_TYPE_GAME_TIME orElse eventType == EVENT_TYPE_SCRIPT orElse eventType == EVENT_TYPE_KNOCKOUT orElse eventType == EVENT_TYPE_GAME_TIME)
//#define is_event_not_real_timed(eventType) (eventType == EVENT_TYPE_DRUG orElse eventType == EVENT_TYPE_WITHDRAWAL orElse eventType == EVENT_TYPE_POISON orElse eventType == EVENT_TYPE_RADIATION)

#define is_prone(critter_obj) (critter_state(critter_obj) == CRITTER_IS_PRONE)
#define signal_close_game                                       sfall_func0("signal_close_game")

#define is_in_death_anim(critter_anim)  ((critter_anim >= ANIM_bad_landing andAlso critter_anim <= ANIM_fall_front_blood) orElse (critter_anim >= ANIM_bad_landing_sf andAlso critter_anim <= ANIM_fall_front_blood_sf))
#define is_in_prone_anim(critter_anim)  ((critter_anim >= ANIM_fall_back andAlso critter_anim <= ANIM_fall_front_blood) orElse (critter_anim >= ANIM_fall_back_sf andAlso critter_anim <= ANIM_fall_front_blood_sf))
#define military_fid(critter_obj)   (critter_art_fid(critter_obj) == 16777217 or critter_art_fid(critter_obj) == 16777226 or critter_art_fid(critter_obj) == 16777219 or critter_art_fid(critter_obj) == 16777309 or critter_art_fid(critter_obj) == 16777287)
#define high_tec_fid(critter_obj)   (critter_art_fid(critter_obj) == 16777287 or critter_art_fid(critter_obj) == 16777301 or critter_art_fid(critter_obj) == 16777217)
#define msg_file "gl_RegPoisMod.msg"
#define msg_perk_regen 1
#define msg_perk_poison_mastery_name 2
#define msg_perk_poison_mastery_name_old 2000
#define msg_perk_regen_acquired 3
#define msg_perk_regen_description 4
#define msg_perk_poison_mastery_description 5
#define msg_right_hand_healed 6
#define msg_right_leg_healed 7
#define msg_left_hand_healed 8
#define msg_left_leg_healed 9
#define msg_eyes_healed 10
#define msg_envenomed 11
#define msg_envenomed_description 12
#define msg_pois_appl_npc 13
#define msg_pois_appl_player 14
#define msg_gland_gone 15
#define msg_gland_gone_npc_use 34
#define msg_gland_gone_npc_player_user 17
#define msg_wpn_poison_full 16
#define msg_wpn_poison_full_add 35
#define msg_wpn_poison_full_no_apply 36

#define msg_failed_poison_sneak 18
#define msg_player_1_hp_healed 19
#define msg_player_many_hp_healed 20
#define msg_npc_1_hp_healed 21
#define msg_npc_many_hp_healed 22
#define msg_player_poison_dmg 23
#define msg_player_poison_dmg_deadly 41
#define msg_npc_poison_dmg 24
#define msg_npc_poison_dmg_deadly 25
#define msg_npc_reach_poison_lethal_value 26
#define msg_player_reach_poison_lethal_value 40
#define msg_player_after_poison_effect 27
#define msg_UnsafeScripting 28
#define msg_failedPoisoning1 29
#define msg_failedPoisoning2 30
#define msg_failedPoisoning3 31
#define msg_failedPoisoning4 32
#define msg_npc_use_item 33

#define msg_ecco_healing_drugs_1 75
#define msg_ecco_healing_drugs_2 76
#define msg_ecco_healing_drugs_3 77
#define msg_ecco_healing_drugs_4 78
#define msg_ecco_healing_drugs_5 79

#define msg_effects 80
#define msg_burn_tag 81
#define msg_burn_tag_trait 82
#define msg_burn_tag_desc 83
#define msg_heal_tag 84
#define msg_max_hr_1 100
#define msg_max_hr_2 101
#define msg_max_hr_npc 102
#define modmsg(x) message_str_game(new_regpois_msg, x)
#define Poison_amt 50
#define OUTLINE_NEW_RED  0x8500

#define powder_hr_increase 7
#define powder_hr_increase_fast_meta  9
#define powder_hr_decrease  9
#define powder_hr_decrease_fast_meta  12
#define powder_duration_fast_meta  600
#define powder_penalty_duration  4800
#define powder_penalty_duration_fast_meta  2400

#define stim_hr_increase  20
#define stim_hr_increase_fast_meta  26
#define stim_hr_decrease  26
#define stim_hr_decrease_fast_meta  32
#define stim_duration_fast_meta  600
#define stim_penalty_duration  4800
#define stim_penalty_duration_fast_meta  2400

#define super_stim_base_max_heal  60
#define super_stim_base_max_heal_fast_meta  80

#define max_burn_count  100
#define lost_hp_to_burn  0.3
#define burn_hr_penalty  10
#define burn_hr_penalty  10


#define PID_SMALL_TAIL  591
#define PID_PBS_DRAGON_SKIN         (612)

#define min_poison_dmg 1

#define tile_refresh_display_disable  call_offset_v0(0x4B12A8)
#define tile_refresh_display_enable  call_offset_v0(0x4B12B4)

#define pid_laser_projectile (0x05000009)
#define Sonora_doc_bag_pid 50
#define new_max_hr 40
#define new_max_hr_npc_stop 35
#define new_min_hr -999
#define min_hr_to_regen 6
#define poison_overdose_damage(critter) (get_critter_stat(critter, STAT_max_hp) * 3)
#define burn_min_dmg 8
#define aoe_main_target_num 15
#define aoe_main_attacker_num 99
#define get_poison_float(critter, critter_id)  (get_poison(critter) - get_array(id_to_poison_fraction,critter_id))

#define poisoned_weapon_check_time 50
#define poisoned_weapon_check_time_combat 50
#define poisoned_weapon_check_time_WM 900
#define poisoned_weapon_check_time_perk 18000
#define fixed_param_poison_perk_rm 1
#define fixed_param_regen_hp 2
#define fixed_param_poison_dmg 3
#define fixed_param_poison_regen 4
#define fixed_param_restore_hr 5

#define fixed_param_all_in_one 99

#define fixed_param_COMBATDAMAGE 6
#define fixed_param_COMBATDAMAGE_add_timer 7

#define fixed_param_rm_mod 8

#define event_key_array_name "F2MMEKARR"
#define event_queue_array_name "F2MMDREA"

#define id_to_poison_timer_array_name "F2MMRPOIT"
#define id_to_poison_fraction_array_name "F2MMPFAN"

#define id_to_regen_time_array_name "F2MMRREGT"
#define saved_stats_array_name "F2MMRPRSS"
#define id_to_event_key_array_name "F2MMREFAK"
#define combatants_array_name "F2MMRCTCA"

#define POTENTIAL_PARTY_PIDs_ARRAY_name "PotentPartyPids"

#define regen_stim_max_count 3
#define EVENT_TYPE_DRUG 0
#define EVENT_TYPE_KNOCKOUT 1
#define EVENT_TYPE_WITHDRAWAL 2
#define EVENT_TYPE_SCRIPT 3
#define EVENT_TYPE_GAME_TIME 4
#define EVENT_TYPE_POISON 5
#define EVENT_TYPE_RADIATION 6
#define EVENT_TYPE_FLARE 7
#define EVENT_TYPE_EXPLOSION 8
#define EVENT_TYPE_ITEM_TRICKLE 9
#define EVENT_TYPE_SNEAK 10
#define EVENT_TYPE_EXPLOSION_FAILURE 11
#define EVENT_TYPE_MAP_UPDATE_EVENT 12
#define EVENT_TYPE_GSOUND_SFX_EVENT 13

#define EVENT_TYPE_BURN 19
#define EVENT_TYPE_POISON_CUSTOM 93
#define EVENT_TYPE_REGENERATION 21
#define EVENT_TYPE_DRUG_CUSTOM 60

#define CUSTOM_BURN_DRUG_PID -93

#define set_time 1
#define set_and_check_time 2

#define eventTime_offset     (0x00)
#define eventType_offset     (0x04)
#define eventOwner_offset    (0x08)
#define eventData_offset     (0x0C)
#define eventNextNode_offset (0x10)

#define stat_FLAG_ADD 10000
#define stat_FLAG_MULT 100000

#define time_offset           (0)
#define event_type_offset     (1)
#define stat_offset           (2)
#define stat_value_offset     (3)
#define next_event_key_offset (4)
#define drug_pid_offset       (5)
#define stat2_offset          (6)
#define stat2_value_offset    (7)
#define MAX_event_offset      (8)
#define forbidden_event_key   (40)

#define adjust_hp_both  1
#define adjust_hp_poison 2
#define adjust_hp_regen 3

//#define skip_msg_both 1
//#define skip_msg_poison 2
//#define skip_msg_regen 3

#define COMBAT_TURN_START      (1)
#define COMBAT_TURN_END       (0)
#define COMBAT_END_ABRUPT      (-1) //combat ends abruptly (by script or by pressing Enter during PC turn)
#define COMBAT_END_NORMAL      (-2) //combat ends normally (hook always runs at the end of combat)



#define saved_stat_max 40
#define get_saved_stats_key(uniq_id)  ((uniq_id - 0x13333333) * saved_stat_max) //even after overflow, the values SHOULD remain unique
#define has_saved_stats(key)  get_array(id_to_saved_stats, (key + 39))
#define set_saved_stats_counter(key, value)  set_array(id_to_saved_stats, (key + 39), value)



//#define set_free_key_queue_event_array(key) set_sfall_global("F2MMRdfk",key)
//#define get_free_key_queue_event_array get_sfall_global_int("F2MMRdfk")


#define set_free_key_queue_event_array(key) set_array(event_free_key_array, 123, key)
#define set_free_key_queue_event_array_char(ASCII_code) set_array(event_free_key_array, 321, ASCII_code)
#define set_free_key_queue_event_array_int(int) get_array(event_free_key_array, 123, int)
#define get_free_key_queue_event_array_char get_array(event_free_key_array, 321)
#define get_free_key_queue_event_array get_array(event_free_key_array, 123)
#define get_free_key_queue_event_array_full get_array(event_free_key_array, 321) + get_array(event_free_key_array, 123)
//event_free_key_array

#define INT32_MIN -2147483647
#define INT32_MAX 2147483647
#define INT32_MAX_key 2147483500
//#define set_free_key_queue_event_array(key) set_array(event_queue_array, INT32_MIN, key)
//#define get_free_key_queue_event_array get_array(event_queue_array, INT32_MIN)

#define get_first_event_key(uniq_id) get_array(id_to_first_event_array, uniq_id)
#define set_first_event_key(uniq_id, key) set_array(id_to_first_event_array, uniq_id, key)

#define get_event_time(key) get_array(event_queue_array, (key + time_offset))
#define set_event_time(key, time) set_array(event_queue_array, (key + time_offset), time)

#define _combat_turn_running read_int(0x51093C)
#define art_max_frames(artFID)                        sfall_func2("art_frame_data", artFID, -1)
#define set_frame_no_refresh(obj,frame) call_offset_v3(0x48AA84, obj, frame, 0)

#define set_anim_priority_disabled write_byte(0x413C20, 0xC3)

#define PID_NEVADA_SUPER_ANTIDOTE 53


#define PID_TYPE(value) ((value) / 0x1000000)


#include "sfall.h"
#include "DEFINE.H"
#include "define_extra.h"
#include "lib.strings.h"
#include "COMMAND.H"
#include "dik.h"
#include "F2MMR.h"


procedure critter_inflict_poison_dmg(variable target, variable dmg_value, variable animate);
procedure check_poison_healing_item(variable critter, variable critter_max_hp, variable critter_cur_hp, variable critter_poison, variable set_false_hr);

variable gLastTagHr;
variable new_regpois_msg;
variable RegenMod;
variable regen_repeat_ticks;
variable regen_stimpak_ticks;
variable last_timed_event_time;
variable RegenMaxHPpercentMult;
variable RegenBaseHP;
variable HealingRateMult;
variable PoisonMod;
variable Poison_overdose;
variable Poison_overdose_max_hp_value;
variable ShowModMSG;
variable ShowFloatMSG;
variable poison_repeat_ticks;
variable PoisonMaxHPpercentMult;
variable PoisonMaxHPpercentMult_combat_diff;
variable PoisonDecayMult;
variable PoisonDecayConst;
variable PoisonBaseDMG;
variable PoisonDMGMult;
variable all_in_one_repeat_time;
variable all_in_one_repeat_time_global;

variable PoisonedWeapons;
variable PoisonableWeapons;
variable PoisonableWeapons_rm;
variable PoisonableWeapons_timer;
variable gPoisonableWeaponsRemoveTimeLast;
variable PoisonAppliedWeapons;
variable PoisonAppliedWeapons_len;
variable Nevada;
variable Sonora;
variable Resurrection;
variable ET_TU;
variable Fallout_2;
variable Olympus2207;
variable Megamod;
variable last_use_hr_drug;

variable regen_perk_name;
variable regen_perk_description;
variable perk_poison_mastery_was_add;
variable perk_poison_mastery_name;
variable perk_poison_mastery_description;
variable regen_perk_acquired_msg;
variable right_hand_healed_msg;
variable right_leg_healed_msg;
variable left_hand_healed_msg;
variable left_leg_healed_msg;
variable eyes_healed_msg;
variable envenomed_msg;
variable envenomed_description_msg;
variable failed_sneak_use_msg;
variable sfall_unsafescripting;
variable sfall_unsafescripting_msg;
variable HR_fog_of_war;
variable StimUninjure;
variable NPCsUsePoisonTails;
variable old_envenomed_msg;

variable gPID_SMALL_SCORPION_TAIL = -5;
variable combat_diff;
variable EnemyPoisonMult;
variable sfall_mods_config;
variable combat_direct_controll;
variable death_array;
variable death_array_active;
variable map_enter;

variable party_member_remove_arr;
variable party_member_remove;
variable dude_must_die;
variable dude_turn;
variable dude_turn_critter_dies;

variable resting;
variable after_rest_death;
variable delayed_ui_disable;
variable enemy_perception_disabled;
variable msg_u_feel_better;
variable on_global_map;

variable game_time_resting;

variable fake_quit;

variable WAHR;
variable TWAHR;
variable WAQHR;
variable CENHR;
variable MCENHR;

variable sfall_ver_maj;
variable ver_build;
variable ver_minor;
variable array_add_poison;
variable array_add_burn;
variable NPCsUseMedTools;
variable doc_bag_pid = PID_DOCTORS_BAG;
variable npc_overhealed;
variable npc_overhealed_stimpak_amount;
variable npc_overhealed_powder_amount;
variable TraitsPlus;
variable fast_metabolism_plus;
variable aoe_target_num;
variable aoe_dmg_type = -1;
variable MedToolsMod;
variable sfall_508;
variable sfall_510;
variable aoe_poison_count;
variable cursor_is_hidden;
variable global_map_speed_mult;
variable last_timed_poison;
variable regen_array_time;
variable stimpak_event_array;
//variable id_to_ptr_array;
variable event_queue_array;
variable id_to_first_event_array;
variable id_to_poison_time;
variable id_to_poison_fraction;
variable id_to_regen_time;
variable id_to_burn_count;
variable id_to_saved_stats;
variable queue_stop;
variable lowest_timer;
variable death_msg_called;
variable delayed_dude_stats_display;
variable iface_tag_burn;
variable iface_tag_regen;
variable Sonora_drug_desc_separator;
variable faster_healing_bonus;
variable combatants_array;
variable combat_turn_start_time;
variable gOneTimeCall;
variable float_msg_disabled;
//variable combat_turn_start_time;
variable combat_turn_critter;
variable combat_end;
variable read_int_2_enabled;
variable write_int_2_enabled;
variable drug_target;
variable tmp_map_exit_event_array;
variable event_free_key_array;
variable DISABLED;
variable F2MMR_POTENTIAL_PARTY_PIDs_ARRAY;
variable ptr_to_id_array;
variable gEndAttackAnim;
variable gEndAttackAnimFrame;
variable priority_disabled;
variable anim_priority_byte;
variable gAntidoteHealingWasSet;
variable gSuperAntidoteHealingWasSet;
//variable cur_map_event_array_name;

variable party_levels;

export variable tail_used;


import variable combat_med_tool_used;
import variable import_alt_attack_aoe_targets_arr;

procedure add_to_poisoned_perk_weapons(variable weapon_pid) begin
   variable num = PoisonAppliedWeapons[weapon_pid] + 1;
   if num < 1 then
      num = 1;
   set_array(PoisonAppliedWeapons, weapon_pid, num);
   PoisonAppliedWeapons_len += 1;
end

inline procedure rm_from_poisoned_perk_weapons(variable weapon_pid) begin
   variable num;
   num = PoisonAppliedWeapons[weapon_pid] - 1;
   if num < 0 then
      num = 0;
   set_array(PoisonAppliedWeapons, weapon_pid, num);
   PoisonAppliedWeapons_len -= 1;
end

procedure rename_old_poisoned_weapons_perks(variable critter) begin
   variable weapon_pid;
   variable weapon_name;
   variable test_pid;
   variable poison_weapon_perk;
   variable old_perk_name;

   if Nevada > 0 then
      test_pid = [4,7,45,112,116,234,236,280,319,320,365,407,420,470,517,522,573,575,654,667,668,677,678,738,739,740,762,763];
   else if Sonora > 0 then
      test_pid = [19,127,128,132,133,134,135,137,138,174,190];
   else if Olympus2207 > 0 then
      test_pid = [37,39,40,60,62,63,64,65,66,67,68,70,71,107,109,217];
   else if Megamod > 0 then
      test_pid = [4,7,45,116,234,236,280,319,320,365,383,407,517,522,530,583,611,641,711,737,738,739,740,877,886,959];
   else begin
      test_pid = [4,7,45,116,234,236,280,319,320,365,383,407,517,522,530,583,611,637,638,639,640];
   end

   foreach weapon_pid in test_pid begin
      weapon_name = proto_data(weapon_pid, 1);
      old_perk_name = old_envenomed_msg + weapon_name;
      poison_weapon_perk = has_fake_perk_npc(critter, old_perk_name);
      if poison_weapon_perk > 0 then begin
         set_fake_perk_npc(critter, old_perk_name, 0, 23, envenomed_description_msg);
         if PoisonMod > 0 then begin
            set_fake_perk_npc(critter, (envenomed_msg + weapon_name), poison_weapon_perk, 23, envenomed_description_msg);
            call add_to_poisoned_perk_weapons(weapon_pid);
         end
      end
   end
   free_array(test_pid);
end

procedure check_poisoned_weapons_perks begin
   variable critter;
   variable party = party_member_list(0);
   variable weapon_pid;
   variable weapon_name;
   variable test_pid;
   variable poison_weapon_perk;
   variable old_perk_name;

   //Nevada Weapons
   if Nevada > 0 then
      test_pid = [4,7,45,112,116,234,236,280,319,320,365,407,420,470,517,522,573,575,654,667,668,677,678,738,739,740,762,763];
   else if Sonora > 0 then
      test_pid = [19,127,128,132,133,134,135,137,138,174,190];
   else if Olympus2207 > 0 then
      test_pid = [37,39,40,60,62,63,64,65,66,67,68,70,71,107,109,217];
   else if Megamod > 0 then
      test_pid = [4,7,45,116,234,236,280,319,320,365,383,407,517,522,530,583,611,641,711,737,738,739,740,877,886,959];
   else begin
      test_pid = [4,7,45,116,234,236,280,319,320,365,383,407,517,522,530,583,611,637,638,639,640];
   end
   PoisonAppliedWeapons = create_array_map;
   save_array("PoisonAppliedWeaponsMMR", PoisonAppliedWeapons);

   foreach (critter in party) begin
      foreach weapon_pid in test_pid begin
         weapon_name = proto_data(weapon_pid, 1);
         old_perk_name = old_envenomed_msg + weapon_name;
         poison_weapon_perk = has_fake_perk_npc(critter, old_perk_name);
         if poison_weapon_perk > 0 then begin
            set_fake_perk_npc(critter, old_perk_name, 0, 23, envenomed_description_msg);
            set_fake_perk_npc(critter, (envenomed_msg + weapon_name), poison_weapon_perk, 23, envenomed_description_msg);
            call add_to_poisoned_perk_weapons(weapon_pid);
         end
      end
   end
   free_array(test_pid);
end

procedure callback_set_cursor_animated_watch begin
   set_cursor_animated_watch;
end

procedure WITHINPERCEPTION begin
   if enemy_perception_disabled > 0 then begin
      set_sfall_return(0);
   end
end

inline procedure perception_disable begin
   enemy_perception_disabled = 1;
end

inline procedure perception_enable begin
   enemy_perception_disabled = 0;
end

procedure calc_regen_tick(variable critter, variable new_heal_rate, variable PoisonTickDmg = 0, variable new_critter_cur_hp = 0) begin
   variable critter_max_hp;
   variable critter_cur_hp;
   variable critter_healing_rate = new_heal_rate;
   variable local_RegenTickHP;
   variable kill_type = critter_kill_type(critter);
   if critter_healing_rate > new_max_hr then begin
      critter_healing_rate = new_max_hr;
   end
   else if critter_healing_rate <= 0 then begin
      critter_healing_rate = get_critter_stat(critter,STAT_heal_rate);
   end
   if critter_healing_rate < min_hr_to_regen then
      return 0;

      critter_max_hp = get_critter_stat(critter,STAT_max_hp);
      if new_critter_cur_hp > 0 then
         critter_cur_hp = new_critter_cur_hp;
      else
         critter_cur_hp = get_critter_stat(critter,STAT_current_hp);

      if PoisonTickDmg > 0 then
         critter_cur_hp -= PoisonTickDmg;

   if critter_cur_hp >= critter_max_hp then
      return 0;

   if fast_metabolism_plus > 0 andAlso critter == real_dude_obj andAlso (fast_metabolism_plus >= 2 orElse has_trait(TRAIT_TRAIT, real_dude_obj, TRAIT_fast_metabolism)) then begin
      critter_healing_rate += critter_healing_rate / 3;
      if get_poison(critter) > 0 then begin
         critter_healing_rate *= 0.5 + (get_critter_stat(critter, STAT_poison_resist) / 200.0);
      end
   end
   else if (kill_type == KILL_TYPE_alien_kills orElse kill_type == KILL_TYPE_centaur_kills) then begin
      if get_poison(critter) > 0 then begin
         critter_healing_rate *= 0.5 + (get_critter_stat(critter, STAT_poison_resist) / 200.0);
      end
   end
   local_RegenTickHP = RegenBaseHP + (critter_healing_rate * HealingRateMult)  + (critter_max_hp / 100.0) * RegenMaxHPpercentMult * critter_healing_rate;

   local_RegenTickHP = ceil(local_RegenTickHP);

   if (local_RegenTickHP < 1) then begin
      local_RegenTickHP = 1;
   end

   if critter_cur_hp + local_RegenTickHP > critter_max_hp then begin
      local_RegenTickHP = critter_max_hp - critter_cur_hp;
   end
   return local_RegenTickHP;
end

procedure cripheal(variable critter, variable count = 1, variable chance = 100) begin
   variable rnd = random(0, 4);
   variable injury;
   variable injures = [DAM_CRIP_ARM_RIGHT, DAM_CRIP_LEG_LEFT, DAM_CRIP_ARM_LEFT, DAM_CRIP_LEG_RIGHT, DAM_BLIND];
   variable messages;
   variable i;
   variable key;
   variable uninjure;
   if critter == dude_obj then
      messages = [right_hand_healed_msg, left_leg_healed_msg, left_hand_healed_msg, right_leg_healed_msg, eyes_healed_msg];

   for (i = 0; i < 5; i++) begin
      key = ((rnd + i) % 5);
      injury = injures[key];
      if critter_state(critter) BWAND injury then begin
         if chance >= random(1,100) then begin
            uninjure = uninjure bwor injury;
            if critter == dude_obj then
               display_msg(messages[key]);
         end
         count--;
         if count <= 0 then
            break;
      end
   end
   if uninjure != 0 then
      critter_uninjure(critter, uninjure);

   return uninjure;
end

procedure critter_regen_heal(variable critter, variable skip_msg, variable new_healing_rate) begin
   variable critter_healing_rate;
   variable local_RegenTickHP;
   variable tar_name;
   variable losblock;
   variable regen;
   if critter <= 0 then
      return 0;

   if is_really_dead(critter, critter_state(critter), get_critter_stat(critter, STAT_current_hp)) orElse get_array(death_array,critter) > 0 then
      return 0;
   // Определяем скорость исцеления
   if new_healing_rate > 0 then begin
      critter_healing_rate = new_healing_rate;
   end else begin
      critter_healing_rate = get_critter_stat(critter, STAT_heal_rate);
   end

   if critter_healing_rate >= min_hr_to_regen then begin
      regen = 1;
      local_RegenTickHP = calc_regen_tick(critter, critter_healing_rate);

      if local_RegenTickHP > 0 then begin
         critter_heal(critter, local_RegenTickHP);

         if ShowModMSG > 0 andAlso skip_msg <= 0 then begin
            tar_name = obj_name(critter);

            if critter == real_dude_obj then begin
               if local_RegenTickHP == 1 then begin
                  display_msg(parse_str_2(modmsg(msg_player_1_hp_healed), tar_name, local_RegenTickHP));
               end else begin
                  display_msg(parse_str_2(modmsg(msg_player_many_hp_healed), tar_name, local_RegenTickHP));
               end
            end else begin
               if HR_fog_of_war > 0 then
                  losblock = obj_blocking_line(dude_obj, tile_num(critter), BLOCKING_TYPE_SIGHT);

               if local_RegenTickHP > 0 andAlso losblock <= 0 then begin
                  if local_RegenTickHP == 1 then begin
                     display_msg(parse_str_2(modmsg(msg_npc_1_hp_healed), tar_name, local_RegenTickHP));
                  end else begin
                     display_msg(parse_str_2(modmsg(msg_npc_many_hp_healed), tar_name, local_RegenTickHP));
                  end
               end
            end
         end
      end

      if critter == real_dude_obj then begin
         if has_fake_perk(regen_perk_name) > 0 andAlso critter_is_crippled(real_dude_obj) then begin
            call cripheal(real_dude_obj);
         end
      end
   end
   return regen;
end

procedure calc_poison_overdose(variable critter) begin
   variable poison_overdose_value;
   variable critter_max_hp = get_critter_stat(critter, STAT_max_hp);
   poison_overdose_value = Poison_overdose + (Poison_overdose_max_hp_value * critter_max_hp);
   if poison_overdose_value <= 0 then begin
      if Poison_overdose == 0 andAlso Poison_overdose_max_hp_value == 0 then
         poison_overdose_value = INT32_MAX;
      else
         poison_overdose_value = 1;
   end
   return poison_overdose_value;
end


procedure decrease_poison(variable critter, variable cur_poison = 0, variable poison_level_change = 1, variable count = 1) begin
   variable critter_id;
   variable decay;
   variable poison_decay;
   variable critter_poison;
   variable poison_floor;
   variable poison_fraction;
   variable i;
   if critter == dude_must_die then
      return 0;

   critter_id = get_unique_id(critter);
   if cur_poison <= 0 then begin
      poison_fraction = get_array(id_to_poison_fraction, critter_id);
      critter_poison = get_poison(critter);
   end
   else
      critter_poison = cur_poison;

   cur_poison = critter_poison - poison_fraction;

   if cur_poison <= 0 then
      return 0;

   for (i = 0; i < count; i++) begin
      decay = PoisonDecayConst + (cur_poison * PoisonDecayMult);
      if decay <= 0.01 then
         decay = 0.01;
      cur_poison -= decay;
      poison_decay += decay;
      if cur_poison <= 0 then begin
         cur_poison = 0;
         break;
      end
   end

   if poison_level_change > 0 then begin
      if cur_poison <= 0 then begin
         poison_decay += 1;
         poison_fraction = 0;
      end
      else begin
         poison_decay = critter_poison - cur_poison;
         poison_fraction = 1 - (cur_poison - floor2(cur_poison));
         if poison_fraction >= 1 then begin
            poison_fraction = 0;
         end
      end
      set_array(id_to_poison_fraction, critter_id, poison_fraction);
      //poison_decay += poison_fraction;
      if poison_decay > 1 then
         poison(critter, -floor2(poison_decay));
      else if critter == dude_obj then
         display_msg(msg_u_feel_better);
   end

   if cur_poison > 0 then
      return cur_poison;
   else
      return 0;
end

procedure calc_poison_dmg(variable critter, variable critter_id, variable cur_poison = 0, variable count = 1) begin
   variable critter_cur_hp;
   variable critter_max_hp;
   variable party;
   variable critter_in_party;
   variable critter_cur_poison;
   variable PoisonTickDmg;
   variable local_PoisonTickDmg;
   variable i;
   if cur_poison <= 0 then
      critter_cur_poison = get_poison_float(critter, critter_id);
   else
      critter_cur_poison = cur_poison;

   if critter_cur_poison > 0 then begin
      if critter_cur_poison >= calc_poison_overdose(critter) then begin
         local_PoisonTickDmg = poison_overdose_damage(critter);
      end
      else begin
         critter_cur_hp = get_critter_stat(critter,STAT_current_hp);
         critter_max_hp = get_critter_stat(critter,STAT_max_hp);
         party = party_member_list(0);
         critter_in_party = is_in_array(critter, party);

         PoisonMaxHPpercentMult_combat_diff = combat_diff * 0.5;
         if not(critter_in_party) andAlso critter != real_dude_obj then begin
            if PoisonMaxHPpercentMult_combat_diff < 1 then
               PoisonMaxHPpercentMult_combat_diff = 1;
            PoisonMaxHPpercentMult_combat_diff *= EnemyPoisonMult;
         end

         for (i = 0; i < count; i++) begin
            PoisonTickDmg = round(PoisonBaseDMG + (critter_cur_poison * PoisonDMGMult) + ((critter_max_hp / 100.0) * PoisonMaxHPpercentMult) * PoisonMaxHPpercentMult_combat_diff * critter_cur_poison);
            if PoisonTickDmg < min_poison_dmg then begin
               PoisonTickDmg = min_poison_dmg;
            end
            local_PoisonTickDmg += PoisonTickDmg;

            if count > 1 then begin
               critter_cur_poison = decrease_poison(critter, critter_cur_poison, false, 1);
               if critter_cur_poison <= 0 then
                  break;
            end
         end
      end
   end
   return local_PoisonTickDmg;
end

procedure delayed_add_poison begin
   variable critter;
   variable poison_amount;
   variable effective_poison;
   if len_array(import_alt_attack_aoe_targets_arr) > 0 then begin
      foreach critter:poison_amount in import_alt_attack_aoe_targets_arr begin
         if poison_amount > 0 then
            poison_amount = aoe_poison_count;
         else begin
            poison_amount = 0;
            continue;
         end

         if critter <= 0 then
            continue;

         if PID_TYPE(obj_pid(critter)) != OBJ_TYPE_CRITTER then begin
            continue;
         end

         if poison_amount <= 0 orElse get_critter_stat(critter, STAT_current_hp) <= 0 orElse is_critter_dead(critter) then begin
            continue;
         end
         poison(critter, poison_amount);
      end
   end
   if len_array(array_add_poison) > 0 then begin
      foreach critter:poison_amount in array_add_poison begin
         if critter <= 0 then
            continue;

         if PID_TYPE(obj_pid(critter)) != OBJ_TYPE_CRITTER then begin
            continue;
         end

         if poison_amount <= 0 orElse get_critter_stat(critter, STAT_current_hp) <= 0 orElse is_critter_dead(critter) then begin
            continue;
         end

         effective_poison = (poison_amount - ((poison_amount * get_critter_stat(critter, STAT_poison_resist)) / 100));
         if get_poison_float(critter, get_unique_id(critter)) + effective_poison >= calc_poison_overdose(critter) then begin
            if get_object_data(critter, OBJ_DATA_DAMAGE_FLAGS) bwand DAM_DEAD != 0 then begin
               float_msg(critter, "-" + poison_overdose_damage(critter), FLOAT_MSG_LIGHT_RED);
               display_msg(parse_str_2(modmsg(msg_npc_reach_poison_lethal_value), obj_name(critter), 0));
            end
            else
               poison(critter, poison_amount);
         end
         else begin
            poison(critter, poison_amount);
         end
      end
      clear_array(array_add_poison);
   end
end

procedure calc_burn_count(variable critter, variable dmg) begin
   variable wpn;
   variable wpn_pid;
   variable dmg_type = aoe_dmg_type;
   variable burn_count;
   variable critter_in_party;
   variable min_dmg_to_burn;
   variable critter_cur_hp;
   if critter <= 0 orElse dmg <= 0 orElse dmg_type <= DMG_normal_dam then
      return 0;

   if combat_data > 0 then
      wpn = get_object_data(combat_data, C_ATTACK_WEAPON);

   if wpn > 0 then begin
      wpn_pid = obj_pid(wpn);
   end

   if dmg_type == DMG_fire orElse dmg_type == DMG_explosion orElse dmg_type == DMG_plasma orElse dmg_type == DMG_laser orElse wpn_pid == PID_MOLOTOV_COCKTAIL then begin
      critter_cur_hp = get_critter_stat(critter, STAT_current_hp);

      if critter_cur_hp > dmg then begin
         if dmg_type == DMG_fire orElse wpn_pid == PID_MOLOTOV_COCKTAIL then
            min_dmg_to_burn = burn_min_dmg;
         else
            min_dmg_to_burn = dmg_type + burn_min_dmg;

         if dmg >= min_dmg_to_burn then begin
            burn_count = dmg / min_dmg_to_burn;

            critter_in_party = is_in_array(critter, party_member_list(0));
            if critter_in_party then begin
               burn_count = round(burn_count / 4.0 * (combat_diff + 1));
            end
            else begin
               if wpn_pid == PID_MOLOTOV_COCKTAIL then begin
                  burn_count += 4;
               end
               burn_count += 1;
            end
         end
      end
   end
   return burn_count;
end

procedure get_art_max_frames(variable obj_fid, variable new_anim = -1) begin
   variable frame;
   variable max_frames;
   variable old_fid;
   variable test_obj;
   variable test_fid;
   variable arg3;

   if sfall_510 > 0 then begin
      test_fid = obj_fid;

      if new_anim >= 0 then begin

         if (new_anim != ANIM_fire_dance andAlso new_anim >= ANIM_fall_back andAlso new_anim <= ANIM_fall_front_blood) then
            arg3 = 1;

         test_fid = critter_anim_fid(test_fid, new_anim, arg3);
      end

      max_frames = art_max_frames(test_fid);

      return max_frames;
   end

   test_obj = create_object_sid(0x05000009, 0, 0, -1);

   old_fid = obj_fid;

   if new_anim >= 0 then begin

      if (new_anim != ANIM_fire_dance andAlso new_anim >= ANIM_fall_back andAlso new_anim <= ANIM_fall_front_blood) then
         arg3 = 1;

      test_fid = critter_anim_fid(old_fid, new_anim, arg3);
      set_object_data(test_obj, OBJ_DATA_FID, test_fid);
   end
   else begin
      set_object_data(test_obj, OBJ_DATA_FID, old_fid);
   end

   while max_frames < 101 do begin
      set_frame_no_refresh(test_obj, max_frames);
      frame = get_object_data(test_obj, OBJ_DATA_CUR_FRM);

      if frame != max_frames then
         break;

      max_frames++;
   end

   destroy_object(test_obj);

   return max_frames;
end

procedure get_attack_anim_last(variable attacker, variable target, variable weapon, variable attack_type) begin
   variable attack_anim;
   variable attack_anim_arr;
   variable index;
   variable attack_anim_last;
   variable rot_to_tar = rotation_to_tile(tile_num(attacker), tile_num(target));
   variable max_frames;
   if attack_type >= ATKTYPE_LWEP_RELOAD andAlso attack_type <= ATKTYPE_RWEP_RELOAD then begin
      return -1;
   end
   //kick
   if attack_type == ATKTYPE_KICK orElse (attack_type >= ATKTYPE_STRONGKICK andAlso attack_type <= ATKTYPE_PIERCINGKICK) then begin
      attack_anim_last = ANIM_kick_leg;
      max_frames = get_art_max_frames(obj_art_fid(attacker), ANIM_kick_leg) - 1;
      gEndAttackAnimFrame = max_frames - max_frames / 3;
      return attack_anim_last;
   end
   //punch
   if weapon <= 0 then begin
      attack_anim_last = ANIM_throw_punch;
      max_frames = get_art_max_frames(obj_art_fid(attacker), ANIM_throw_punch) - 1;
      gEndAttackAnimFrame = max_frames - max_frames / 3;
      return attack_anim_last;
   end
   attack_anim_arr = [ANIM_stand, ANIM_throw_punch, ANIM_kick_leg, ANIM_swing_anim, ANIM_thrust_anim, ANIM_throw_anim, ANIM_fire_single, ANIM_fire_burst, ANIM_fire_continuous];
   if attack_type == ATKTYPE_LWEP1 OrElse attack_type == ATKTYPE_RWEP1 then begin
      index = get_proto_data(obj_pid(weapon), PROTO_FLAG_EXT) bwand 0x0000000F;
   end
   else begin
      index = (get_proto_data(obj_pid(weapon), PROTO_FLAG_EXT) bwand 0x000000F0) / 16;
   end
   attack_anim = attack_anim_arr[index];

   if attack_anim >= ANIM_fire_single then begin
      attack_anim_last = ANIM_unpoint;
      gEndAttackAnimFrame = 2;
   end
   else if attack_anim == ANIM_throw_anim then begin
      attack_anim_last = ANIM_throw_anim;
      max_frames = get_art_max_frames(obj_art_fid(attacker), attack_anim_last);
      gEndAttackAnimFrame = max_frames - 1;
   end
   else begin
      attack_anim_last = attack_anim;
      max_frames = get_art_max_frames(obj_art_fid(attacker), attack_anim_last);
      gEndAttackAnimFrame = max_frames - max_frames / 3;
   end


   return attack_anim_last;
end

procedure get_attack_anim(variable weapon,variable attack_type) begin
   variable attack_anim;
   variable attack_anim_arr;
   variable index;
   if attack_type >= ATKTYPE_LWEP_RELOAD andAlso attack_type <= ATKTYPE_RWEP_RELOAD then begin
      return -1;
   end
   //kick
   if attack_type == ATKTYPE_KICK orElse (attack_type >= ATKTYPE_STRONGKICK andAlso attack_type <= ATKTYPE_PIERCINGKICK) then begin
      return ANIM_kick_leg;
   end
   //punch
   if weapon <= 0 then begin
      return ANIM_throw_punch;
   end
   attack_anim_arr = [ANIM_stand, ANIM_throw_punch, ANIM_kick_leg, ANIM_swing_anim, ANIM_thrust_anim, ANIM_throw_anim, ANIM_fire_single, ANIM_fire_burst, ANIM_fire_continuous];
   if attack_type == ATKTYPE_LWEP1 OrElse attack_type == ATKTYPE_RWEP1 then begin
      index = get_proto_data(obj_pid(weapon), PROTO_FLAG_EXT) bwand 0x0000000F;
   end
   else begin
      index = (get_proto_data(obj_pid(weapon), PROTO_FLAG_EXT) bwand 0x000000F0) / 16;
   end
   attack_anim = attack_anim_arr[index];
   return attack_anim;
end

//by Phobos2077 https://github.com/phobos2077/fo2_ecco/blob/f5df1e4edfe03c2df30fcf26f38ce8e2bdae4a4c/scripts_src/_pbs_main/gl_pbs_damage_mod.ssl#L515
procedure validate_critter_anim(variable critter, variable animType) begin
   variable objFid := obj_art_fid(critter);
   //variable rot := objFid bwand 0x70000000;
   // This is based on vanilla logic from art_id_()
   if (animType != ANIM_fire_dance and animType >= ANIM_fall_back and animType <= ANIM_fall_front_blood) then begin
      if (art_exists(critter_anim_fid(objFid, animType, 1))) then
         return true;
   end
   return art_exists(critter_anim_fid(objFid, animType, 0));
end

procedure clear_imported_arr begin
   clear_array(import_alt_attack_aoe_targets_arr);
end

procedure callback_ui_disable begin
   if resting <= 0 then begin
      game_ui_disable2;
      call callback_set_cursor_animated_watch in 0;
   end
end

procedure show_poison_dmg_msg(variable target, variable target_cur_hp, variable dmg_value) begin
   variable target_name;
   variable losblock;
   //return if no target
   if target > 0 then begin
       //npc msg
      if target != real_dude_obj then begin
         if HR_fog_of_war > 0 then
            losblock = obj_blocking_line(dude_obj, tile_num(target), BLOCKING_TYPE_SIGHT);

         if losblock <= 0 then begin
            target_name = obj_name(target);
            // not dead
            if target_cur_hp > dmg_value then begin
               display_msg(parse_str_2(modmsg(msg_npc_poison_dmg), target_name, dmg_value));
            end
            //dead
            else begin
               display_msg(parse_str_2(modmsg(msg_npc_poison_dmg_deadly), target_name, dmg_value));
            end
         end
      end
      //real_dude msg
      else begin
         if target_cur_hp > dmg_value then begin
            display_msg(parse_str_2(modmsg(msg_player_poison_dmg), -1, dmg_value));
         end
         else begin
            display_msg(parse_str_2(modmsg(msg_player_poison_dmg_deadly), -1,dmg_value));
         end
      end
   end
end

procedure kill_dude begin
   variable target_frm;
   if dude_must_die <= 0 then
      return;

   target_frm = art_anim(obj_art_fid(dude_must_die));
   if (target_frm >= ANIM_bad_landing_sf andAlso target_frm <= ANIM_fall_front_blood_sf) then begin
      critter_heal(dude_must_die, -((get_critter_stat(dude_must_die,STAT_max_hp)+get_critter_stat(dude_must_die,STAT_max_hp))*3));
      if dude_must_die == real_dude_obj then begin
         call perception_disable;
         terminate_combat;
         game_ui_enable;
      end
      else
         dude_must_die = 0;
   end
   else begin
      call critter_inflict_poison_dmg(dude_must_die, ((get_critter_stat(dude_must_die,STAT_max_hp)+get_critter_stat(dude_must_die,STAT_max_hp))*3), 1);
   end
end


procedure itemDestroyAllHidden(variable obj) begin
   variable num_items = inven_count(obj);
   variable item;
   while (num_items > 0) do begin
      item = inven_ptr(obj, num_items);
      num_items -= 1;
      if item <= 0 orElse ((get_proto_data(obj_pid(item), PROTO_FLAG_EXT) bwand HIDDEN_ITEM) == 0) then
         continue;

      rm_obj_from_inven(obj, item);
      destroy_object(item);
   end

end

procedure kill_critter_no_anim(variable target) begin
   variable target_flags = get_flags(target);
   variable target_sid = get_object_data(target, OBJ_DATA_SID);
   if sfall_510 > 0 then
      reg_anim_clear_forced(target, sfall_510);
   else
      reg_anim_clear(target);

   combat_delete_critter(target);
   party_remove(target);
   set_flags(target, (target_flags bwor FLAG_NOBLOCK bwor FLAG_FLAT bwand bwnot(FLAG_LIGHTING)));
   if target_sid != -1 then begin
      call_offset_v1(0x4A61D4, target_sid);
      set_object_data(target, OBJ_DATA_SID, -1);
   end
   //clear drugs
   write_int(0x518438, target);
   call_offset_v2(0x4A2790, EVENT_TYPE_DRUG, 0x42DA54); //queue_clear_type

   call itemDestroyAllHidden(target);
   tile_refresh_display;
end


procedure show_death_msg begin
   variable target;
   variable target_death_frm;
   variable target_sid;
   variable target_frm;
   variable death_array_len;
   variable force_sf_anim_death;
   variable i;
   death_array_len = len_array(death_array);
   force_sf_anim_death = resting + after_rest_death + map_enter;
   if (dude_must_die > 0 or dude_turn_critter_dies > 0) andAlso not(game_ui_is_disabled) then begin
      game_ui_disable2;
      if dude_turn_critter_dies > 0 then
         set_cursor_animated_watch;
   end
   if death_array_len > 0 then begin
      for (i = death_array_len - 1; i >= 0; i--) begin
         target = array_key(death_array, i);
         if target <= 0 then
            continue;

         target_death_frm = get_array(death_array, target);
         target_frm = art_anim(obj_art_fid(target));
         if force_sf_anim_death > 0 orElse target_frm == target_death_frm orElse (target_frm >= ANIM_bad_landing_sf andAlso target_frm <= ANIM_fall_front_blood_sf) orElse anim_busy(target) == 0 then begin
           set_object_data(target, OBJ_DATA_DAMAGE_FLAGS, (get_object_data(target, OBJ_DATA_DAMAGE_FLAGS) bwand NOT_DAM_DEAD));
           set_array(death_array, target, 0);
            target_sid = get_object_data(target, OBJ_DATA_SID);

            if target != dude_obj then
               poison(target, -(get_poison(target) * 2));

            if target_sid > 0 then begin
               exec_obj_script_proc(target_sid, destroy_proc);
            end
            set_outline(target,  OUTLINE_NONE);
            if target != dude_must_die then begin

               if force_sf_anim_death > 0 orElse (target_frm < ANIM_bad_landing_sf orElse target_frm > ANIM_fall_front_blood_sf) then begin
                  if validate_critter_anim(target, ANIM_fall_front_blood_sf) then
                     target_frm = ANIM_fall_front_blood_sf;
                  else
                     target_frm = ANIM_fall_back_blood_sf;
               end


               critter_heal(target, -get_critter_stat(target, STAT_current_hp));
               //if validate_critter_anim(target, target_frm) <= 0 then begin
                  //target_frm = -1;
                  //call kill_critter_no_anim(target);
               //end
               //else
                  //kill_critter(target, target_frm);
            end
            else begin
               call kill_dude;
            end
         end
      end
   end
   death_array_len = len_array(death_array);

   if death_array_len <= 0 then begin
      death_array_active = 0;
      if dude_turn_critter_dies > 0 then begin
         dude_turn_critter_dies = 0;
         set_global_script_type(3);
         set_global_script_repeat(0);
      end
      if (dude_turn == dude_obj orElse not(combat_is_initialized)) then begin
         set_cursor_hidden;
         game_ui_enable;
      end
      death_msg_called = 0;
      call perception_enable;
      return;
   end
   else if death_msg_called <= 0 then begin
      call show_death_msg in 1;
      death_msg_called = 1;
   end
end

procedure get_death_anim_poison(variable target, variable dmg_value) begin
   variable death_anim = ANIM_fall_back;
   variable target_cur_anim = art_anim(obj_art_fid(target));
   variable is_front_hit;
   variable dmg_type;
   //add target to array of creatures that will die. critter_PTR as key, dmg as value
   death_array_active = 1;

   //Death animation for target in death anim
   //if is_in_death_anim(target_cur_anim) then begin
      //death_anim = target_cur_anim;
   //end
   //Death animation for SPECIAL_DEATH
   if (get_proto_data(obj_pid(target), PROTO_CR_FLAGS) bwand CFLG_SPECIAL) == CFLG_SPECIAL then begin
      death_anim = ANIM_exploded_to_nothing;
   end
   //Death animation for a knocked out target
   else if target_cur_anim == ANIM_fall_back orElse target_cur_anim == ANIM_fall_back_sf then begin
      death_anim = ANIM_fall_back_blood;
   end
   else if target_cur_anim == ANIM_fall_front orElse target_cur_anim == ANIM_fall_front_sf then begin
      death_anim = ANIM_fall_front_blood;
   end
   //Death animation for a standing target
   else begin
      is_front_hit = random(0,1);
      //standard death_anim
      if dmg_type == DMG_normal_dam then begin
         death_anim = ANIM_fall_front - is_front_hit;
      end
   end
   if not(validate_critter_anim(target, death_anim)) then begin
       death_anim = ANIM_fall_front - is_front_hit;

       if not(validate_critter_anim(target, death_anim)) then
           death_anim = ANIM_fall_back + is_front_hit;
   end
   return death_anim;
end

procedure close_all_wins(variable game_mode) begin
   variable ui_is_disabled;
   if game_mode <= 0 orElse game_mode == COMBAT orElse game_mode == (COMBAT bwor PCOMBAT) then
      return;

   ui_is_disabled = game_ui_is_disabled;

   //if game_mode bwand (SKILLDEX bwor INVENTORY bwor INTFACELOOT bwor INTFACEUSE bwor AUTOMAP bwor CHARSCREEN bwor HELP bwor HEROWIN) then begin
      //game_ui_enable;
      //tap_key(DIK_ESCAPE);
      //if ui_is_disabled > 0 then
         //game_ui_disable2;
   //end
   //else begin
      if (game_mode bwand COUNTERWIN) orElse (game_mode == DIALOG) then begin
         if game_mode == DIALOG then
            write_int(0x518718, 0);//set _dialogue_switch_mode to 0
         game_ui_enable;
         tap_key(DIK_ESCAPE);
         if ui_is_disabled > 0 then
            game_ui_disable2;
      end
      fake_quit = 2;
      write_int(0x5186CC, fake_quit);//set _game_user_wants_to_quit to 2
   //end
end

procedure critter_inflict_poison_dmg(variable target,variable dmg_value, variable animate) begin
   variable target_cur_hp;
   variable target_team;
   variable who_hit_target;
   variable death_anim;
   variable death_anim_part2;
   variable death_anim_sf;
   variable combat_xp_bonus;
   variable dead_attacker;
   variable game_mode;
   variable final_death_art;
   variable no_sound;
   //check target
   if target <= 0 then
      return;

   if obj_type(target) != OBJ_TYPE_CRITTER orElse get_array(death_array,target) > 0 then
      return;

   if map_enter > 0 andAlso animate <= 1 then
      animate = 0;

   target_cur_hp = get_critter_stat(target, STAT_current_hp);
   target_team = has_trait(TRAIT_OBJECT, target, OBJECT_TEAM_NUM);
   if is_really_dead(target, critter_state(target), target_cur_hp) then
      return;

   if map_enter <= 0 then
      call show_poison_dmg_msg(target, target_cur_hp, dmg_value);

   //cause non-lethal damage
   if target_cur_hp > dmg_value then begin
      critter_heal(target, -dmg_value);
   end
   //cause lethal POISON damage
   else begin
      game_mode = get_game_mode;
      call perception_disable;
      if game_mode <= 0 orElse game_mode == COMBAT orElse game_mode == (COMBAT bwor PCOMBAT) then
         delayed_ui_disable = 0;
      else
         delayed_ui_disable = 1;

      if target == dude_obj then begin
         if ((game_mode bwand WORLDMAP) == WORLDMAP) orElse (combat_data > 0 andAlso get_object_data(combat_data, C_ATTACK_TARGET) > 0 andAlso anim_busy(dude_obj) < 0) then begin
            critter_heal(target, -((get_critter_stat(target, STAT_current_hp) + get_critter_stat(target, STAT_max_hp)) * 3));
            return;
         end
         else if dude_must_die <= 0 then begin
            call close_all_wins(game_mode);
            set_global_script_type(3);
            set_global_script_repeat(1);
            dude_must_die = dude_obj;
         end
      end
      else if target == dialog_obj orElse target == loot_obj then
         call close_all_wins(game_mode);
      else if game_mode bwand INTFACEUSE then
         tap_key(DIK_ESCAPE);

      if game_mode bwand WORLDMAP then begin
         animate = 0;
         if is_in_array(target, party_member_list(1)) then begin
            if not(array_exists(party_member_remove_arr)) then begin
               party_member_remove = 1;
               party_member_remove_arr = create_array_map;
            end
            set_array(party_member_remove_arr, len_array(party_member_remove_arr), get_object_data(target, OBJ_DATA_ID));
         end
      end
      else if dude_must_die <= 0 andAlso (resting + after_rest_death) > 0 then
         animate = 0;

      death_anim = art_anim(obj_art_fid(target));
      if is_in_death_anim(death_anim) then begin
         no_sound = 1;
      end
      else
         death_anim = get_death_anim_poison(target, dmg_value);

      rm_timer_event(target);

      final_death_art = death_anim;
      if target != dude_must_die then begin
         set_object_data(target, OBJ_DATA_CUR_HP, 0);
         set_object_data(target, OBJ_DATA_DAMAGE_FLAGS, (get_object_data(target, OBJ_DATA_DAMAGE_FLAGS) bwor DAM_DEAD));
      end

      if animate <= 0 then begin
         set_array(death_array, target, final_death_art);
         call show_death_msg;
      end
      else begin
         reg_anim_combat_check(0);
         if sfall_510 > 0 then
            reg_anim_clear_forced(target, sfall_510);
         else
            reg_anim_clear(target);

         reg_anim_func(REG_ANIM_BEGIN, RB_RESERVED);
         reg_anim_set_priority(sfall_510);
         if delayed_ui_disable <= 0 then begin
            reg_anim_callback(callback_ui_disable);
         end
         //standard death anim
         if death_anim == ANIM_fall_back or death_anim == ANIM_fall_front then begin
            death_anim_part2 = death_anim + 14;
            reg_anim_animate(target, death_anim, 0);
            if no_sound <= 0 then
               reg_anim_play_sfx(target,sfx_build_char_name(target,death_anim,snd_knock_down),1);
            if validate_critter_anim(target, death_anim_part2) then begin
               death_anim_sf = death_anim_part2 + 28;
               if no_sound <= 0 then
                  reg_anim_play_sfx(target,sfx_build_char_name(target,death_anim_part2,snd_knock_down),-1);
               reg_anim_animate(target, death_anim_part2, -no_sound);
               final_death_art = death_anim_part2;
            end
            else begin
               death_anim_sf = death_anim + 28;
            end
         end
         //KO target death
         else if death_anim == ANIM_fall_back_blood or death_anim == ANIM_fall_back_blood then begin
            death_anim_sf = death_anim + 28;
            reg_anim_animate(target, death_anim, 0);
            if no_sound <= 0 then
               reg_anim_play_sfx(target,sfx_build_char_name(target,death_anim,snd_knock_down),1);
         end
         //brutal fire_dance death
         else if death_anim == ANIM_fire_dance then begin
            death_anim_part2 = death_anim - 4;
            death_anim_sf = death_anim_part2 + 28;
            reg_anim_animate(target, death_anim, 0);
            if no_sound <= 0 then
               reg_anim_play_sfx(target,sfx_build_char_name(target,death_anim,snd_knock_down),1);
            if validate_critter_anim(target, death_anim_part2) then begin
               if no_sound <= 0 then
                  reg_anim_play_sfx(target,sfx_build_char_name(target,death_anim_part2,snd_knock_down),-1);
               reg_anim_animate(target, death_anim_part2, -no_sound);
               final_death_art = death_anim_part2;
            end
         end
         //brutal death
         else begin
            death_anim_sf = death_anim + 28;
            reg_anim_animate(target, death_anim, 0);
            if no_sound <= 0 then
               reg_anim_play_sfx(target,sfx_build_char_name(target,death_anim,snd_knock_down),1);
         end
         if validate_critter_anim(target, death_anim_sf) then begin
            reg_anim_animate(target, death_anim_sf, -1);
            final_death_art = death_anim_sf;
         end
         reg_anim_callback(show_death_msg);
         reg_anim_end();
         set_array(death_array, target, final_death_art);
      end
   end
   //increase combat_xp and increase kill_count
   if combat_is_initialized then begin
      if target_team != TEAM_PLAYER then begin
         //inc combat exp
         if Sonora <= 0 then begin
            combat_xp_bonus = get_combat_exp + get_critter_xp(target);
            set_combat_exp(combat_xp_bonus);
         end
         inc_kill_count(critter_kill_type(target));
      end
      else begin
         inc_kill_count(critter_kill_type(target));
      end
   end
   else begin
      if Sonora <= 0 andAlso target_team != TEAM_PLAYER then begin
         give_exp_points(get_critter_xp(target));
      end
   end
end

procedure DEATHANIM2 begin
   variable target = get_sfall_arg_at(2);
   variable death_anim;
   variable poison_to_add;
   variable new_death_anim;
   if target > 0 then begin
      death_anim = get_sfall_arg_at(4);
      new_death_anim = -1;
      poison_to_add = get_array(array_add_poison, target);
      if poison_to_add > 0 andAlso (get_poison_float(target, get_unique_id(target)) + (poison_to_add - ((poison_to_add * get_critter_stat(target,STAT_poison_resist)) / 100)) >= calc_poison_overdose(target)) then begin
         if (get_proto_data(obj_pid(target), PROTO_CR_FLAGS) bwand CFLG_SPECIAL) != 0 then
            return;

         death_anim = ANIM_fall_front;
         if validate_critter_anim(target, death_anim) then
            new_death_anim = ANIM_fall_back;
      end

      if new_death_anim >= 0 then begin
         set_sfall_return(new_death_anim);
         set_sfall_arg(4, new_death_anim);
      end
   end
end

procedure get_PERK_faster_healing_bonus begin
   variable PERK_faster_healing_count = has_trait(TRAIT_PERK, real_dude_obj, PERK_faster_healing);
   variable PERK_faster_healing_bonus;
   variable dude_extra_heal_rate = get_critter_stat(real_dude_obj, STAT_heal_rate);
   if PERK_faster_healing_count > 0 then begin
      critter_rm_trait(real_dude_obj, TRAIT_PERK, PERK_faster_healing, 1);
      PERK_faster_healing_bonus = dude_extra_heal_rate - get_critter_stat(real_dude_obj, STAT_heal_rate);
      critter_add_trait(real_dude_obj, TRAIT_PERK, PERK_faster_healing, 1);
   end
   else begin
      critter_add_trait(real_dude_obj, TRAIT_PERK, PERK_faster_healing, 1);
      PERK_faster_healing_bonus = get_critter_stat(real_dude_obj, STAT_heal_rate) - dude_extra_heal_rate;
      critter_rm_trait(real_dude_obj, TRAIT_PERK, PERK_faster_healing, 1);
   end
   if PERK_faster_healing_bonus >= 0 then
      faster_healing_bonus = PERK_faster_healing_bonus;
   else
      faster_healing_bonus = 2;
end

procedure get_dude_base_heal_rate begin
   variable heal_rate;
   heal_rate = get_real_dude_real_base_stat(STAT_heal_rate);
   heal_rate += has_trait(TRAIT_PERK, real_dude_obj, PERK_faster_healing) * faster_healing_bonus;
   return heal_rate;
end

procedure newperks begin
   variable poison_mastery;
   if RegenMod > 0 andAlso has_fake_perk(regen_perk_name) <= 0 andAlso get_dude_base_heal_rate >= min_hr_to_regen then begin
      display_msg(regen_perk_acquired_msg);
      set_fake_perk(regen_perk_name, 1, 79, regen_perk_description);
   end
   if PoisonMod > 0 andAlso perk_poison_mastery_was_add != -1 then begin
      poison_mastery = has_fake_perk(perk_poison_mastery_name);
      if PoisonMod > 0 andAlso perk_poison_mastery_was_add <= 0 andAlso get_pc_stat(PCSTAT_level) >= 6 - (4 * has_trait(TRAIT_TRAIT,dude_obj,TRAIT_skilled)) andAlso poison_mastery <= 0 andAlso (has_skill(real_dude_obj, SKILL_SCIENCE) > 49 or has_skill(real_dude_obj, SKILL_OUTDOORSMAN) > 69) then begin
         set_selectable_perk(perk_poison_mastery_name, 1, 102, perk_poison_mastery_description);
         perk_poison_mastery_was_add = 1;
      end
      if poison_mastery > 0 then begin
         set_selectable_perk(perk_poison_mastery_name, 0, 102, perk_poison_mastery_description);
         if poison_mastery > 1 then begin
            poison_mastery -= 1;
            set_perk_owed(get_perk_owed + poison_mastery);
            set_fake_perk(perk_poison_mastery_name, 1, 102, perk_poison_mastery_description);
         end
         perk_poison_mastery_was_add = -1;
      end
   end
end

procedure npc_max_hr_add_regen_items begin
   variable critter = npc_overhealed;
   variable stim_amount = npc_overhealed_stimpak_amount;
   variable powder_amount = npc_overhealed_powder_amount;
   if critter <= 0 orElse (stim_amount <= 0 andAlso powder_amount <= 0) then
      return;

   if combat_is_initialized andAlso art_anim(obj_art_fid(critter)) == ANIM_magic_hands_middle then begin
      call npc_max_hr_add_regen_items in 1;
      return;
   end
   if stim_amount > 0 then begin
      add_mult_objs_to_inven(critter, create_object_sid(PID_STIMPAK, 0, 0, -1), stim_amount);
   end
   if powder_amount > 0 then begin
      add_mult_objs_to_inven(critter, create_object_sid(PID_HEALING_POWDER, 0, 0, -1), powder_amount);
   end
   npc_overhealed = 0;
   npc_overhealed_stimpak_amount = 0;
   npc_overhealed_powder_amount = 0;
end

procedure npc_max_hr_rm_regen_items(variable critter) begin
   variable stim_amount = obj_is_carrying_obj_pid(critter, PID_STIMPAK);
   variable powder_amount = obj_is_carrying_obj_pid(critter, PID_HEALING_POWDER);
   variable powder_ptr;
   variable sitm_ptr;
   variable tmp;
   call npc_max_hr_add_regen_items;
   if stim_amount > 0 then begin
      npc_overhealed = critter;
      npc_overhealed_stimpak_amount = stim_amount;
      if npc_overhealed_stimpak_amount > 1 andAlso not(combat_is_initialized) then begin
         npc_overhealed_stimpak_amount -= 1;
      end
      sitm_ptr = obj_carrying_pid_obj(critter, PID_STIMPAK);
      tmp = rm_mult_objs_from_inven(critter, sitm_ptr, (stim_amount));
      destroy_object(sitm_ptr);
   end

   if powder_amount > 0 then begin
      npc_overhealed = critter;
      npc_overhealed_powder_amount = stim_amount;
      if npc_overhealed_powder_amount > 1 andAlso not(combat_is_initialized) then begin
         npc_overhealed_powder_amount -= 1;
      end
      if npc_overhealed_powder_amount > 1 andAlso not(combat_is_initialized) then begin
         npc_overhealed_powder_amount -= 1;
      end
      powder_ptr = obj_carrying_pid_obj(critter, PID_HEALING_POWDER);
      tmp = rm_mult_objs_from_inven(critter, powder_ptr, (powder_amount));
      destroy_object(powder_ptr);
   end
   call npc_max_hr_add_regen_items in 3;
end

procedure check_and_set_poison_drug(variable drug_pid) begin
   variable drug_poison;
   variable i;
   if drug_pid <= 0 orElse get_proto_data(drug_pid,PROTO_IT_TYPE) != item_type_drug then
      return;

   for (i := 0; i <= 2; i++) begin
      if (get_proto_data(drug_pid,PROTO_DR_STAT_A + (4 * i)) == STAT_current_poison) orElse (i == 0 andAlso (get_proto_data(drug_pid,PROTO_DR_STAT_A) == -2) andAlso (get_proto_data(drug_pid,PROTO_DR_STAT_B) == STAT_current_poison)) then begin
         drug_poison = get_proto_data(drug_pid, PROTO_DR_AMOUNT_1_A + (4 * i)) + get_proto_data(drug_pid, PROTO_DR_AMOUNT_2_A + (4 * i)) + get_proto_data(drug_pid, PROTO_DR_AMOUNT_3_A + (4 * i));
         drug_poison = ceil(drug_poison / 6.0);
         if drug_poison > 50 then begin
            drug_poison = 50;
         end
         set_proto_data(drug_pid, PROTO_DR_AMOUNT_1_A + (4 * i), drug_poison);
         set_proto_data(drug_pid, PROTO_DR_AMOUNT_2_A + (4 * i), 0);
         set_proto_data(drug_pid, PROTO_DR_AMOUNT_3_A + (4 * i), 0);
      end
   end
end


procedure weapon_is_poisonable(variable weapon,variable used_in_USEOBJON) begin
   variable weapon_pid;
   variable weapon_anim;
   variable weapon_damage_type;
   variable allowed_weapons;
   variable disabled_weapons;
   if weapon <= 0 orElse obj_item_subtype(weapon) != item_type_weapon then
      return 0;

   weapon_pid = obj_pid(weapon);
   if array_exists(PoisonedWeapons) andAlso PoisonedWeapons[weapon_pid] > 0 then begin
      if used_in_USEOBJON > 0 then begin
         set_sfall_return(0);
         display_msg(parse_str_2(modmsg(msg_wpn_poison_full_no_apply), 0, obj_name(weapon)));
      end
      return 0;
   end

   weapon_anim = get_proto_data(weapon_pid, PROTO_WP_ANIM);
   weapon_damage_type = get_proto_data(weapon_pid, PROTO_WP_DMG_TYPE);
   if Resurrection > 0 then begin
      disabled_weapons = [-5];
      allowed_weapons = [PID_SPIKED_KNUCKLES, PID_PLANT_SPIKE, PID_MEGA_POWER_FIST, 600];
   end
   else if Nevada > 0 then begin
      disabled_weapons = [-5];
      allowed_weapons = [112, PID_SPIKED_KNUCKLES, PID_PLANT_SPIKE, PID_MEGA_POWER_FIST, 740];
   end
   else if Sonora > 0 then begin
      disabled_weapons = [180];
      allowed_weapons = [58,127,128,190];
   end
   else if Megamod > 0 then begin
      disabled_weapons = [-5];
      allowed_weapons = [365,738,740,959];
   end
   else if Olympus2207 > 0 then begin
      disabled_weapons = [61];
      allowed_weapons = [37,39,40,107,109,217,514,515,516,517,518,519,520,521,522,523,524];
   end
   else begin
      disabled_weapons = [-5];
      allowed_weapons = [PID_SPIKED_KNUCKLES, PID_PLANT_SPIKE, PID_MEGA_POWER_FIST, 583, 638, 640];// + ecco
   end

   if is_in_array(weapon_pid, allowed_weapons)
      orElse (array_exists(PoisonableWeapons) andAlso is_in_array(weapon_pid, PoisonableWeapons))
      orElse (not(is_in_array(weapon_pid, disabled_weapons))
      andAlso weapon_damage_type == DMG_normal_dam
      andAlso (weapon_anim == WPN_ANIM_KNIFE
         orElse weapon_anim == WPN_ANIM_SPEAR
         orElse weapon_anim == 0x0E))
      then begin
         return 1;
   end
end

procedure get_poisonable_weapon_target_hands_USEOBJON(variable target, variable skip_right_hand) begin
   variable poisonable_weapon;
   if target <= 0 then
      return 0;

   if skip_right_hand <= 0 then begin
      poisonable_weapon = get_active_weapon(target);
   end

   if poisonable_weapon <= 0 orElse weapon_is_poisonable(poisonable_weapon, true) <= 0 then begin
      poisonable_weapon = get_non_active_weapon(target);
      if weapon_is_poisonable(poisonable_weapon, true) <= 0 then begin
         poisonable_weapon = 0;
      end
   end

   return poisonable_weapon;
end

procedure weapon_apply_poison_USEOBJON(variable target, variable user, variable tail_pid) begin
   variable poisonable_weapon;
   variable weapon_cur_poison;
   variable weapon_new_poison;
   variable weapon_max_poison;
   variable poisonable_weapon_name;
   variable weapon_pid;
   variable poison_mastery;
   variable poison_perk_name;
   variable lost_chance;
   variable tar_name;
   variable user_name;
   variable last_poison;
   variable poison_is_full;
   variable msg;
   if target <= 0 then
      return 0;

   if user <= 0 then
      user = target;

   poisonable_weapon = get_poisonable_weapon_target_hands_USEOBJON(target, false);

   if poisonable_weapon <= 0 then
      return;

   tar_name = obj_name(target);
   user_name = obj_name(user);

   weapon_pid = obj_pid(poisonable_weapon);
   poisonable_weapon_name = proto_data(weapon_pid, 1);
   poison_perk_name = envenomed_msg + poisonable_weapon_name;
   weapon_cur_poison = has_fake_perk_npc(target, poison_perk_name);
   poison_mastery = has_fake_perk_npc(user, perk_poison_mastery_name);
   weapon_new_poison = weapon_cur_poison + 5 + (20 * poison_mastery);
   weapon_max_poison = 10 + (5 * poison_mastery);
   if weapon_cur_poison >= weapon_max_poison then begin
      display_msg(parse_str_2(modmsg(msg_wpn_poison_full_no_apply), user_name, poisonable_weapon_name));
      if poisonable_weapon != get_non_active_weapon(target) then
         poisonable_weapon = get_poisonable_weapon_target_hands_USEOBJON(target, true);
      else
         poisonable_weapon = 0;

      if poisonable_weapon <= 0 then begin
         set_sfall_return(0);
         return;
      end
      else begin
         weapon_pid = obj_pid(poisonable_weapon);
         poisonable_weapon_name = proto_data(weapon_pid, 1);
         poison_perk_name = envenomed_msg + poisonable_weapon_name;
         weapon_cur_poison = has_fake_perk_npc(target, poison_perk_name);
         weapon_new_poison = weapon_cur_poison + 5 + (20 * poison_mastery);
         if weapon_cur_poison >= weapon_max_poison then begin
            display_msg(parse_str_2(modmsg(msg_wpn_poison_full_no_apply), user_name, poisonable_weapon_name));
            set_sfall_return(0);
            return;
         end
      end
   end

   //add to check arr
   if weapon_cur_poison <= 0 then begin
      if PoisonableWeapons_timer <= 0 then begin
         PoisonableWeapons_timer = 1;
         if poison_mastery <= 0 then
            add_global_timer_event(poisoned_weapon_check_time, fixed_param_poison_perk_rm);
         else
            add_global_timer_event(poisoned_weapon_check_time_perk, fixed_param_poison_perk_rm);
      end
      call add_to_poisoned_perk_weapons(weapon_pid);
   end


   if weapon_new_poison >= weapon_max_poison then begin
      weapon_new_poison = weapon_max_poison;
      poison_is_full = 1;
   end

   set_fake_perk_npc(target, poison_perk_name, weapon_new_poison, 23, envenomed_description_msg);

   if poison_mastery > 0 then
      lost_chance = 1;
   else if get_proto_data(tail_pid,PROTO_IT_WEIGHT) > 1 then
      lost_chance = 5;
   else
      lost_chance = 15;

   if random(1, 100) <= lost_chance then begin
      set_sfall_return(1);
      if user == dude_obj then begin
         if target != dude_obj then begin
            msg = parse_str_2(modmsg(msg_gland_gone_npc_player_user), tar_name, poisonable_weapon_name);
         end
         else begin
            msg = parse_str_2(modmsg(msg_gland_gone), user_name, poisonable_weapon_name);
         end
         if poison_is_full > 0 then
            msg += modmsg(msg_wpn_poison_full_add);
      end
      else begin
         msg = parse_str_2(modmsg(msg_gland_gone_npc_use), user_name, poisonable_weapon_name);
      end
   end
   else begin
      set_sfall_return(0);
      if user == dude_obj then
         if poison_is_full > 0 then
            msg = parse_str_2(modmsg(msg_wpn_poison_full), user_name, poisonable_weapon_name);
         else
            msg = parse_str_2(modmsg(msg_pois_appl_player), user_name, poisonable_weapon_name);
      else
         msg = parse_str_2(modmsg(msg_pois_appl_npc), user_name, poisonable_weapon_name);
   end

   display_msg(msg);
end


procedure check_regen_tag begin
   variable hr;
   variable color;
   variable text;
   variable percent;
   //variable hp_missing;
   //variable next_regen;

   if RegenMod <= 0 then
      return;
   hr = get_critter_stat(dude_obj, STAT_heal_rate);
   if hr >= min_hr_to_regen andAlso (combat_is_initialized orElse (dude_cur_hits < dude_max_hits orElse has_fake_perk_npc(dude_obj, regen_perk_name) <= 0) orElse (PoisonMod > 0 andAlso get_poison(dude_obj) > 0)) then begin
      if hr == gLastTagHr then
         return;

      gLastTagHr = hr;
      text = modmsg(msg_heal_tag);
      if hr >= 40 then begin
         color = 0;
         //next_regen = calc_regen_tick(dude_obj, hr);
      end
      else if hr >= 20 then
         color = 3; // yellow
      else
         color = 2; // white
      //else if hr >= 10 then
         //color = 7;
      //else
         //color = 1;
      //else begin
         //hp_missing = get_critter_stat(dude_obj, STAT_max_hp) - get_critter_stat(dude_obj, STAT_current_hp);
         //next_regen = calc_regen_tick(dude_obj, hr);
         //if next_regen >= hp_missing then
            //color = 0;
         //else
            //color = 2;
      //end
      //if next_regen > 0 then

   //if hr <= 6 then
      //percent = 1;
   //else if hr >= 40 then
      //percent = 100;
   //else
      //percent = ceil(((hr) / 40.0) * 100.0);
      //if hr <= 9 then
         //text += ":  " +hr;
      //else
         //text += ": " +hr;
      if is_iface_tag_active(iface_tag_regen) <= 0 then begin
         set_iface_tag_text(iface_tag_regen,text, color);
         show_iface_tag(iface_tag_regen);
      end
      else begin
         set_iface_tag_text(iface_tag_regen,text, color);
      end
   end
   else if is_iface_tag_active(iface_tag_regen) > 0 then begin
      gLastTagHr = 0;
      hide_iface_tag(iface_tag_regen);
   end
end


procedure dude_apply_and_display_stat(variable stat, variable stat_value, variable is_timer_event, variable forced_display, variable apply_stats = 1) begin
   variable cur_stat;
   variable displayed_stat_value;
   variable new_stat_value;
   variable cur_map_enter;
   if stat < STAT_st orElse stat > STAT_current_rad then
      return;

   if apply_stats > 0 then begin
      cur_stat = get_critter_stat(dude_obj, stat);
      if stat == STAT_current_hp then begin
         if stat_value < 0 then begin
            forced_display = 1;
            cur_map_enter = map_enter;
            if cur_map_enter <= 0 then begin
               map_enter = 1;
               call critter_inflict_poison_dmg(dude_obj, -stat_value, 2);
               map_enter = cur_map_enter;
            end
            else
               call critter_inflict_poison_dmg(dude_obj, -stat_value, 1);
         end
         else
            critter_heal(dude_obj, stat_value);
      end
      else
         set_critter_extra_stat(dude_obj, stat, get_critter_extra_stat(dude_obj, stat) + stat_value);
   end
   if forced_display > 0 then
      displayed_stat_value = stat_value;
   else if apply_stats > 0 then begin
      new_stat_value = get_critter_stat(dude_obj, stat);
      displayed_stat_value = new_stat_value - cur_stat;
   end
   if displayed_stat_value > 0 then
      display_msg(string_format(message_str_game(GAME_MSG_ITEM, 1), displayed_stat_value, message_str_game(GAME_MSG_STAT, 100 + stat))); // You gained %d %s.
   else if displayed_stat_value == 0 then begin
      if forced_display <= 0 andAlso is_timer_event <= 0 then
         display_msg(message_str_game(GAME_MSG_ITEM, 10)); // Nothing happens.
   end
   else begin
      display_msg(string_format(message_str_game(GAME_MSG_ITEM, 2), -displayed_stat_value, message_str_game(GAME_MSG_STAT, 100 + stat))); // You lost %d %s.
   end

   if stat == STAT_heal_rate andAlso cur_stat < min_hr_to_regen andAlso new_stat_value >= min_hr_to_regen then
      call check_regen_tag;
end

procedure isPotentialPartyMember(variable critter) begin
   variable critter_pid;
   if sfall_510 > 0 then
      return obj_is_party_member(critter);
   else begin
      critter_pid = obj_pid(critter);
      return get_array(F2MMR_POTENTIAL_PARTY_PIDs_ARRAY, critter_pid);
   end
end

procedure set_unique_id2(variable critter) begin
   variable critter_id = set_unique_id(critter);
   if isPotentialPartyMember(critter) > 0 then begin
      if critter_id > 83535 orElse critter_id < 18000 then begin
         critter_id = (obj_pid(critter) bwand 0xFFFFFF) + 18000;
         set_object_data(critter, OBJ_DATA_ID, critter_id);
      end
   end
   return critter_id;
end

procedure check_id(variable critter) begin
   variable last_id;
   last_id = get_array(ptr_to_id_array, critter);
   if last_id == 0 then begin
      last_id = set_unique_id2(critter);
      set_array(ptr_to_id_array, critter, last_id);
   end
   else if last_id != get_unique_id(critter) then begin
      set_object_data(critter, OBJ_DATA_ID, last_id);
   end
   return last_id;
end

procedure add_and_save_stats(variable critter, variable critter_id, variable stat, variable stat_value, variable apply_stats, variable is_timer_event) begin
   variable critter_id_arr_key;
   variable cur_saved_stat_value;
   variable saved_stats_counter;
   variable cur_stat;
   variable new_stat;
   variable cur_map_enter;
   variable npc_lvl;
   if stat < STAT_st orElse stat > STAT_current_rad then
      return;

   if critter == dude_obj then begin
      if apply_stats > 0 then begin
         call dude_apply_and_display_stat(stat, stat_value, is_timer_event, false);
      end
   end
   else begin
      critter_id = check_id(critter);
      if apply_stats > 0 then
         if stat == STAT_current_hp then begin
            if stat_value < 0 then begin
               cur_map_enter = map_enter;
               if cur_map_enter <= 0 then begin
                  map_enter = 1;
                  call critter_inflict_poison_dmg(critter, -stat_value, 2);
                  map_enter = cur_map_enter;
               end
               else
                  call critter_inflict_poison_dmg(critter, -stat_value, 1);
            end
            else
               critter_heal(critter, stat_value);
         end
         else
            set_critter_extra_stat(critter, stat, get_critter_extra_stat(critter, stat) + stat_value);

      if stat != STAT_current_hp andAlso critter != real_dude_obj then begin
         if isPotentialPartyMember(critter) > 0 then begin
            npc_lvl = get_npc_level(obj_pid(critter));
            if npc_lvl < 0 then
               npc_lvl = 0;
            set_array(party_levels, obj_pid(critter), npc_lvl);
         end

         //save stats for non-saveble in game files critter (and to restore for party after lvlup)
         critter_id_arr_key = get_saved_stats_key(critter_id);
         saved_stats_counter = has_saved_stats(critter_id_arr_key);
         cur_saved_stat_value = get_array(id_to_saved_stats, (critter_id_arr_key + stat));
         if cur_saved_stat_value == 0 then
            set_saved_stats_counter(critter_id_arr_key, saved_stats_counter + 1);

         set_array(id_to_saved_stats, (critter_id_arr_key + stat), cur_saved_stat_value + stat_value);
      end
      if stat == STAT_max_hp then begin
         cur_stat = get_critter_stat(critter, STAT_current_hp);
         new_stat = get_critter_stat(critter, STAT_max_hp);
         if cur_stat > new_stat then
            critter_heal(critter, 1);
      end
   end
end

procedure add_drug_effect_to_saved_arrays(variable critter, variable drug) begin
   variable critter_id = check_id(critter);
   variable critter_pid = obj_pid(critter);
   variable drug_pid = obj_pid(drug);
   variable drug_max_stats = 3;
   variable i;
   variable drug_stat;
   variable drug_stat_value;
   //add istant effect for non savebla in save game critter
   for (i = 0; i < drug_max_stats; i++) begin
      drug_stat = get_proto_data(drug_pid, (PROTO_DR_STAT_A + (4 * i)));
      if drug_stat >= 0 andAlso drug_stat <= STAT_poison_resist then
         drug_stat_value = get_proto_data(drug_pid, (PROTO_DR_AMOUNT_1_A + (4 * i)));

      if drug_stat_value != 0 then begin
         call add_and_save_stats(critter, critter_id, drug_stat, drug_stat_value, false, false);
      end
   end
   for (i = 0; i < drug_max_stats; i++) begin



   end
end

procedure has_custom_event_type(variable unique_id, variable event_type) begin
   variable event_key = get_first_event_key(unique_id);
   variable current_event_type;
   while event_key != 0 do begin
      current_event_type = get_array(event_queue_array, event_key + event_type_offset);
      if current_event_type == event_type then begin
         return 1;
      end
      event_key = get_array(event_queue_array, event_key + next_event_key_offset);
   end

   return 0;
end

procedure queue_add_burn_event(variable critter_id, variable time, variable stat, variable stat_value, variable stat2 = -1, variable stat2_value = 0) begin
   variable free_key = get_free_key_queue_event_array;
   variable new_key = free_key;
   variable first_event_key = get_first_event_key(critter_id);
   variable first_event_time = get_event_time(first_event_key);
   variable cur_key = first_event_key;
   variable cur_time = first_event_time;
   variable next_time;
   variable next_key;
   variable new_key_to_save = new_key + MAX_event_offset;
   variable free_key_char = get_free_key_queue_event_array_char;
   if new_key_to_save < forbidden_event_key andAlso new_key_to_save > -forbidden_event_key then begin
      new_key = forbidden_event_key;
      new_key_to_save = forbidden_event_key + MAX_event_offset;
   end
   if new_key_to_save >= INT32_MAX_key then begin
      new_key = INT32_MIN;
      new_key_to_save = new_key + MAX_event_offset;
      if free_key_char == 0 then
         free_key_char = "A";
      else
         free_key_char = sprintf("%c", charcode(free_key_char) + 1);

      set_free_key_queue_event_array_char(free_key_char);
   end
   set_free_key_queue_event_array(new_key_to_save);
   if free_key_char != 0 then
      new_key = free_key_char + new_key;

   set_array(event_queue_array, new_key + time_offset, time);
   set_array(event_queue_array, new_key + event_type_offset, EVENT_TYPE_BURN);
   if stat >= 0 andAlso stat_value != 0 then begin
      set_array(event_queue_array, new_key + stat_offset, stat);
      set_array(event_queue_array, new_key + stat_value_offset, stat_value);
   end
   else
      set_array(event_queue_array, new_key + stat_offset, -1);

   if stat2 >= 0 andAlso stat2_value != 0 then begin
      set_array(event_queue_array, new_key + stat2_offset, stat2);
      set_array(event_queue_array, new_key + stat2_value_offset, stat2_value);
   end
   else
      set_array(event_queue_array, new_key + stat2_offset, -1);


   // Check if its new event
   if first_event_key == 0 orElse (time < first_event_time) then begin
      set_first_event_key(critter_id, new_key);
      set_array(event_queue_array, new_key + next_event_key_offset, first_event_key);
      return;
   end

   cur_key = first_event_key;
   next_key = get_array(event_queue_array, first_event_key + next_event_key_offset);

   while (next_key != 0) do begin
      next_time = get_array(event_queue_array, next_key + time_offset);
      if (time < next_time) then begin
         break;
      end
      cur_key = next_key;
      next_key = get_array(event_queue_array, next_key + next_event_key_offset);
   end

   set_array(event_queue_array, new_key + next_event_key_offset, next_key);
   set_array(event_queue_array, cur_key + next_event_key_offset, new_key);
end

procedure queue_add_drug_event(variable critter_id, variable drug_pid, variable stat, variable stat_value, variable time) begin
   variable free_key = get_free_key_queue_event_array;
   variable new_key = free_key;
   variable first_event_key = get_first_event_key(critter_id);
   variable first_event_time = get_event_time(first_event_key);
   variable cur_key = first_event_key;
   variable cur_time = first_event_time;
   variable next_time;
   variable next_key;
   variable new_key_to_save = new_key + MAX_event_offset;
   variable free_key_char = get_free_key_queue_event_array_char;
   if new_key_to_save < forbidden_event_key andAlso new_key_to_save > -forbidden_event_key then begin
      new_key = forbidden_event_key;
      new_key_to_save = forbidden_event_key + MAX_event_offset;
   end
   if new_key_to_save >= INT32_MAX_key then begin
      new_key = INT32_MIN;
      new_key_to_save = new_key + MAX_event_offset;
      if free_key_char == 0 then
         free_key_char = "A";
      else
         free_key_char = sprintf("%c", charcode(free_key_char) + 1);

      set_free_key_queue_event_array_char(free_key_char);
   end
   set_free_key_queue_event_array(new_key_to_save);
   if free_key_char != 0 then
      new_key = free_key_char + new_key;

   set_array(event_queue_array, new_key + time_offset, time);
   set_array(event_queue_array, new_key + event_type_offset, EVENT_TYPE_DRUG_CUSTOM);
   set_array(event_queue_array, new_key + stat_offset, stat);
   set_array(event_queue_array, new_key + stat_value_offset, stat_value);
   set_array(event_queue_array, new_key + drug_pid_offset, drug_pid);


   // Check if its new event
   if first_event_key == 0 orElse (time < first_event_time) then begin
      set_first_event_key(critter_id, new_key);
      set_array(event_queue_array, new_key + next_event_key_offset, first_event_key);
      return;
   end

   cur_key = first_event_key;
   next_key = get_array(event_queue_array, first_event_key + next_event_key_offset);

   while (next_key != 0) do begin
      next_time = get_array(event_queue_array, next_key + time_offset);
      if (time < next_time) then begin
         break;
      end
      cur_key = next_key;
      next_key = get_array(event_queue_array, next_key + next_event_key_offset);
   end

   set_array(event_queue_array, new_key + next_event_key_offset, next_key);
   set_array(event_queue_array, cur_key + next_event_key_offset, new_key);
end

procedure queue_add_regen_event(variable critter_id, variable time) begin
   variable free_key;
   variable new_key;
   variable first_event_key;
   variable first_event_time;
   variable cur_key;
   variable next_time;
   variable next_key;
   variable new_key_to_save;
   variable free_key_char;
   if has_custom_event_type(critter_id, EVENT_TYPE_REGENERATION) then begin
      return;
   end
   free_key = get_free_key_queue_event_array;
   new_key = free_key;
   first_event_key = get_first_event_key(critter_id);
   first_event_time = get_event_time(first_event_key);
   new_key_to_save = new_key + MAX_event_offset;
   free_key_char = get_free_key_queue_event_array_char;

   if new_key_to_save < forbidden_event_key andAlso new_key_to_save > -forbidden_event_key then begin
      new_key = forbidden_event_key;
      new_key_to_save = forbidden_event_key + MAX_event_offset;
   end
   if new_key_to_save >= INT32_MAX_key then begin
      new_key = INT32_MIN;
      new_key_to_save = new_key + MAX_event_offset;
      if free_key_char == 0 then
         free_key_char = "A";
      else
         free_key_char = sprintf("%c", charcode(free_key_char) + 1);

      set_free_key_queue_event_array_char(free_key_char);
   end
   set_free_key_queue_event_array(new_key_to_save);
   if free_key_char != 0 then
      new_key = free_key_char + new_key;

   //add to id_to_regen_time array
   set_array(id_to_regen_time, critter_id, time);

   set_array(event_queue_array, new_key + time_offset, time);
   set_array(event_queue_array, new_key + event_type_offset, EVENT_TYPE_REGENERATION);

   //set_array(event_queue_array, new_key + stat_offset, 0);
   //set_array(event_queue_array, new_key + stat_value_offset, 0);
   //set_array(event_queue_array, new_key + drug_pid_offset, 0);
   //set_array(event_queue_array, new_key + stat2_offset, 0);
   //set_array(event_queue_array, new_key + h_offset, 0);

   // Check if its new event
   if first_event_key == 0 orElse (time <= first_event_time) then begin
      set_first_event_key(critter_id, new_key);
      set_array(event_queue_array, new_key + next_event_key_offset, first_event_key);
      return;
   end

   cur_key = first_event_key;
   next_key = get_array(event_queue_array, first_event_key + next_event_key_offset);

   while (next_key != 0) do begin
      next_time = get_array(event_queue_array, next_key + time_offset);
      if (time <= next_time) then begin
         break;
      end
      cur_key = next_key;
      next_key = get_array(event_queue_array, next_key + next_event_key_offset);
   end

   set_array(event_queue_array, new_key + next_event_key_offset, next_key);
   set_array(event_queue_array, cur_key + next_event_key_offset, new_key);
end


procedure queue_remove(variable critter_id, variable event_key) begin
   variable i;
   for (i = 0; i < MAX_event_offset; i++) begin
      set_array(event_queue_array, event_key + i, 0);
   end
end

procedure remove_all_burns(variable critter, variable cur_game_time) begin
   variable critter_cur_hp;
   variable critter_id = get_unique_id(critter);
   variable PoisonTickDmg;
   variable RegenTickHP;
   variable next_event_key;
   variable event_key;
   variable event_type;
   variable stat;
   variable stat_value;
   variable cur_poison;
   variable was_add_regen;
   variable was_add_poison;
   variable next_regen_time;
   variable first_event_key;
   set_array(id_to_burn_count, critter_id, 0);
   if critter == dude_obj andAlso is_iface_tag_active(iface_tag_burn) then begin
      //set_fake_trait_npc(dude_obj, "burn", 0, 168,"");
      hide_iface_tag(iface_tag_burn);
   end

   critter_cur_hp = get_critter_stat(critter, STAT_current_hp);
   if not(is_really_dead(critter, critter_state(critter), critter_cur_hp)) andAlso get_array(death_array, critter) == 0 then begin
      first_event_key = get_first_event_key(critter_id);
      event_key = first_event_key;
      if event_key != 0 then begin
         while event_key != 0 do begin
            event_type = get_array(event_queue_array, event_key + event_type_offset);
            if event_type == EVENT_TYPE_BURN then begin
               was_add_regen = 0;
               was_add_poison = 0;

               set_array(event_queue_array, event_key + event_type_offset, 0);


               stat = get_array(event_queue_array, event_key + stat_offset);
               stat_value = get_array(event_queue_array, event_key + stat_value_offset);
               call add_and_save_stats(critter, critter_id, stat, stat_value, true, true);

               stat = get_array(event_queue_array, event_key + stat2_offset);
               stat_value = get_array(event_queue_array, event_key + stat2_value_offset);
               call add_and_save_stats(critter, critter_id, stat, stat_value, true, true);


               if RegenMod > 0 andAlso was_add_regen <= 0 then begin
                  if get_critter_stat(critter, STAT_heal_rate) >= min_hr_to_regen andAlso get_critter_stat(critter, STAT_current_hp) < get_critter_stat(critter, STAT_max_hp) then begin
                     next_regen_time = get_array(id_to_regen_time, critter_id);
                     if next_regen_time <= 0 then begin
                        call queue_add_regen_event(critter_id, cur_game_time + regen_repeat_ticks);
                        was_add_regen = 1;
                     end
                     else if next_regen_time <= cur_game_time then begin
                        next_regen_time = regen_repeat_ticks - (cur_game_time - next_regen_time) % regen_repeat_ticks;
                        call queue_add_regen_event(critter_id, cur_game_time + next_regen_time);
                        was_add_regen = 1;
                     end
                  end
               end

               if event_key == first_event_key then
                  set_first_event_key(critter_id, next_event_key);

               next_event_key = get_array(event_queue_array, event_key + next_event_key_offset);
               call queue_remove(critter_id, event_key);

            end
            else
               next_event_key = get_array(event_queue_array, event_key + next_event_key_offset);

            event_key = next_event_key;
         end
      end
      if RegenMod > 0 andAlso was_add_regen <= 0 then begin
         if get_critter_stat(critter, STAT_heal_rate) >= min_hr_to_regen andAlso get_critter_stat(critter, STAT_current_hp) < get_critter_stat(critter, STAT_max_hp) then begin
            next_regen_time = get_array(id_to_regen_time, critter_id);
            if next_regen_time <= 0 then begin
               call queue_add_regen_event(critter_id, cur_game_time + regen_repeat_ticks);
               was_add_regen = 1;
            end
            else if next_regen_time <= cur_game_time then begin
               next_regen_time = regen_repeat_ticks - (cur_game_time - next_regen_time) % regen_repeat_ticks;
               call queue_add_regen_event(critter_id, cur_game_time + next_regen_time);
               was_add_regen = 1;
            end
         end
      end
   end
end

inline procedure queue_shift_all_events_time(variable critter_id, variable time_shift) begin
   variable event_key;
   variable event_time;
   event_key = get_first_event_key(critter_id);
   while event_key != 0 do begin
      event_time = get_event_time(event_key);
      set_event_time(event_key, event_time + time_shift);
      event_key = get_array(event_queue_array, event_key + next_event_key_offset);
   end
end

procedure add_burn_effect_to_saved_arrays(variable critter, variable burn_count, variable cur_game_time = 0) begin
   variable critter_id = check_id(critter);
   //variable critter_pid;
   variable drug_stat;
   variable drug_stat_value1;
   variable drug_stat_value2;
   variable drug_stat_value3;
   variable drug_stat2;
   variable drug_stat2_value1;
   variable drug_stat2_value2;
   variable drug_stat2_value3;
   variable duration1;
   variable duration2;
   variable fast_meta;
   variable next_heal_time;
   variable timer_mod;
   variable cur_offset;
   variable cur_stat;
   variable cur_burn_count = get_array(id_to_burn_count, critter_id);
   variable new_burn_count;
   variable stat_value_base;
   variable burn_diff_20;
   variable new_burn_20;
   variable critter_cur_stat;
   variable tag_is_active;

   if get_critter_stat(critter, STAT_current_hp) >= get_critter_stat(critter, STAT_max_hp) then begin
      new_burn_count = 0;
   end
   else begin
      new_burn_count = cur_burn_count + burn_count;
   end
   if cur_game_time == 0 then
      cur_game_time = game_time;
   //if new_burn_count > max_burn_count then

      //new_burn_count = max_burn_count;

   if new_burn_count <= 0 then begin
      if cur_burn_count > 0 then
         call remove_all_burns(critter, cur_game_time);

      return;
   end
   burn_diff_20 = new_burn_count / 20 - cur_burn_count / 20;

   set_array(id_to_burn_count, critter_id, new_burn_count);

   if critter == dude_obj then begin
      tag_is_active = is_iface_tag_active(iface_tag_burn);
      if new_burn_count <= 0 andAlso tag_is_active > 0 then begin
         //set_fake_trait_npc(dude_obj,modmsg(msg_burn_tag_trait), 0, 168,"");
         hide_iface_tag(iface_tag_burn);
      end
      else if tag_is_active <= 0 then begin
         //set_iface_tag_text(iface_tag_burn, new_burn_count+"% BURNED", 1);
         //set_fake_trait_npc(dude_obj,modmsg(msg_burn_tag_trait), 1, 168,modmsg(msg_burn_tag_desc));
         //set_iface_tag_text(iface_tag_burn,"ОЖОГ", 1);
         show_iface_tag(iface_tag_burn);
      end
   end
   if burn_count > 0 then begin


      if combat_is_initialized andAlso critter != combat_turn_critter andAlso get_array(combatants_array, critter_id) > 0 then
         cur_game_time += 50;

      if burn_diff_20 > 0 then begin
         if random(0,1) then begin
            drug_stat = STAT_ch;
         end
         else begin
            drug_stat = STAT_en;
         end
         drug_stat_value1 = -1 * burn_diff_20;
         drug_stat_value2 = -drug_stat_value1;

         if random(0,3) then begin
            drug_stat2 = STAT_poison_resist;
            drug_stat2_value1 = -20 * burn_diff_20;
            //drug_stat2 = STAT_max_hp;
            //critter_cur_stat = get_critter_stat(critter, drug_stat2);
            //drug_stat2_value1 = -critter_cur_stat / 10 * burn_diff_20;
            //if critter_cur_stat + drug_stat2_value1 < 5 then
               //drug_stat2_value1 = 5 - critter_cur_stat;
            //if drug_stat2_value1 > 0 then
               //drug_stat2_value1 = 0;
         end
         else begin
            drug_stat2 = STAT_ag;
            drug_stat2_value1 = -1 * burn_diff_20;
         end
         drug_stat2_value2 = -drug_stat2_value1;
         duration1 = random(100000, 300000) * burn_diff_20;

         //heal rate;
         //instant effect
         call add_and_save_stats(critter, critter_id, drug_stat, drug_stat_value1, true, true);
         call add_and_save_stats(critter, critter_id, drug_stat2, drug_stat2_value1, true, true);
         //timed effect 1
         call queue_add_burn_event(critter_id, (cur_game_time + duration1), drug_stat, drug_stat_value2, drug_stat2, drug_stat2_value2);

      end


      drug_stat = STAT_heal_rate;
      drug_stat_value1 = -1 * burn_count;
      drug_stat_value2 = -drug_stat_value1;
      duration1 = 600 * cur_burn_count + random(15000, 50000) * burn_count;

      //heal rate;
      //instant effect
      if drug_stat_value1 != 0 then begin
         call add_and_save_stats(critter, critter_id, drug_stat, drug_stat_value1, true, true);
         //timed effect 1

         call queue_add_burn_event(critter_id, (cur_game_time + duration1), drug_stat, drug_stat_value2);
      end
   end
end

procedure drug_affects_heal_instant(variable critter, variable drug_pid) begin
   variable heal_rate;
   variable stat;
   variable amount;
   variable i;
   if drug_pid <= 0 orElse get_proto_data(drug_pid,PROTO_IT_TYPE) != item_type_drug then
      return 0;

   for (i := 0; i <= 2; i++) begin
      stat = get_proto_data(drug_pid, PROTO_DR_STAT_A + (4 * i));
      if stat == STAT_heal_rate then begin
         amount = get_proto_data(drug_pid, PROTO_DR_AMOUNT_1_A + (4 * i));
         if amount != 0 then
            heal_rate = amount;
      end
      else if (stat == STAT_current_hp) then begin
         amount = get_proto_data(drug_pid, PROTO_DR_AMOUNT_1_A + (4 * i));
         if amount > 0 then
            amount = amount / 10;

         if amount > 0 then
            call add_burn_effect_to_saved_arrays(critter, -amount);

      end
   end

   return heal_rate;
end

procedure drug_affects_heal_rate(variable drug_pid) begin
   variable heal_rate;
   variable amount_A;
   variable i;
   if drug_pid <= 0 orElse get_proto_data(drug_pid,PROTO_IT_TYPE) != item_type_drug then
      return heal_rate;

   for (i := 0; i <= 2; i++) begin
      if (get_proto_data(drug_pid,PROTO_DR_STAT_A + (4 * i)) == STAT_heal_rate) orElse (i == 0 andAlso (get_proto_data(drug_pid,PROTO_DR_STAT_A) == -2) andAlso (get_proto_data(drug_pid,PROTO_DR_STAT_B) == STAT_heal_rate)) then begin
         amount_A = get_proto_data(drug_pid, PROTO_DR_AMOUNT_1_A + (4 * i));
         if amount_A != 0 then
            heal_rate = amount_A;
         else if get_proto_data(drug_pid, PROTO_DR_AMOUNT_2_A + (4 * i)) != 0 then
            heal_rate = 1;
         else if get_proto_data(drug_pid, PROTO_DR_AMOUNT_3_A + (4 * i)) != 0 then
            heal_rate = 1;
      end
   end

   return heal_rate;
end

procedure add_drug_regen_event(variable critter, variable drug_heal_rate) begin
   variable critter_id = check_id(critter);
   variable cur_game_time = game_time;
   variable next_heal_time;
   if combat_is_initialized andAlso critter != combat_turn_critter andAlso get_array(combatants_array, critter_id) > 0 then begin
      cur_game_time += 50;
   end

   next_heal_time = get_array(id_to_regen_time, critter_id);
   if next_heal_time <= cur_game_time andAlso get_critter_stat(critter, STAT_heal_rate) + drug_heal_rate >= min_hr_to_regen then begin
      next_heal_time = cur_game_time + regen_repeat_ticks;
      call queue_add_regen_event(critter_id, next_heal_time);
   end
end

procedure add_stimpak_effect_to_saved_arrays(variable critter, variable drug_pid) begin
   variable critter_id = check_id(critter);
   //variable critter_pid = obj_pid(critter);
   variable i;
   variable drug_stat = STAT_heal_rate;
   variable drug_stat_value1;
   variable drug_stat_value2;
   variable drug_stat_value3;
   variable duration1;
   variable duration2;
   variable fast_meta;
   variable cur_game_time;
   variable next_heal_time;
   variable timer_mod;
   variable cur_offset;
   variable cur_stat;

   cur_game_time = game_time;

   if fast_metabolism_plus > 0 andAlso critter == real_dude_obj andAlso (fast_metabolism_plus >= 2 orElse has_trait(TRAIT_TRAIT, real_dude_obj, TRAIT_fast_metabolism)) then begin
      fast_meta = 1;
   end

   if fast_meta > 0 then begin
      drug_stat_value1 = stim_hr_increase_fast_meta;
      drug_stat_value2 = -stim_hr_decrease_fast_meta;
      drug_stat_value3 = stim_hr_decrease_fast_meta - stim_hr_increase_fast_meta;
      duration1 = regen_repeat_ticks * regen_stimpak_ticks;
      duration2 = 2 * duration1 + 6000;
   end
   else begin
      drug_stat_value1 = stim_hr_increase;
      drug_stat_value2 = -stim_hr_decrease;
      drug_stat_value3 = stim_hr_decrease - stim_hr_increase;
      duration1 = regen_repeat_ticks * regen_stimpak_ticks;
      duration2 = 3 * duration1 + 9000;
   end


   if combat_is_initialized andAlso critter != combat_turn_critter andAlso get_array(combatants_array, critter_id) > 0 then begin
      cur_game_time += 50;
   end
   //adjust and set timer
   next_heal_time = get_array(id_to_regen_time, critter_id);
   if next_heal_time >= cur_game_time then begin
      timer_mod += (next_heal_time - cur_game_time) - regen_repeat_ticks;
      if timer_mod != 0 then begin
         duration1 += timer_mod;
         duration2 += timer_mod;
      end
   end
   else if get_critter_stat(critter, STAT_heal_rate) + drug_stat_value1 >= min_hr_to_regen then begin
      //if next_heal_time < cur_game_time + regen_repeat_ticks then begin
         next_heal_time = cur_game_time + regen_repeat_ticks;
         call queue_add_regen_event(critter_id, next_heal_time);
      //end
   end

   for (i := 0; i <= 2; i++) begin
      cur_offset = (4 * i);
      cur_stat = get_proto_data(drug_pid, PROTO_DR_STAT_A + cur_offset);
      if (cur_stat == STAT_current_hp) orElse (i == 0 andAlso (get_proto_data(drug_pid,PROTO_DR_STAT_A) == -2) andAlso (get_proto_data(drug_pid,PROTO_DR_STAT_B) == STAT_current_hp)) then begin
         if drug_stat_value1 != 0 andAlso critter == dude_obj then begin
            set_proto_data(drug_pid, PROTO_DR_STAT_A + cur_offset, drug_stat);
            set_proto_data(drug_pid, PROTO_DR_AMOUNT_1_A + cur_offset, drug_stat_value1);
            drug_stat_value1 = 0;
         end
         else begin
            set_proto_data(drug_pid, PROTO_DR_STAT_A + cur_offset, -1);
            set_proto_data(drug_pid, PROTO_DR_AMOUNT_1_A + cur_offset, 0);
         end
         set_proto_data(drug_pid, PROTO_DR_AMOUNT_2_A + cur_offset, 0);
         set_proto_data(drug_pid, PROTO_DR_AMOUNT_3_A + cur_offset, 0);
      end
      else if (cur_stat == STAT_heal_rate) orElse (i == 0 andAlso (get_proto_data(drug_pid,PROTO_DR_STAT_A) == -2) andAlso (get_proto_data(drug_pid,PROTO_DR_STAT_B) == STAT_heal_rate)) then begin
         if drug_stat_value1 != 0 andAlso critter == dude_obj then begin
            set_proto_data(drug_pid, PROTO_DR_STAT_A + cur_offset, drug_stat);
            set_proto_data(drug_pid, PROTO_DR_AMOUNT_1_A + cur_offset, drug_stat_value1);
            drug_stat_value1 = 0;
         end
         else begin
            set_proto_data(drug_pid, PROTO_DR_STAT_A + cur_offset, -1);
            set_proto_data(drug_pid, PROTO_DR_AMOUNT_1_A + cur_offset, 0);
         end
         set_proto_data(drug_pid, PROTO_DR_AMOUNT_2_A + cur_offset, 0);
         set_proto_data(drug_pid, PROTO_DR_AMOUNT_3_A + cur_offset, 0);
      end
      else if cur_stat == -1 then begin
         if drug_stat_value1 != 0 andAlso critter == dude_obj then begin
            set_proto_data(drug_pid, PROTO_DR_STAT_A + cur_offset, drug_stat);
            set_proto_data(drug_pid, PROTO_DR_AMOUNT_1_A + cur_offset, drug_stat_value1);
            set_proto_data(drug_pid, PROTO_DR_AMOUNT_2_A + cur_offset, 0);
            set_proto_data(drug_pid, PROTO_DR_AMOUNT_3_A + cur_offset, 0);
            drug_stat_value1 = 0;
         end
      end
   end

   //heal rate;
   //instant effect
   if drug_stat_value1 != 0 then
      call add_and_save_stats(critter, critter_id, drug_stat, drug_stat_value1, true, false);
   //timed effect 1
   call queue_add_drug_event(critter_id, drug_pid, drug_stat, drug_stat_value2, (cur_game_time + duration1));
   //timed effect 2
   call queue_add_drug_event(critter_id, drug_pid, drug_stat, drug_stat_value3, (cur_game_time + duration2));
end

procedure add_healing_powder_effect_to_saved_arrays(variable critter, variable drug_pid) begin
   variable critter_id = check_id(critter);
   //variable critter_pid = obj_pid(critter);
   variable i;
   variable drug_stat = STAT_heal_rate;
   variable drug_stat_value1;
   variable drug_stat_value2;
   variable drug_stat_value3;
   variable duration1;
   variable duration2;
   variable fast_meta;
   variable cur_game_time;
   variable next_heal_time;
   variable timer_mod;
   variable cur_offset;
   variable cur_stat;
   variable healing_powder_ticks;

   cur_game_time = game_time;

   if combat_is_initialized andAlso critter != combat_turn_critter andAlso get_array(combatants_array, critter_id) > 0 then
      cur_game_time += 50;

   if fast_metabolism_plus > 0 andAlso critter == real_dude_obj andAlso (fast_metabolism_plus >= 2 orElse has_trait(TRAIT_TRAIT, real_dude_obj, TRAIT_fast_metabolism)) then begin
      fast_meta = 1;
   end

   healing_powder_ticks = round(regen_stimpak_ticks / 2.0);
   if healing_powder_ticks < 3 then
      healing_powder_ticks = 3;

   if fast_meta > 0 then begin
      drug_stat_value1 = powder_hr_increase_fast_meta;
      drug_stat_value2 = -powder_hr_decrease_fast_meta;
      drug_stat_value3 = powder_hr_decrease_fast_meta - powder_hr_increase_fast_meta;
      duration1 = regen_repeat_ticks * healing_powder_ticks;
      duration2 = 2 * duration1 + 12000;
   end
   else begin
      drug_stat_value1 = powder_hr_increase;
      drug_stat_value2 = -powder_hr_decrease;
      drug_stat_value3 = powder_hr_decrease - powder_hr_increase;
      duration1 = regen_repeat_ticks * healing_powder_ticks;
      duration2 = 3 * duration1 + 18000;
   end

   //adjust and set timer
   next_heal_time = get_array(id_to_regen_time, critter_id);

   if next_heal_time >= cur_game_time then begin
      timer_mod += (next_heal_time - cur_game_time) - regen_repeat_ticks;
      if timer_mod != 0 then begin
         duration1 += timer_mod;
         duration2 += timer_mod;
      end
   end
   else if get_critter_stat(critter, STAT_heal_rate) + drug_stat_value1 >= min_hr_to_regen then begin
      //if next_heal_time < cur_game_time + regen_repeat_ticks then begin
         next_heal_time = cur_game_time + regen_repeat_ticks;
         call queue_add_regen_event(critter_id, next_heal_time);
      //end
   end

   for (i := 0; i <= 2; i++) begin
      cur_offset = (4 * i);
      cur_stat = get_proto_data(drug_pid, PROTO_DR_STAT_A + cur_offset);
      if (cur_stat == STAT_current_hp) orElse (i == 0 andAlso (get_proto_data(drug_pid,PROTO_DR_STAT_A) == -2) andAlso (get_proto_data(drug_pid,PROTO_DR_STAT_B) == STAT_current_hp)) then begin
         if drug_stat_value1 != 0 andAlso critter == dude_obj then begin
            set_proto_data(drug_pid, PROTO_DR_STAT_A + cur_offset, drug_stat);
            set_proto_data(drug_pid, PROTO_DR_AMOUNT_1_A + cur_offset, drug_stat_value1);
            drug_stat_value1 = 0;
         end
         else begin
            set_proto_data(drug_pid, PROTO_DR_STAT_A + cur_offset, -1);
            set_proto_data(drug_pid, PROTO_DR_AMOUNT_1_A + cur_offset, 0);
         end
         set_proto_data(drug_pid, PROTO_DR_AMOUNT_2_A + cur_offset, 0);
         set_proto_data(drug_pid, PROTO_DR_AMOUNT_3_A + cur_offset, 0);
      end
      else if (cur_stat == STAT_heal_rate) orElse (i == 0 andAlso (get_proto_data(drug_pid,PROTO_DR_STAT_A) == -2) andAlso (get_proto_data(drug_pid,PROTO_DR_STAT_B) == STAT_heal_rate)) then begin
         if drug_stat_value1 != 0 andAlso critter == dude_obj then begin
            set_proto_data(drug_pid, PROTO_DR_STAT_A + cur_offset, drug_stat);
            set_proto_data(drug_pid, PROTO_DR_AMOUNT_1_A + cur_offset, drug_stat_value1);
            drug_stat_value1 = 0;
         end
         else begin
            set_proto_data(drug_pid, PROTO_DR_STAT_A + cur_offset, -1);
            set_proto_data(drug_pid, PROTO_DR_AMOUNT_1_A + cur_offset, 0);
         end
         set_proto_data(drug_pid, PROTO_DR_AMOUNT_2_A + cur_offset, 0);
         set_proto_data(drug_pid, PROTO_DR_AMOUNT_3_A + cur_offset, 0);
      end
      else if cur_stat == -1 then begin
         if drug_stat_value1 != 0 andAlso critter == dude_obj then begin
            set_proto_data(drug_pid, PROTO_DR_STAT_A + cur_offset, drug_stat);
            set_proto_data(drug_pid, PROTO_DR_AMOUNT_1_A + cur_offset, drug_stat_value1);
            set_proto_data(drug_pid, PROTO_DR_AMOUNT_2_A + cur_offset, 0);
            set_proto_data(drug_pid, PROTO_DR_AMOUNT_3_A + cur_offset, 0);
            drug_stat_value1 = 0;
         end
      end
   end

   //heal rate;
   //instant effect
   if drug_stat_value1 != 0 then
      call add_and_save_stats(critter, critter_id, drug_stat, drug_stat_value1, true, false);
   //timed effect 1
   call queue_add_drug_event(critter_id, drug_pid, drug_stat, drug_stat_value2, (cur_game_time + duration1));
   //timed effect 2
   call queue_add_drug_event(critter_id, drug_pid, drug_stat, drug_stat_value3, (cur_game_time + duration2));
end

procedure add_super_stimpak_effect_to_saved_arrays(variable critter, variable drug_pid) begin
   variable critter_id = check_id(critter);
   //variable critter_pid = obj_pid(critter);
   variable i;
   variable drug_stat_a = STAT_current_hp;
   variable drug_stat_b = STAT_heal_rate;
   variable drug_stat_value1;
   variable drug_stat_value2;
   variable drug_stat_value3;
   variable drug_stat_value1b;
   variable drug_stat_value2b;
   variable drug_stat_value3b;
   variable duration1;
   variable duration2;
   variable fast_meta;
   variable cur_game_time;
   variable next_heal_time;
   variable timer_mod;
   variable injuryhealed;
   variable injures;
   variable injury;
   variable critter_cur_state;
   variable tarHR;
   variable RegenTickHP;
   variable SShphealed;
   variable HRhealcost;
   variable hp_lost;
   variable SShpdmg;
   variable cur_offset;
   variable cur_stat;
   variable burn_dec;
   variable in_combat = combat_is_initialized;
   if fast_metabolism_plus > 0 andAlso critter == real_dude_obj andAlso (fast_metabolism_plus >= 2 orElse has_trait(TRAIT_TRAIT, real_dude_obj, TRAIT_fast_metabolism)) then begin
      fast_meta = 1;
   end
   if StimUninjure > 1 then begin
      critter_cur_state = critter_state(critter);
      injures = (DAM_CRIP_LEG_LEFT BWOR DAM_CRIP_LEG_RIGHT BWOR DAM_CRIP_ARM_LEFT BWOR DAM_CRIP_ARM_RIGHT BWOR DAM_BLIND);
      critter_cur_state = critter_cur_state bwand injures;
      if critter_cur_state > 0 then begin
         i = 0;
         while critter_cur_state > 0 do begin
            i += critter_cur_state bwand 1;
            critter_cur_state /= 2;
         end
         injuryhealed += 5 * i;
         critter_uninjure(critter, injures);
      end
   end

   hp_lost = get_critter_stat(critter, STAT_max_hit_points) - get_critter_stat(critter, STAT_current_hp);
   tarHR = get_critter_stat(critter, STAT_heal_rate);
   if fast_meta <= 0 then begin
      SShphealed = super_stim_base_max_heal;
      if tarHR <= 20 then begin
         if tarHR < 0 then begin
            RegenTickHP = calc_regen_tick(critter, 20);
         end
         else begin
            RegenTickHP = calc_regen_tick(critter, (tarHR + 20));
         end
      end
      else begin
         RegenTickHP = calc_regen_tick(critter, 40);
      end
      // if regen > 60
      if RegenTickHP > super_stim_base_max_heal then begin
         SShphealed = RegenTickHP;
      end
      HRhealcost = 20 + injuryhealed;
      if SShphealed >= hp_lost then begin
         HRhealcost = HRhealcost * hp_lost / SShphealed;
         SShphealed = hp_lost;
         if SShphealed > 0 andAlso HRhealcost <= 0 then begin
            HRhealcost = 1;
         end
      end
      if SShphealed > 0 andAlso tarHR < HRhealcost then begin
         SShpdmg = floor2((SShphealed / 7.0 * (tarHR - HRhealcost)) / 20);
         if SShpdmg >= 0 then begin
            SShpdmg = -1;
         end
      end
      if SShphealed < SShpdmg then begin
        SShpdmg = SShphealed;
      end
      drug_stat_value1 = SShphealed - injuryhealed;
      drug_stat_value1b = -HRhealcost;
      duration1 = 600;
      drug_stat_value2 = SShpdmg;
      drug_stat_value2b = ceil((HRhealcost) / 2.0);
      duration2 = 21000;
      drug_stat_value3b = HRhealcost - drug_stat_value2b;
   end
      // modified stimpak if dude hase fast_metabolism
   //if fast_meta > 0 andAlso critter == real_dude_obj then begin
   else begin
      SShphealed = super_stim_base_max_heal_fast_meta;
      if tarHR <= 20 then begin
         if tarHR < 0 then begin
            RegenTickHP = calc_regen_tick(critter, 20);
         end
         else begin
            RegenTickHP = calc_regen_tick(critter, (tarHR + 20));
         end
      end
      else begin
         RegenTickHP = calc_regen_tick(critter, 40);
      end
      // if regen > 80
      if RegenTickHP > super_stim_base_max_heal_fast_meta then begin
         SShphealed = RegenTickHP;
      end
      HRhealcost = 20 + injuryhealed;
      if SShphealed >= hp_lost then begin
         HRhealcost = HRhealcost * hp_lost / SShphealed;
         SShphealed = hp_lost;
         if SShphealed > 0 andAlso HRhealcost <= 0 then begin
            HRhealcost = 1;
         end
      end
      if SShphealed > 0 andAlso tarHR < HRhealcost then begin
         SShpdmg = ((SShphealed / 7 * (tarHR - HRhealcost)) / 20);
         if SShpdmg >= 0 then begin
            SShpdmg = -1;
         end
      end
      if SShphealed < SShpdmg then begin
        SShpdmg = SShphealed;
      end
      drug_stat_value1 = SShphealed - (injuryhealed / 2);
      drug_stat_value1b = -HRhealcost;
      duration1 = 300;
      drug_stat_value2 = SShpdmg;
      drug_stat_value2b = ceil((HRhealcost) / 2.0);
      duration2 = 10500;
      drug_stat_value3b = HRhealcost - drug_stat_value2b;
   end

   cur_game_time = game_time;

   if in_combat andAlso critter != combat_turn_critter andAlso get_array(combatants_array, critter_id) > 0 then
      cur_game_time += 50;


   for (i := 0; i <= 2; i++) begin
      cur_offset = (4 * i);
      cur_stat = get_proto_data(drug_pid, PROTO_DR_STAT_A + cur_offset);
      if (cur_stat == STAT_current_hp) orElse (i == 0 andAlso (get_proto_data(drug_pid,PROTO_DR_STAT_A) == -2) andAlso (get_proto_data(drug_pid,PROTO_DR_STAT_B) == STAT_current_hp)) then begin
         if drug_stat_value1 != 0 andAlso critter == dude_obj then begin
            set_proto_data(drug_pid, PROTO_DR_STAT_A + cur_offset, drug_stat_b);
            set_proto_data(drug_pid, PROTO_DR_AMOUNT_1_A + cur_offset, drug_stat_value1b);
            drug_stat_value1b = 0;
         end
         else begin
            set_proto_data(drug_pid, PROTO_DR_STAT_A + cur_offset, -1);
            set_proto_data(drug_pid, PROTO_DR_AMOUNT_1_A + cur_offset, 0);
         end
         set_proto_data(drug_pid, PROTO_DR_AMOUNT_2_A + cur_offset, 0);
         set_proto_data(drug_pid, PROTO_DR_AMOUNT_3_A + cur_offset, 0);
      end
      else if (cur_stat == STAT_heal_rate) orElse (i == 0 andAlso (get_proto_data(drug_pid,PROTO_DR_STAT_A) == -2) andAlso (get_proto_data(drug_pid,PROTO_DR_STAT_B) == STAT_heal_rate)) then begin
         if drug_stat_value1 != 0 andAlso critter == dude_obj then begin
            set_proto_data(drug_pid, PROTO_DR_STAT_A + cur_offset, drug_stat_b);
            set_proto_data(drug_pid, PROTO_DR_AMOUNT_1_A + cur_offset, drug_stat_value1b);
            drug_stat_value1b = 0;
         end
         else begin
            set_proto_data(drug_pid, PROTO_DR_STAT_A + cur_offset, -1);
            set_proto_data(drug_pid, PROTO_DR_AMOUNT_1_A + cur_offset, 0);
         end
         set_proto_data(drug_pid, PROTO_DR_AMOUNT_2_A + cur_offset, 0);
         set_proto_data(drug_pid, PROTO_DR_AMOUNT_3_A + cur_offset, 0);
      end
      else if cur_stat == -1 then begin
         if drug_stat_value1 != 0 andAlso critter == dude_obj then begin
            set_proto_data(drug_pid, PROTO_DR_STAT_A + cur_offset, drug_stat_b);
            set_proto_data(drug_pid, PROTO_DR_AMOUNT_1_A + cur_offset, drug_stat_value1b);
            set_proto_data(drug_pid, PROTO_DR_AMOUNT_2_A + cur_offset, 0);
            set_proto_data(drug_pid, PROTO_DR_AMOUNT_3_A + cur_offset, 0);
            drug_stat_value1b = 0;
         end
      end
   end


   //instant effect stat_a
   if drug_stat_value1 != 0 then
      call add_and_save_stats(critter, critter_id, drug_stat_a, drug_stat_value1, true, false);

   burn_dec = drug_stat_value1 / 10;
   if burn_dec < 1 then
      burn_dec = 1;

   call add_burn_effect_to_saved_arrays(critter, -burn_dec);

   //timed effect 1 // dmg
   if drug_stat_value2 < 0 then
      call queue_add_drug_event(critter_id, drug_pid, drug_stat_a, drug_stat_value2, (cur_game_time + duration1));
   //instant effect
   if drug_stat_value1b != 0 then
      call add_and_save_stats(critter, critter_id, drug_stat_b, drug_stat_value1b, true, false);
   //timed effect 1
   call queue_add_drug_event(critter_id, drug_pid, drug_stat_b, drug_stat_value2b, (cur_game_time + duration1));
   //timed effect 2
   call queue_add_drug_event(critter_id, drug_pid, drug_stat_b, drug_stat_value3b, (cur_game_time + duration2));

   if hp_lost > 19 andAlso critter != dude_obj andAlso in_combat andAlso critter_is_fleeing(critter) then
      critter_set_flee_state(critter, 0);
end

procedure get_regen_by_id(variable critter, variable unique_id, variable PoisonTickDmg, variable critter_cur_hp) begin
   variable RegenTickHP = -1;
   variable critter_cur_heal_rate;
   variable regen_heal_time;
   if RegenMod > 0 andAlso critter > 0 andAlso get_array(death_array, critter) <= 0 then begin
      critter_cur_heal_rate = get_critter_stat(critter, STAT_heal_rate);
      if critter_cur_heal_rate < min_hr_to_regen then begin
         if get_array(id_to_regen_time, unique_id) > 0 then
            set_array(id_to_regen_time, unique_id, 0);
         return -1;
      end

      RegenTickHP = calc_regen_tick(critter, critter_cur_heal_rate, PoisonTickDmg, critter_cur_hp);

      if critter == real_dude_obj andAlso has_fake_perk(regen_perk_name) andAlso critter_is_crippled(critter) then begin
         if cripheal(real_dude_obj) <= 0 andAlso RegenTickHP <= 0 then
            RegenTickHP = -1;
      end
      else if RegenTickHP <= 0 then
         RegenTickHP = -1;
   end

   return RegenTickHP;
end

procedure reg_anim_magic_hands_middle_combat(variable critter) begin
   if validate_critter_anim(critter, ANIM_magic_hands_middle) then begin
      reg_anim_combat_check(0);
      reg_anim_begin();
      reg_anim_animate(critter, ANIM_magic_hands_middle, -1);
      reg_anim_end();
   end
end

procedure critter_use_item(variable critter,variable item,variable not_animate, variable count) begin
   variable i;
   variable item_pid;
   variable tmp;
   variable critter_hr;
   variable RegenTickHP;
   variable critter_sid = -1;
   if critter > 0 andAlso item > 0 andAlso obj_type(item) == OBJ_TYPE_ITEM then begin
      item_pid = obj_pid(item);
      if not_animate <= 0 then begin

         if count <= 1 then begin
            if resting <= 0 then begin
               if combat_is_initialized then begin
                  call reg_anim_magic_hands_middle_combat(critter);
               end
               else begin
                  reg_anim_clear(critter);
                  reg_anim_begin();
                  reg_anim_animate(critter, ANIM_magic_hands_middle, -1);
                  reg_anim_end();
               end
            end
         end
      end
      for (i  := 0; i < count; i++) begin
         if not_animate <= 0 then
            display_msg(parse_str_2(modmsg(msg_npc_use_item), obj_name(critter), obj_name(item)));

         if on_global_map > 0 then begin
            critter_sid = get_object_data(critter, OBJ_DATA_SID);
            if critter_sid != -1 then begin
               set_obj_script_source(critter_sid, critter, item);
               exec_obj_script_proc(critter_sid, use_obj_on_proc);
               set_object_data(critter, OBJ_DATA_SID, -1);
            end
         end
         set_self(critter);
         set_self(critter);
         use_obj_on_obj(item, critter);
         if critter_sid != -1 then begin
            set_object_data(critter, OBJ_DATA_SID, critter_sid);
         end

         item = obj_carrying_pid_obj(critter, item_pid);
         if item <= 0 then
            break;
      end
      set_self(0);
   end
end

procedure check_max_hr begin
   variable stat_name = message_str_game(GAME_MSG_STAT, 100 + STAT_heal_rate);
   variable target_hr = get_critter_stat(drug_target, STAT_heal_rate);
   if target_hr >= new_max_hr then begin
      if drug_target == real_dude_obj then begin
         display_msg(modmsg(msg_max_hr_1)+stat_name+modmsg(msg_max_hr_2));
      end
      else
         display_msg(obj_name(drug_target)+": "+stat_name+modmsg(msg_max_hr_npc));
   end
      //else
         //display_msg("Ваша текущая скорость восстановления: "+target_hr);
   call check_regen_tag;


   drug_target = 0;
end

procedure REMOVEINVENOBJ begin
   if drug_target > 0 then
      call check_max_hr;
end

inline procedure modify_antidote_healing_flag(variable set_flag) begin
   variable current_state = (gAntidoteHealingWasSet == 1);

   if set_flag != current_state then begin
      variable flag_ext = get_proto_data(PID_ANTIDOTE, PROTO_FLAG_EXT);
      variable has_flag = (flag_ext bwand HEALING_ITEM) != 0;

      if set_flag andAlso not(has_flag) then begin
         set_proto_data(PID_ANTIDOTE, PROTO_FLAG_EXT, flag_ext bwor HEALING_ITEM);
         gAntidoteHealingWasSet = 1;
      end
      else if not(set_flag) andAlso has_flag then begin
         set_proto_data(PID_ANTIDOTE, PROTO_FLAG_EXT, flag_ext bwand NOT_HEALING_ITEM);
         gAntidoteHealingWasSet = 0;
      end
   end
end

inline procedure modify_super_antidote_healing_flag(variable set_flag) begin
   if Nevada > 0 then begin
      variable current_state = (gSuperAntidoteHealingWasSet == 1);

      if set_flag != current_state then begin
         variable flag_ext = get_proto_data(PID_NEVADA_SUPER_ANTIDOTE, PROTO_FLAG_EXT);
         variable has_flag = (flag_ext bwand HEALING_ITEM) != 0;

         if set_flag andAlso not(has_flag) then begin
            set_proto_data(PID_NEVADA_SUPER_ANTIDOTE, PROTO_FLAG_EXT, flag_ext bwor HEALING_ITEM);
            gSuperAntidoteHealingWasSet = 1;
         end
         else if not(set_flag) andAlso has_flag then begin
            set_proto_data(PID_NEVADA_SUPER_ANTIDOTE, PROTO_FLAG_EXT, flag_ext bwand NOT_HEALING_ITEM);
            gSuperAntidoteHealingWasSet = 0;
         end
      end
   end
end



procedure CALCAPCOST begin
   if drug_target > 0 then
      call check_max_hr;
end


procedure USEOBJON begin
   variable target = get_sfall_arg;
   variable user = get_sfall_arg;
   variable obj = get_sfall_arg;
   variable objpid = obj_pid(obj);
   variable target_obj_type = obj_type(target);
   variable tarHR;
   variable target_pe;
   variable party = party_member_list(0);
   variable user_in_party = is_in_array(user,party);
   variable target_in_party;
   variable tar_type;
   variable tar_fid;
   variable tar_cur_hp;
   variable tar_state;
   variable RegenTickHP;
   variable check_hr;
   if target_obj_type == OBJ_TYPE_CRITTER then begin
      call check_id(target);
      tar_cur_hp = get_critter_stat(target, STAT_current_hp);
      tarHR = get_critter_stat(target, STAT_heal_rate);
      target_pe = get_critter_stat(target, STAT_pe);
      target_in_party = is_in_array(target, party);
      tar_type = metarule(METARULE_CRITTER_KILL_TYPE, target);
      tar_state = critter_state(target);
   end

   //prevent stim overusage
   if RegenMod > 0 then begin
      if user != dude_obj then begin
         if objpid == PID_STIMPAK then
            check_hr = stim_hr_increase;
         else if objpid == PID_HEALING_POWDER then
            check_hr = powder_hr_increase;

         if check_hr > 0 andAlso tarHR + check_hr >= new_max_hr_npc_stop then begin
            if combat_is_initialized then begin
               call npc_max_hr_rm_regen_items(user);
            end
            else begin
               RegenTickHP = get_regen_by_id(target, check_id(target), 0, 0);
               if RegenTickHP < 18 then
                  RegenTickHP = 18;

               critter_heal(target, RegenTickHP);
               set_sfall_return(0);
               return;
            end
         end
      end


      if objpid == PID_STIMPAK then begin
         if target == real_dude_obj then begin
            last_use_hr_drug = game_time;
         end
         call add_stimpak_effect_to_saved_arrays(target, objpid);
         check_hr = 1;
      end
      else if objpid == PID_SUPER_STIMPAK then begin
         call add_super_stimpak_effect_to_saved_arrays(target, objpid);
         check_hr = 1;
      end
      else if objpid == PID_HEALING_POWDER then begin
         call add_healing_powder_effect_to_saved_arrays(target, PID_HEALING_POWDER);
         check_hr = 1;
      end
      else if MedToolsMod > 0 andAlso objpid == PID_DOCTORS_BAG orElse objpid == PID_PARAMEDICS_BAG then begin
         call add_burn_effect_to_saved_arrays(target, -(has_skill(user, SKILL_DOCTOR) / 15));
         check_hr = 1;
      end
      else if MedToolsMod > 0 andAlso objpid == PID_FIRST_AID_KIT orElse objpid == PID_FIELD_MEDIC_KIT then begin
         call add_burn_effect_to_saved_arrays(target, -(has_skill(user, SKILL_FIRST_AID) / 25));
         check_hr = 1;
      end
      else begin
         tarHR = drug_affects_heal_instant(target, objpid);
         if tarHR > 0 then begin
            call add_drug_regen_event(target, tarHR);
            check_hr = 1;
         end
         else if tarHR < 0 then
            check_hr = 1;
      end
   end

   //if target == dude_obj then
      //call check_regen_tag in 0;

   if user == dude_obj andAlso check_hr then begin
      drug_target = target;
   end

   if PoisonMod > 0 then begin
      if get_poison(user) < 18 then begin
         call modify_antidote_healing_flag(false);
         call modify_super_antidote_healing_flag(false);
      end

      if objpid == PID_HYPO_POISON andAlso target_obj_type == OBJ_TYPE_CRITTER andAlso tar_type != KILL_TYPE_robot_kills andAlso tar_cur_hp > 0 andAlso tar_state != CRITTER_IS_DEAD andAlso user_in_party andAlso not(target_in_party) then begin
         if obj_can_see_obj(target, user) andAlso (random(30, target_pe * 30) > random(0, (has_skill(user, SKILL_FIRST_AID) + has_skill(user, SKILL_DOCTOR) + has_skill(user, SKILL_SNEAK)))) then begin
            tar_fid = critter_art_fid(target);
            if random(0,1) andAlso not(combat_is_initialized) andAlso get_critter_stat(target, STAT_iq) > 3 andAlso can_use_items(tar_type) andAlso tar_type != KILL_TYPE_children_kills andAlso tar_fid != FID_NFBRLP andAlso tar_fid != 16777336 andAlso tar_fid != 16777325 then begin
               float_msg(target, modmsg(random(msg_failedPoisoning1,msg_failedPoisoning4)), FLOAT_COLOR_AFRAID);
               set_sfall_return(0);
            end
            else begin
               if get_poison_float(target, get_unique_id(target)) + (Poison_amt - (Poison_amt * get_critter_stat(target, STAT_poison_resist) / 100)) <= calc_poison_overdose(target) then begin
                  display_msg(failed_sneak_use_msg);
                  attack_setup(target,user);
               end
            end
         end
      end

      // radscorp tails
      if (objpid == gPID_SMALL_SCORPION_TAIL orElse objpid == PID_SCORPION_TAIL) andAlso (user_in_party orElse user == dude_obj) andAlso (target_in_party orElse target == dude_obj) then begin
         call weapon_apply_poison_USEOBJON(target, user, objpid);
      end
   end
end

inline procedure rm_poisonable_weapons_from_arr begin
   variable weapon_pid;
   foreach weapon_pid in PoisonableWeapons_rm begin
      call rm_from_poisoned_perk_weapons(weapon_pid);
   end
   clear_array(PoisonableWeapons_rm);
end

inline procedure check_decrease_poisoned_weapon_perk(variable target,variable dec_value, variable poison_mastery) begin
   variable left_hand;
   variable right_hand;
   variable left_hand_pid;
   variable right_hand_pid;
   variable left_hand_name;
   variable right_hand_name;
   variable weapon_pid;
   variable weapon_count;
   variable perk_name;
   variable perk_count;
   variable new_perk_count;
   variable forced;
   variable i;
   variable new_dec_value;
   if dec_value == -101 then begin
      forced = 1;
      dec_value = 9999;
   end

   if target > 0 then begin
      if PoisonAppliedWeapons_len > 0 then begin
         if forced <= 0 then begin
            right_hand_pid = 0;
            left_hand_pid = 0;
            left_hand = critter_inven_obj2(target, INVEN_TYPE_LEFT_HAND);
            right_hand = critter_inven_obj2(target, INVEN_TYPE_RIGHT_HAND);
            if right_hand > 0 andAlso obj_item_subtype(right_hand) == item_type_weapon then
               right_hand_pid = obj_pid(right_hand);
            if left_hand > 0 andAlso obj_item_subtype(left_hand) == item_type_weapon then
               left_hand_pid = obj_pid(left_hand);
         end


         foreach weapon_pid : weapon_count in PoisonAppliedWeapons begin
            perk_name = envenomed_msg + proto_data(weapon_pid, 1);
            perk_count = has_fake_perk_npc(target, perk_name);
            if perk_count > 0 andAlso right_hand_pid != weapon_pid andAlso left_hand_pid != weapon_pid then begin
               if poison_mastery > 0 then begin
                  new_dec_value = 0;
                  for (i = 1; i <= dec_value; i++) begin
                     if random(0, 25) == 0 then
                        new_dec_value += 1;
                     if new_dec_value >= perk_count then
                        break;
                  end
                  if new_dec_value > 0 then
                     dec_value = new_dec_value;
                  else
                     continue;
               end

               new_perk_count = perk_count - dec_value;
               if new_perk_count < 0 then new_perk_count = 0;
               set_fake_perk_npc(target, perk_name, new_perk_count, 23, envenomed_description_msg);
               if new_perk_count <= 0 then
                  set_array(PoisonableWeapons_rm, weapon_pid, weapon_pid);
            end
         end
         if len_array(PoisonableWeapons_rm) > 0 then begin
            call rm_poisonable_weapons_from_arr;
         end
      end
   end
end


procedure critter_try_use_antidote_heal(variable critter,variable critter_in_party, variable skip_msg, variable PoisonTickDmg, variable count) begin
   variable critter_name;
   variable critter_type;
   variable critter_cur_hp;
   variable critter_max_hp;
   variable critter_cur_poison;
   variable critter_healing_rate;
   variable has_antidote;
   variable has_super_antidote;
   variable antidote;
   variable stim;
   //variable stim_count;
   variable critter_iq_rnd;
   // npc use antidote
   if critter != dude_obj andAlso PoisonTickDmg > 0 then begin
      tail_used = 0;
      critter_type = critter_kill_type(critter);
      if not(is_prone(critter)) andAlso can_use_items(critter_type) then begin
         critter_name = obj_name(Critter);
         critter_cur_hp = get_critter_stat(critter, STAT_current_hp);
         critter_max_hp = get_critter_stat(critter, STAT_max_hp);
         critter_cur_poison = get_poison(Critter);

         has_antidote = obj_is_carrying_obj_pid(Critter, PID_ANTIDOTE);
         if Nevada > 0 then
            has_super_antidote = obj_is_carrying_obj_pid(Critter, PID_NEVADA_SUPER_ANTIDOTE);

         critter_iq_rnd = random(1, get_critter_stat(critter, STAT_iq));
         //antidoe use
         if (has_antidote > 0 orElse has_super_antidote > 0) andAlso PoisonTickDmg >= critter_cur_hp / critter_iq_rnd then begin
            tail_used = 1;

            if has_super_antidote > 0 andAlso critter_cur_poison > 25 then begin
               antidote = obj_carrying_pid_obj(critter, PID_NEVADA_SUPER_ANTIDOTE);
            end
            else begin
               antidote = obj_carrying_pid_obj(critter, PID_ANTIDOTE);
            end
            if count > 1 then
               count = 1 + critter_cur_poison / 20;
            call critter_use_item(critter, antidote, skip_msg, count);

            if critter_in_party andAlso critter_cur_poison > 30 then
               poison(critter, -(25));
         end
         // stimpack use
         else if tail_used <= 0 andAlso (critter_in_party orElse (critter_iq_rnd - 3)) then begin
            stim = check_poison_healing_item(critter, critter_max_hp, critter_cur_hp, PoisonTickDmg,0);
            if stim > 0 andAlso obj_type(stim) == OBJ_TYPE_ITEM then begin
               tail_used = 1;
               call critter_use_item(critter, stim, skip_msg, count);
            end
         end
      end
   end
end


procedure critter_heal_regen_poison(variable critter, variable RegenTickHP, variable PoisonTickDmg, variable skip_msg, variable adjust_hp) begin
   variable losblock;
   variable critter_name;
   variable critter_cur_hp;
   variable death;
   variable cur_burn_count;
   variable burn_dec;
   variable new_RegenTickHP;
   variable in_combat;
   //aplly burn
   if adjust_hp > 0 then begin
      cur_burn_count = get_array(id_to_burn_count, get_unique_id(critter));
      if cur_burn_count > 0 then begin
         burn_dec = get_critter_stat(critter, STAT_heal_rate) / 10;
         if burn_dec < 1 then
            burn_dec = 1;

         call add_burn_effect_to_saved_arrays(critter, -burn_dec);
      end
   end
   if RegenTickHP < 0 then
      RegenTickHP = 0;
   if PoisonTickDmg < 0 then
      PoisonTickDmg = 0;
   if critter > 0 andAlso (RegenTickHP > 0 orElse PoisonTickDmg > 0) then begin
      critter_name = obj_name(critter);
      critter_cur_hp = get_critter_stat(critter, STAT_current_hp);
      if RegenTickHP > 0 then begin
         if adjust_hp > 0 andAlso adjust_hp != adjust_hp_poison then
            critter_cur_hp += RegenTickHP;
         if ShowModMSG > 0 andAlso skip_msg <= 0 then begin
            if critter == real_dude_obj then begin
               if RegenTickHP == 1 then begin
                  display_msg(parse_str_2(modmsg(msg_player_1_hp_healed), critter_name, RegenTickHP));
               end else begin
                  display_msg(parse_str_2(modmsg(msg_player_many_hp_healed), critter_name, RegenTickHP));
               end
            end
            else begin
               if HR_fog_of_war > 0 then
                  losblock = obj_blocking_line(dude_obj, tile_num(critter), BLOCKING_TYPE_SIGHT);
               if losblock == 0 then begin
                  if RegenTickHP == 1 then begin
                     display_msg(parse_str_2(modmsg(msg_npc_1_hp_healed), critter_name, RegenTickHP));
                  end else begin
                     display_msg(parse_str_2(modmsg(msg_npc_many_hp_healed), critter_name, RegenTickHP));
                  end
               end
            end
         end
      end
      if PoisonTickDmg > 0 then begin
         if adjust_hp > 0 andAlso critter_cur_hp <= PoisonTickDmg then begin
            death = 1;
         end
         else begin
            if ShowModMSG > 0 andAlso skip_msg <= 0 then begin
               if Critter == real_dude_obj then begin
                  display_msg(parse_str_2(modmsg(msg_player_poison_dmg), critter_name, PoisonTickDmg));
               end
               else begin
                  if HR_fog_of_war > 0 andAlso losblock <= 0 then
                     losblock = obj_blocking_line(dude_obj, tile_num(critter), BLOCKING_TYPE_SIGHT);

                  if losblock <= 0 then begin
                     display_msg(parse_str_2(modmsg(msg_npc_poison_dmg), critter_name, PoisonTickDmg));
                  end
               end
            end
         end
      end
      if HR_fog_of_war > 0 andAlso losblock <= 0 then
         losblock = obj_blocking_line(dude_obj, tile_num(critter), BLOCKING_TYPE_SIGHT);
      in_combat = combat_is_initialized;
      if ShowFloatMSG > 0 andAlso skip_msg <= 0 andAlso in_combat andAlso (losblock <= 0) then begin
         float_msg(critter, "", FLOAT_MSG_GREEN);
         if RegenTickHP > 0 then begin
            if PoisonTickDmg <= 0 then begin
               float_msg(critter, "+" + RegenTickHP, FLOAT_MSG_GREEN);
            end
            else begin
               if RegenTickHP > PoisonTickDmg then begin
                  float_msg(critter, "+" + (RegenTickHP - PoisonTickDmg), FLOAT_MSG_BLUE);
               end
               else begin
                  float_msg(critter, "" + (RegenTickHP - PoisonTickDmg), FLOAT_MSG_BLUE);
               end
            end
         end
         else if PoisonTickDmg > 0 then begin
            float_msg(critter, "-" + PoisonTickDmg, FLOAT_COLOR_AFRAID);
         end
      end

      if death > 0 then begin
         if skip_msg > 0 then
            call critter_inflict_poison_dmg(critter, PoisonTickDmg, 0);
         else
            call critter_inflict_poison_dmg(critter, PoisonTickDmg, 1);
      end
      else if adjust_hp > 0 then begin
         if adjust_hp == adjust_hp_poison then
            critter_heal(Critter, -PoisonTickDmg);
         else if adjust_hp == adjust_hp_regen then
            critter_heal(Critter, RegenTickHP);
         else
            critter_heal(Critter, (RegenTickHP - PoisonTickDmg));

         if in_combat andAlso RegenTickHP > 0 andAlso critter_is_fleeing(critter) andAlso get_critter_stat(critter, STAT_current_hp) >= 15 + random(0,20) then
            critter_set_flee_state(critter, 0);
      end
   end
   return RegenTickHP;
end

procedure set_poison_apply_items begin
   variable tail_flags = get_proto_data(PID_SCORPION_TAIL, PROTO_IT_FLAGS);
   variable small_tail_flags;
   variable was_set;

   if gPID_SMALL_SCORPION_TAIL > 0 andAlso get_proto_data(gPID_SMALL_SCORPION_TAIL, PROTO_IT_INV_FID) == 117440914 then begin
      small_tail_flags = get_proto_data(gPID_SMALL_SCORPION_TAIL, PROTO_IT_FLAGS);
      if (small_tail_flags bwand ITEM_ACTION_USEON) != ITEM_ACTION_USEON then begin
         set_proto_data(gPID_SMALL_SCORPION_TAIL, PROTO_IT_FLAGS, (small_tail_flags bwor ITEM_ACTION_USEON));
      end
      set_proto_data(gPID_SMALL_SCORPION_TAIL, PROTO_IT_WEIGHT, 1);
      was_set = 1;
   end

   //radscorpion tail add 'ITEM_ACTION_USEON'
   if (tail_flags bwand ITEM_ACTION_USEON) != ITEM_ACTION_USEON then begin
      set_proto_data(PID_SCORPION_TAIL, PROTO_IT_FLAGS, (tail_flags bwor ITEM_ACTION_USEON));
      was_set = 1;
   end

   //radscorpion tail weight modifying
   set_proto_data(PID_SCORPION_TAIL, PROTO_IT_WEIGHT, 3);
   if was_set > 0 then
      intface_redraw;
end


procedure set_drugs_proto begin
   if PoisonMod > 0 then begin
      // poison injection moddification
      if Sonora <= 0 then begin
         set_proto_data(PID_HYPO_POISON, PROTO_DR_STAT_A, STAT_current_hp);
         set_proto_data(PID_HYPO_POISON, PROTO_DR_STAT_B, STAT_current_poison);
         set_proto_data(PID_HYPO_POISON, PROTO_DR_STAT_C, STAT_ag);
         set_proto_data(PID_HYPO_POISON, PROTO_DR_AMOUNT_1_A, 0);
         set_proto_data(PID_HYPO_POISON, PROTO_DR_AMOUNT_1_B, Poison_amt);
         set_proto_data(PID_HYPO_POISON, PROTO_DR_AMOUNT_1_C, -2);
         set_proto_data(PID_HYPO_POISON, PROTO_DR_DURATION_1, 30);
         set_proto_data(PID_HYPO_POISON, PROTO_DR_AMOUNT_2_A, 0);
         set_proto_data(PID_HYPO_POISON, PROTO_DR_AMOUNT_2_B, 0);
         set_proto_data(PID_HYPO_POISON, PROTO_DR_AMOUNT_2_C, 0);
         set_proto_data(PID_HYPO_POISON, PROTO_DR_DURATION_2, 60);
         set_proto_data(PID_HYPO_POISON, PROTO_DR_AMOUNT_3_A, 0);
         set_proto_data(PID_HYPO_POISON, PROTO_DR_AMOUNT_3_B, 0);
         set_proto_data(PID_HYPO_POISON, PROTO_DR_AMOUNT_3_C, 2);
         set_proto_data(PID_HYPO_POISON, PROTO_DR_ADDICT_CHANCE, 0);
         set_proto_data(PID_HYPO_POISON, PROTO_DR_ADDICT_PERK, 0);
         set_proto_data(PID_HYPO_POISON, PROTO_DR_ADDICT_DELAY, 0);

         // antidot moddification
         set_proto_data(PID_ANTIDOTE, PROTO_DR_STAT_A, -2);
         set_proto_data(PID_ANTIDOTE, PROTO_DR_STAT_B, STAT_current_poison);
         set_proto_data(PID_ANTIDOTE, PROTO_DR_STAT_C, STAT_poison_resist);
         set_proto_data(PID_ANTIDOTE, PROTO_DR_AMOUNT_1_A, -28);
         set_proto_data(PID_ANTIDOTE, PROTO_DR_AMOUNT_1_B, -18);
         set_proto_data(PID_ANTIDOTE, PROTO_DR_AMOUNT_1_C, 20);
         set_proto_data(PID_ANTIDOTE, PROTO_DR_DURATION_1, 10);
         set_proto_data(PID_ANTIDOTE, PROTO_DR_AMOUNT_2_A, 0);
         set_proto_data(PID_ANTIDOTE, PROTO_DR_AMOUNT_2_B, 0);
         set_proto_data(PID_ANTIDOTE, PROTO_DR_AMOUNT_2_C, -20);
         set_proto_data(PID_ANTIDOTE, PROTO_DR_DURATION_2, 0);
         set_proto_data(PID_ANTIDOTE, PROTO_DR_AMOUNT_3_A, 0);
         set_proto_data(PID_ANTIDOTE, PROTO_DR_AMOUNT_3_B, 0);
         set_proto_data(PID_ANTIDOTE, PROTO_DR_AMOUNT_3_C, 0);
         set_proto_data(PID_ANTIDOTE, PROTO_DR_ADDICT_CHANCE, 0);
         set_proto_data(PID_ANTIDOTE, PROTO_DR_ADDICT_PERK, 0);
         set_proto_data(PID_ANTIDOTE, PROTO_DR_ADDICT_DELAY, 0);

         //EcCo dragon skin
         call check_and_set_poison_drug(PID_PBS_DRAGON_SKIN);
      end
      call set_poison_apply_items;
   end

   if RegenMod > 0 then begin

      if Sonora <= 0 then begin
         if WAHR != "" then
            set_proto_data(PID_ALIEN, PROTO_CR_BONUS_HEALING_RATE, WAHR);
         if TWAHR != "" then
            set_proto_data(PID_TOUGH_ALIEN, PROTO_CR_BONUS_HEALING_RATE, TWAHR);
         if ET_TU <= 0 andAlso WAQHR != "" then
            set_proto_data(PID_QUEEN_ALIEN, PROTO_CR_BONUS_HEALING_RATE, WAQHR);
         if CENHR!= "" then
            set_proto_data(PID_CENTAUR, PROTO_CR_BONUS_HEALING_RATE, CENHR);
         if MCENHR != "" then
         set_proto_data(PID_MEAN_CENTAUR, PROTO_CR_BONUS_HEALING_RATE, MCENHR);

         if Nevada <= 0 andAlso ET_TU <= 0 andAlso Resurrection <= 0 then begin
            set_proto_data(PID_END_BOSS, PROTO_CR_BONUS_POISON_DR, 35); // set Frank Horrigan poison res to 85%(base 50 + bonus 35%)
         end
      end
      // Nevada food
      if Nevada > 0 then begin
         //232
         if get_proto_data(232,PROTO_AR_PERK)== PERK_faster_healing then
            set_proto_data(232, PROTO_AR_PERK, PERK_presence);
         // mutafruit heal
         set_proto_data(PID_MUTATED_FRUIT, PROTO_DR_STAT_A, -2);
         set_proto_data(PID_MUTATED_FRUIT, PROTO_DR_STAT_B, STAT_current_hp);
         set_proto_data(PID_MUTATED_FRUIT, PROTO_DR_AMOUNT_1_A, 0);
         set_proto_data(PID_MUTATED_FRUIT, PROTO_DR_AMOUNT_1_B, 1);
         // iguana
         set_proto_data(PID_IGUANA_ON_A_STICK, PROTO_DR_STAT_C, STAT_poison_resist);
         set_proto_data(PID_IGUANA_ON_A_STICK, PROTO_DR_AMOUNT_1_C, 3);
         set_proto_data(PID_IGUANA_ON_A_STICK, PROTO_DR_AMOUNT_2_C , -3);
         set_proto_data(PID_IGUANA_ON_A_STICK, PROTO_DR_AMOUNT_3_C , 0);
         // pretty & glamour care kit
         set_proto_data(90, PROTO_DR_STAT_C, STAT_poison_resist);
         set_proto_data(90, PROTO_DR_AMOUNT_1_C, 15);
         // iguana bits
         set_proto_data(103, PROTO_DR_STAT_C, STAT_poison_resist);
         set_proto_data(103, PROTO_DR_AMOUNT_1_C, 7);
         set_proto_data(103, PROTO_DR_AMOUNT_2_C , -7);
         // nuka heal
         set_proto_data(106, PROTO_DR_AMOUNT_1_A, 1);
         // water
         set_proto_data(126, PROTO_DR_STAT_A, STAT_current_hp);
         set_proto_data(126, PROTO_DR_STAT_B, STAT_current_poison);
         set_proto_data(126, PROTO_DR_STAT_C, STAT_current_rad);
         set_proto_data(126, PROTO_DR_AMOUNT_1_A, 1);
         set_proto_data(126, PROTO_DR_AMOUNT_1_B, -4);
         set_proto_data(126, PROTO_DR_AMOUNT_1_C, -3);
         //clear water  8
         set_proto_data(212, PROTO_DR_STAT_A, STAT_current_hp);
         set_proto_data(212, PROTO_DR_STAT_B, STAT_current_poison);
         set_proto_data(212, PROTO_DR_STAT_C, STAT_current_rad);
         set_proto_data(212, PROTO_DR_AMOUNT_1_A, 2);
         set_proto_data(212, PROTO_DR_AMOUNT_1_B, -7);
         set_proto_data(212, PROTO_DR_AMOUNT_1_C, -7);
         // the ashes of the forefather poison for 6, not 25
         set_proto_data(218, PROTO_DR_AMOUNT_1_A, 6);
         //meat jerky
         set_proto_data(PID_MEAT_JERKY, PROTO_DR_STAT_B, STAT_current_hp);
         set_proto_data(PID_MEAT_JERKY, PROTO_DR_AMOUNT_1_B, 1);
         set_proto_data(PID_MEAT_JERKY, PROTO_DR_AMOUNT_2_B, 0);
         set_proto_data(PID_MEAT_JERKY, PROTO_DR_AMOUNT_3_B, 0);
         //pirog max hp + ac instead of hr
         set_proto_data(343, PROTO_DR_STAT_A, STAT_max_hp);
         set_proto_data(343, PROTO_DR_STAT_B, STAT_current_hp);
         set_proto_data(343, PROTO_DR_STAT_C, STAT_ac);
         set_proto_data(343, PROTO_DR_AMOUNT_1_A, 4);
         set_proto_data(343, PROTO_DR_AMOUNT_1_B, 4);
         set_proto_data(343, PROTO_DR_AMOUNT_1_C, 3);
         set_proto_data(343, PROTO_DR_AMOUNT_2_A, 0);
         set_proto_data(343, PROTO_DR_AMOUNT_2_B, 0);
         set_proto_data(343, PROTO_DR_AMOUNT_2_C, -3);
         //mantis
         set_proto_data(419, PROTO_DR_STAT_A, STAT_current_hp);
         set_proto_data(419, PROTO_DR_STAT_B, STAT_crit_chance);
         set_proto_data(419, PROTO_DR_STAT_C, 0);
         set_proto_data(419, PROTO_DR_AMOUNT_1_A, 3);
         set_proto_data(419, PROTO_DR_AMOUNT_1_B, 1);
         set_proto_data(419, PROTO_DR_AMOUNT_1_C, 0);
         set_proto_data(419, PROTO_DR_DURATION_1, 15);
         set_proto_data(419, PROTO_DR_AMOUNT_2_A, 0);
         set_proto_data(419, PROTO_DR_AMOUNT_2_B, -1);
         set_proto_data(419, PROTO_DR_AMOUNT_2_C, 0);
         set_proto_data(419, PROTO_DR_DURATION_2, 0);
         set_proto_data(419, PROTO_DR_AMOUNT_3_A, 0);
         set_proto_data(419, PROTO_DR_AMOUNT_3_B, 0);
         set_proto_data(419, PROTO_DR_AMOUNT_3_C, 0);
         //rootbeer
         set_proto_data(423, PROTO_DR_AMOUNT_1_A, 3);
         //milk
         set_proto_data(440, PROTO_DR_STAT_B, STAT_current_hp);
         set_proto_data(440, PROTO_DR_STAT_C, STAT_current_poison);
         set_proto_data(440, PROTO_DR_AMOUNT_1_B, 2);
         set_proto_data(440, PROTO_DR_AMOUNT_1_C, -4);
         set_proto_data(440, PROTO_DR_AMOUNT_2_B, 0);
         set_proto_data(440, PROTO_DR_AMOUNT_2_C, 0);
         //burger
         set_proto_data(468, PROTO_DR_STAT_A, STAT_current_hp);
         set_proto_data(468, PROTO_DR_STAT_C, STAT_carry_amt);
         set_proto_data(468, PROTO_DR_AMOUNT_1_A, 2);
         set_proto_data(468, PROTO_DR_AMOUNT_1_C, 3);
         set_proto_data(468, PROTO_DR_DURATION_1, 930);
         set_proto_data(468, PROTO_DR_AMOUNT_2_A, 0);
         set_proto_data(468, PROTO_DR_AMOUNT_2_C, -3);
         set_proto_data(468, PROTO_DR_DURATION_2, 0);
         set_proto_data(468, PROTO_DR_AMOUNT_3_A, 0);
         set_proto_data(468, PROTO_DR_AMOUNT_3_B, 0);
         set_proto_data(468, PROTO_DR_AMOUNT_3_C, 0);
         //pizza max hp instead of hr
         set_proto_data(581, PROTO_DR_AMOUNT_1_A, 2);
         set_proto_data(581, PROTO_DR_STAT_B, STAT_max_hp);
         set_proto_data(581, PROTO_DR_STAT_C, STAT_melee_dmg);
         set_proto_data(581, PROTO_DR_AMOUNT_1_B, 2);
         set_proto_data(581, PROTO_DR_AMOUNT_2_B, -2);
         set_proto_data(581, PROTO_DR_AMOUNT_1_C, 1);
         set_proto_data(581, PROTO_DR_AMOUNT_2_C, -1);
         //cola heal hp instead of hr
         set_proto_data(583, PROTO_DR_STAT_A, STAT_current_hp);
         set_proto_data(583, PROTO_DR_AMOUNT_1_A, 3);
         set_proto_data(583, PROTO_DR_AMOUNT_2_A, 0);
         //обед кОрОванщика
         set_proto_data(672, PROTO_DR_STAT_A, STAT_max_hp);
         set_proto_data(672, PROTO_DR_STAT_B, STAT_carry_amt);
         set_proto_data(672, PROTO_DR_AMOUNT_1_A, 10);
         set_proto_data(672, PROTO_DR_AMOUNT_1_B, 15);
         set_proto_data(672, PROTO_DR_DURATION_1, 1440);
         set_proto_data(672, PROTO_DR_AMOUNT_2_A, -10);
         set_proto_data(672, PROTO_DR_AMOUNT_2_B, -15);
         //potroh heal hp instead of hr
         set_proto_data(708, PROTO_DR_STAT_A, STAT_current_hp);
         set_proto_data(708, PROTO_DR_AMOUNT_1_A, 4);
         set_proto_data(708, PROTO_DR_AMOUNT_2_A, 0);
         //drgn meat crit instead of hr
         set_proto_data(743, PROTO_DR_STAT_A, STAT_crit_chance);
         set_proto_data(743, PROTO_DR_STAT_B, STAT_current_hp);
         set_proto_data(743, PROTO_DR_AMOUNT_1_A, 2);
         set_proto_data(743, PROTO_DR_AMOUNT_1_B, 10);
         set_proto_data(743, PROTO_DR_AMOUNT_2_A, -2);
         set_proto_data(743, PROTO_DR_AMOUNT_2_B, 0);
         set_proto_data(743, PROTO_DR_AMOUNT_3_A, 0);
         set_proto_data(743, PROTO_DR_AMOUNT_3_B, 0);
      end
      // Sonora food
      else if Sonora > 0 then begin
         set_proto_data(64, PROTO_DR_STAT_A, STAT_current_hp);
         set_proto_data(64, PROTO_DR_STAT_B, STAT_max_hp);
         set_proto_data(64, PROTO_DR_STAT_C, -1);
         set_proto_data(64, PROTO_DR_AMOUNT_1_A, 10);
         set_proto_data(64, PROTO_DR_AMOUNT_1_B, 2);
         set_proto_data(64, PROTO_DR_AMOUNT_1_C, 0);
         set_proto_data(64, PROTO_DR_DURATION_1, 1440);
         set_proto_data(64, PROTO_DR_AMOUNT_2_A, 0);
         set_proto_data(64, PROTO_DR_AMOUNT_2_B, -2);
         set_proto_data(64, PROTO_DR_AMOUNT_2_C, 0);
         set_proto_data(64, PROTO_DR_DURATION_2, 0);
         set_proto_data(64, PROTO_DR_AMOUNT_3_A, 0);
         set_proto_data(64, PROTO_DR_AMOUNT_3_B, 0);
         set_proto_data(64, PROTO_DR_AMOUNT_3_C, 0);
         set_proto_data(64, PROTO_DR_ADDICT_CHANCE, 0);
         set_proto_data(64, PROTO_DR_ADDICT_PERK, 0);
         set_proto_data(64, PROTO_DR_ADDICT_DELAY, 0);

         //MRE
         set_proto_data(68, PROTO_DR_STAT_A, STAT_max_hp);
         set_proto_data(68, PROTO_DR_STAT_B, STAT_current_poison);
         set_proto_data(68, PROTO_DR_STAT_C, STAT_current_hp);
         set_proto_data(68, PROTO_DR_AMOUNT_1_A, 5);
         set_proto_data(68, PROTO_DR_AMOUNT_1_B, -10);
         set_proto_data(68, PROTO_DR_AMOUNT_1_C, 12);
         set_proto_data(68, PROTO_DR_DURATION_1, 2880);
         set_proto_data(68, PROTO_DR_AMOUNT_2_A, -5);
         set_proto_data(68, PROTO_DR_AMOUNT_2_B, 0);
         set_proto_data(68, PROTO_DR_AMOUNT_2_C, 0);
         set_proto_data(68, PROTO_DR_DURATION_2, 0);
         set_proto_data(68, PROTO_DR_AMOUNT_3_A, 0);
         set_proto_data(68, PROTO_DR_AMOUNT_3_B, 0);
         set_proto_data(68, PROTO_DR_AMOUNT_3_C, 0);
         set_proto_data(68, PROTO_DR_ADDICT_CHANCE, 0);
         set_proto_data(68, PROTO_DR_ADDICT_PERK, 0);
         set_proto_data(68, PROTO_DR_ADDICT_DELAY, 0);
      end
   end
end

inline procedure float_msg_disable begin
   if float_msg_disabled == 0 then begin
      float_msg_disabled = read_byte(0x459280);
      write_byte(0x459280, 0xC3);
   end
end

inline procedure float_msg_enable begin
   if float_msg_disabled != 0 then begin
      write_byte(0x459280, float_msg_disabled);
      float_msg_disabled = 0;
   end
end



procedure add_to_events_remove_from_tmp(variable event_key) begin
   variable i;
   variable value;
   variable next_event_key;
   variable cur_key;
   while event_key != 0 do begin
      next_event_key = get_array(tmp_map_exit_event_array, event_key + next_event_key_offset);
      for (i = 0; i < MAX_event_offset; i++) begin
         cur_key = event_key + i;
         value = get_array(tmp_map_exit_event_array, cur_key);
         if value != 0 then begin
            set_array(event_queue_array,  cur_key, value);

            set_array(tmp_map_exit_event_array, cur_key, 0);
         end
      end
      event_key = next_event_key;
   end
end

procedure merge_event_arrays begin
   variable critter_id;
   variable next_event_key;
   variable event_type;
   variable stat;
   variable stat_value;
   variable cur_burn_count;
   variable event_key;
   variable str_key;
   variable is_str;
   if len_array(tmp_map_exit_event_array) > 0 then begin
      event_key = array_key(tmp_map_exit_event_array,0);
      if get_free_key_queue_event_array_char != 0 then
         is_str = 1;

      if is_str then begin
         str_key = substr(event_key, 0, -1);
         if str_key != -1 then
            event_key = str_key;
      end

      while event_key != 0 do begin
         call add_to_events_remove_from_tmp(event_key);
         if len_array(tmp_map_exit_event_array) > 0 then begin
            event_key = array_key(tmp_map_exit_event_array,0);
            if is_str then begin
               str_key = substr(event_key, 0, -1);
               if str_key != -1 then
                  event_key = str_key;
            end
         end
         else
            event_key = 0;
      end
      clear_array(tmp_map_exit_event_array);
   end
end

procedure add_to_tmp_remove_from_global(variable event_key) begin
   variable i;
   variable value;
   variable next_event_key;
   variable cur_key;
   while event_key != 0 do begin
      next_event_key = get_array(event_queue_array, event_key + next_event_key_offset);
      for (i = 0; i < MAX_event_offset; i++) begin
         cur_key = event_key + i;
         value = get_array(event_queue_array, cur_key);
         if value != 0 then begin
            set_array(tmp_map_exit_event_array,  cur_key, value);

            set_array(event_queue_array, cur_key, 0);
         end
      end
      event_key = next_event_key;
   end
end

procedure merge_event_arrays_after_global begin
   variable critter_id;
   variable next_event_key;
   variable event_type;
   variable stat;
   variable stat_value;
   variable cur_burn_count;
   variable event_key;
   variable str_key;
   variable is_str;
   if len_array(event_queue_array) > 0 then begin
      event_key = array_key(event_queue_array,0);
      if get_free_key_queue_event_array_char != 0 then
         is_str = 1;

      if is_str then begin
         str_key = substr(event_key, 0, -1);
         if str_key != -1 then
            event_key = str_key;
      end

      while event_key != 0 do begin
         call add_to_tmp_remove_from_global(event_key);
         if len_array(event_queue_array) > 0 then begin
            event_key = array_key(event_queue_array,0);
            if is_str then begin
               str_key = substr(event_key, 0, -1);
               if str_key != -1 then
                  event_key = str_key;
            end
         end
         else
            event_key = 0;
      end
      clear_array(event_queue_array);
   end
end

procedure restore_saved_stats_party_lvl_up(variable party_array) begin
   variable critter;
   variable critter_pid;
   variable critter_id;
   variable critter_id_arr_key;
   variable critter_lvl;
   variable critter_stat;
   variable i;
   foreach critter in party_array begin
      if critter == real_dude_obj orElse obj_type(critter) != OBJ_TYPE_CRITTER then
         continue;
      critter_id = check_id(critter);
      critter_id_arr_key = get_saved_stats_key(critter_id);
      if has_saved_stats(critter_id_arr_key) > 0 then begin
         critter_pid = obj_pid(critter);
         critter_lvl = get_npc_level(critter_pid);
         if critter_lvl < 0 then
            critter_lvl = 0;
         if critter_lvl != get_array(party_levels, critter_pid) then begin
            set_array(party_levels, critter_pid, critter_lvl);
            for (i = 0; i <= STAT_poison_resist; i++) begin
               critter_stat = get_array(id_to_saved_stats, (critter_id_arr_key + i));
               if critter_stat != 0 then begin
                  set_critter_extra_stat(critter, i, (get_critter_extra_stat(critter, i) + critter_stat));
               end
            end
         end
      end
   end
end

procedure GAMEMODECHANGE begin
   variable game_exit = get_sfall_arg;
   variable lastgamemode = get_sfall_arg;
   variable game_mode = get_game_mode;
   variable cur_map_event_array_name;
   if game_exit then begin
      call float_msg_enable;
      game_ui_enable;
      return;
   end

   if resting > 0 andAlso not(game_mode bwand PIPBOY) then begin
      resting = 0;
      remove_timer_event(fixed_param_all_in_one);
      add_global_timer_event(0, fixed_param_all_in_one);
      call float_msg_enable;
   end
   if game_mode <= 0 orElse game_mode == COMBAT orElse game_mode == (COMBAT bwor PCOMBAT) then begin
      call restore_saved_stats_party_lvl_up(party_member_list(1));
      if fake_quit != 0 then begin
         fake_quit = 0;
         write_int(0x5186CC, fake_quit);
      end
      else begin
         if delayed_ui_disable > 0 then begin
            if resting <= 0 andAlso death_array_active > 0 then begin
               game_ui_disable2;
               call callback_set_cursor_animated_watch;
            end
            delayed_ui_disable = 0;
         end
      end
   end

   if death_array_active > 0 andAlso game_mode bwand COMBAT andAlso not(lastgamemode bwand COMBAT) then begin
      after_rest_death = 1;
      call show_death_msg;
      after_rest_death = 0;
   end
   on_global_map = 0;
   if lastgamemode bwand OPTIONS then begin
      combat_diff = (combat_difficulty + 1);
   end
   if npc_overhealed > 0 then begin
      call npc_max_hr_add_regen_items;
   end

   if (lastgamemode bwand CHARSCREEN) orElse (game_mode bwand CHARSCREEN) then begin
      if faster_healing_bonus == -99 then
         call get_PERK_faster_healing_bonus;
      call newperks;
   end

   if game_mode bwand PIPBOY then begin
      set_stat_min(STAT_heal_rate, 0);
   end
   else begin
      after_rest_death = 0;
      if (game_mode bwand WORLDMAP) then begin
         set_stat_min(STAT_heal_rate, 0);
         on_global_map = 1;
         call set_drugs_proto;
         cur_map_event_array_name = event_queue_array_name + ("WM");
         event_queue_array = load_array(cur_map_event_array_name);
         if not event_queue_array then begin
            event_queue_array = create_array_map;
            save_array(cur_map_event_array_name, event_queue_array);
         end
         call merge_event_arrays;
      end
      else if lastgamemode bwand PIPBOY orElse lastgamemode bwand WORLDMAP then begin
         set_stat_min(STAT_heal_rate, -new_max_hr);
         remove_timer_event(fixed_param_all_in_one);
         add_global_timer_event(all_in_one_repeat_time, fixed_param_all_in_one);
         call float_msg_enable;
      end
   end
   call check_regen_tag;
end

// check for a healing item based on the critter's poison lvl (no antidote))
procedure check_poison_healing_item(variable critter,variable critter_max_hp,variable critter_cur_hp,variable PoisonTickDmg, variable set_false_hr) begin
   variable healing_item;
   variable healing_item_pid;
   variable has_stim;
   variable has_super_stim;
   variable has_hypo;
   variable has_healing_powder;
   variable has_doc_item;
   variable has_fa_item;
   variable has_super_doc_item;
   variable has_super_fa_item;
   variable next_regen_tick;
   variable critter_hr;
   variable new_critter_hr;
   // If the critter is not poisoned or the current HP is safe, exit the function
   if PoisonTickDmg <= 0 orElse (critter_cur_hp - PoisonTickDmg) >= critter_max_hp orElse (critter_cur_hp - 3) > (3 * PoisonTickDmg) then begin
      return 0;
   end
   // Check for stims
   has_stim = obj_is_carrying_obj_pid(Critter, PID_STIMPAK);
   if has_stim > 0 then begin
      if RegenMod > 0 then begin
         critter_hr = get_critter_stat(critter, STAT_heal_rate);
         if critter_hr < new_max_hr then begin
            healing_item_pid = PID_STIMPAK;
         end
         new_critter_hr = get_critter_base_stat(critter, STAT_heal_rate) + get_critter_extra_stat(critter, STAT_heal_rate) + 20;
         if new_critter_hr + set_false_hr > new_max_hr then begin
            new_critter_hr = new_max_hr;
         end
         if critter_hr >= min_hr_to_regen then begin
            next_regen_tick = calc_regen_tick(critter, (new_critter_hr));
         end
      end
      else begin
         healing_item_pid = PID_STIMPAK;
         next_regen_tick = 9;
      end
      // If the regeneration is not sufficient, check for super stimpacks
      if 2 * PoisonTickDmg >= (critter_cur_hp + next_regen_tick) then begin
         has_super_stim = obj_is_carrying_obj_pid(Critter, PID_SUPER_STIMPAK);
         if has_super_stim > 0 then begin
            healing_item_pid = PID_SUPER_STIMPAK;
         end
         else begin
            has_hypo = obj_is_carrying_obj_pid(Critter, 525);
            //hypo
            if has_hypo > 0 then begin
               healing_item_pid = 525;
            end
         end
      end
   end
   else begin
      if NPCsUseMedTools >= 2 orElse (NPCsUseMedTools == 1 andAlso not(is_in_array(critter, party_member_list(0)))) then begin
         has_doc_item = obj_is_carrying_obj_pid(Critter, doc_bag_pid);
         if Sonora <= 0 then begin
            has_fa_item = obj_is_carrying_obj_pid(Critter, PID_FIRST_AID_KIT);
            has_super_doc_item = obj_is_carrying_obj_pid(Critter, PID_PARAMEDICS_BAG);
            has_super_fa_item = obj_is_carrying_obj_pid(Critter, PID_FIELD_MEDIC_KIT);
         end
         if has_fa_item > 0 then begin
            healing_item_pid = PID_FIRST_AID_KIT;
         end
         else if has_super_fa_item > 0 then begin
            healing_item_pid = PID_FIELD_MEDIC_KIT;
         end
         else if has_doc_item > 0 then begin
            healing_item_pid = doc_bag_pid;
         end
         else if has_super_doc_item > 0 then begin
            healing_item_pid = PID_PARAMEDICS_BAG;
         end
      end
   end
   if healing_item_pid <= 0 andAlso has_stim <= 0 then begin
      has_super_stim = obj_is_carrying_obj_pid(Critter, PID_SUPER_STIMPAK);
      if has_super_stim > 0 then begin
         healing_item_pid = PID_SUPER_STIMPAK;
      end
      else if Sonora <= 0 then begin
         has_hypo = obj_is_carrying_obj_pid(Critter, 525);
         //hypo
         if has_hypo > 0 then begin
            healing_item_pid = 525;
         end
         else begin
            has_healing_powder = obj_is_carrying_obj_pid(Critter, PID_HEALING_POWDER);
            if has_healing_powder > 0 then begin
               healing_item_pid = PID_HEALING_POWDER;
            end
         end
      end
   end
   if healing_item_pid > 0 then begin
      healing_item = obj_carrying_pid_obj(critter, healing_item_pid);
   end
   return healing_item;
end

procedure get_poison_dmg_by_id(variable critter, variable unique_id, variable critter_in_party, variable skip_party = 0, variable skip_msg = 0, variable count = 1) begin
   variable critter_cur_hp;
   variable critter_cur_poison;
   variable critter_cur_poison2;
   variable i;
   variable PoisonTickDmg;
   if critter > 0 andAlso get_array(death_array, critter) <= 0 then begin
      critter_cur_poison = get_poison(critter);
      if critter_cur_poison <= 0 then begin
         if get_array(id_to_poison_time, unique_id) != 0 then
            set_array(id_to_poison_time, unique_id, 0);

         if get_array(id_to_poison_fraction, unique_id) != 0 then
            set_array(id_to_poison_fraction, unique_id, 0);

         return -1;
      end
      critter_cur_poison -= get_array(id_to_poison_fraction, unique_id);

      critter_cur_hp = get_critter_stat(critter, STAT_current_hp);
      if critter_cur_hp > 0 then begin
         if combat_is_initialized then
            PoisonTickDmg = calc_poison_dmg(critter, unique_id, critter_cur_poison, count);
         else begin
            PoisonTickDmg = calc_poison_dmg(critter, unique_id, critter_cur_poison, count);
            call critter_try_use_antidote_heal(critter, critter_in_party, skip_msg, PoisonTickDmg, count);
            critter_cur_poison2 = get_poison(critter) - get_array(id_to_poison_fraction, unique_id);
            if critter_cur_poison2 != critter_cur_poison then
               PoisonTickDmg = calc_poison_dmg(critter, unique_id, critter_cur_poison2, count);
         end
      end
   end

   return PoisonTickDmg;
end

procedure queue_remove_all(variable critter_id) begin
   variable event_key = get_first_event_key(critter_id);
   variable next_event_key;
   variable i;
   while event_key != 0 do begin
      next_event_key = get_array(event_queue_array, event_key + next_event_key_offset);
      for (i = 0; i < MAX_event_offset; i++) begin
         set_array(event_queue_array, event_key + i, 0);
      end
      event_key = next_event_key;
   end
   set_first_event_key(critter_id, 0);
end

inline procedure remove_from_saved_stats(variable critter_id) begin
   variable critter_id_arr_key;
   variable cur_key;
   variable i;
   critter_id_arr_key = get_saved_stats_key(critter_id);
   if has_saved_stats(critter_id_arr_key) > 0 then begin
      for (i = 0; i < saved_stat_max; i++) begin
         cur_key = critter_id_arr_key + i;
         if get_array(id_to_saved_stats, cur_key) != 0 then
            set_array(id_to_saved_stats, cur_key, 0);
      end
   end
end

procedure remove_from_everywhere_critter(variable critter) begin
   variable critter_id = get_unique_id(critter);

   if get_array(id_to_regen_time, critter_id) != 0 then
      set_array(id_to_regen_time, critter_id, 0);

   if get_array(id_to_poison_time, critter_id) != 0 then
      set_array(id_to_poison_time, critter_id, 0);

   if get_array(id_to_poison_fraction, critter_id) != 0 then
      set_array(id_to_poison_fraction, critter_id, 0);

   if get_array(id_to_burn_count, critter_id) != 0 then
      set_array(id_to_burn_count, critter_id, 0);

   call remove_from_saved_stats(critter_id);
   call queue_remove_all(critter_id);
end

procedure ONDEATH begin
   variable critter = get_sfall_arg;
   call remove_from_everywhere_critter(critter);
   if critter == dude_obj andAlso dude_obj != real_dude_obj then
      set_dude_obj(real_dude_obj);
end

procedure queue_add_poison_event(variable critter_id, variable time) begin
   variable free_key;
   variable new_key;
   variable first_event_key;
   variable first_event_time;
   variable cur_key;
   variable cur_time ;
   variable next_time;
   variable next_key;
   variable new_key_to_save;
   variable free_key_char = get_free_key_queue_event_array_char;
   if has_custom_event_type(critter_id, EVENT_TYPE_POISON_CUSTOM) then begin
      return;
   end
   free_key = get_free_key_queue_event_array;
   new_key = free_key;
   first_event_key = get_first_event_key(critter_id);
   first_event_time = get_event_time(first_event_key);
   cur_key = first_event_key;
   cur_time = first_event_time;
   new_key_to_save = new_key + MAX_event_offset;
   free_key_char = get_free_key_queue_event_array_char;

   if new_key_to_save < forbidden_event_key andAlso new_key_to_save > -forbidden_event_key then begin
      new_key = forbidden_event_key;
      new_key_to_save = forbidden_event_key + MAX_event_offset;
   end
   if new_key_to_save >= INT32_MAX_key then begin
      new_key = INT32_MIN;
      new_key_to_save = new_key + MAX_event_offset;
      if free_key_char == 0 then
         free_key_char = "A";
      else
         free_key_char = sprintf("%c", charcode(free_key_char) + 1);

      set_free_key_queue_event_array_char(free_key_char);
   end
   set_free_key_queue_event_array(new_key_to_save);
   if free_key_char != 0 then
      new_key = free_key_char + new_key;

   //add to id_to_poison_time array
   set_array(id_to_poison_time, critter_id, time);
   set_array(event_queue_array, new_key + time_offset, time);
   set_array(event_queue_array, new_key + event_type_offset, EVENT_TYPE_POISON_CUSTOM);
   //set_array(event_queue_array, new_key + stat_offset, 0);
   //set_array(event_queue_array, new_key + stat_value_offset, 0);
   //set_array(event_queue_array, new_key + drug_pid_offset, 0);
   //set_array(event_queue_array, new_key + g_offset, 0);
   //set_array(event_queue_array, new_key + h_offset, 0);

   // Check if its new event
   if first_event_key == 0 orElse (time < first_event_time) then begin
      set_first_event_key(critter_id, new_key);
      set_array(event_queue_array, new_key + next_event_key_offset, first_event_key);
      return;
   end

   cur_key = first_event_key;
   next_key = get_array(event_queue_array, first_event_key + next_event_key_offset);

   while (next_key != 0) do begin
      next_time = get_array(event_queue_array, next_key + time_offset);
      if (time < next_time) then begin
         break;
      end
      cur_key = next_key;
      next_key = get_array(event_queue_array, next_key + next_event_key_offset);
   end

   set_array(event_queue_array, new_key + next_event_key_offset, next_key);
   set_array(event_queue_array, cur_key + next_event_key_offset, new_key);
end


procedure disabled_scr_events_queue_critter(variable critter) begin
   variable critter_cur_hp;
   variable critter_id;
   variable next_event_key;
   variable event_key;
   variable event_type;
   variable stat;
   variable stat_value;
   variable cur_burn_count;
   if not(array_exists(event_queue_array)) then
      return;
   critter_cur_hp = get_critter_stat(critter, STAT_current_hp);
   if not(is_really_dead(critter, critter_state(critter), critter_cur_hp)) andAlso get_array(death_array, critter) == 0 then begin
      critter_id = get_unique_id(critter);
      event_key = get_first_event_key(critter_id);
      if event_key != 0 then begin
         while event_key != 0 do begin
            event_type = get_array(event_queue_array, event_key + event_type_offset);
            set_array(event_queue_array, event_key + event_type_offset, 0);
            if event_type == EVENT_TYPE_DRUG_CUSTOM then begin
               stat = get_array(event_queue_array, event_key + stat_offset);
               stat_value = get_array(event_queue_array, event_key + stat_value_offset);
               call add_and_save_stats(critter, critter_id, stat, stat_value, true, true);
            end
            else if event_type == EVENT_TYPE_BURN then begin
               set_array(id_to_burn_count, critter_id, 0);
               if critter == dude_obj andAlso is_iface_tag_active(iface_tag_burn) then begin
                  hide_iface_tag(iface_tag_burn);
               end

               stat = get_array(event_queue_array, event_key + stat_offset);
               stat_value = get_array(event_queue_array, event_key + stat_value_offset);
               call add_and_save_stats(critter, critter_id, stat, stat_value, true, true);
               stat = get_array(event_queue_array, event_key + stat2_offset);
               stat_value = get_array(event_queue_array, event_key + stat2_value_offset);
               call add_and_save_stats(critter, critter_id, stat, stat_value, true, true);
            end
            else if event_type == EVENT_TYPE_POISON_CUSTOM then begin
               set_array(id_to_poison_time, critter_id, 0);
               set_array(id_to_poison_fraction, critter_id, 0);
            end
            else if event_type == EVENT_TYPE_REGENERATION then begin
               set_array(id_to_regen_time, critter_id, 0);
            end
            next_event_key = get_array(event_queue_array, event_key + next_event_key_offset);
            set_first_event_key(critter_id, next_event_key);
            call queue_remove(critter_id, event_key);
            event_key = next_event_key;
         end
      end
   end
end

procedure check_events_queue_critter(variable critter, variable party_array, variable cur_game_time, variable no_break = 0) begin
   variable critter_cur_hp;
   variable critter_max_hp;
   variable critter_id;
   variable PoisonTickDmg;
   variable RegenTickHP;
   variable critter_in_party;
   variable next_event_key;
   variable event_key;
   variable event_time;
   variable event_type;
   variable stat;
   variable stat_value;
   variable cur_poison;
   variable was_add_regen;
   variable was_add_poison;
   variable next_regen_time;
   variable event_procces;
   variable cur_burn;
   event_procces = 0;
   critter_cur_hp = get_critter_stat(critter, STAT_current_hp);
   if not(is_really_dead(critter, critter_state(critter), critter_cur_hp)) andAlso get_array(death_array, critter) == 0 then begin
      critter_id = check_id(critter);
      //call check_id(critter, critter_id);

      event_key = get_first_event_key(critter_id);

      if event_key != 0 then begin
         critter_in_party = is_in_array(critter, party_array);
         while event_key != 0 do begin
            event_time = get_event_time(event_key);
            if event_time <= cur_game_time then begin
               set_game_time_no_queue_check(event_time);
               was_add_regen = 0;
               was_add_poison = 0;
               event_type = get_array(event_queue_array, event_key + event_type_offset);
               set_array(event_queue_array, event_key + event_type_offset, 0);
               if event_type == EVENT_TYPE_POISON_CUSTOM then begin
                  PoisonTickDmg = get_poison_dmg_by_id(critter, critter_id, critter_in_party, false, false, 1);
                  if PoisonTickDmg > 0 then begin
                     call critter_heal_regen_poison(critter, 0, PoisonTickDmg, map_enter, true);
                     call queue_add_poison_event(critter_id, event_time + poison_repeat_ticks);
                     PoisonTickDmg = 0;
                     was_add_poison = 1;
                  end
                  call decrease_poison(critter, 0, true, 1);
               end
               else if event_type == EVENT_TYPE_REGENERATION then begin
                  RegenTickHP = get_regen_by_id(critter, critter_id, PoisonTickDmg, 0);
                  if RegenTickHP >= 0 then begin
                     call queue_add_regen_event(critter_id, event_time + regen_repeat_ticks);
                     was_add_regen = 1;
                     if RegenTickHP > 0 orElse PoisonTickDmg > 0 then
                        call critter_heal_regen_poison(critter, RegenTickHP, 0, map_enter, true);
                  end
                  RegenTickHP = 0;
               end
               else if event_type == EVENT_TYPE_DRUG_CUSTOM then begin
                  stat = get_array(event_queue_array, event_key + stat_offset);
                  stat_value = get_array(event_queue_array, event_key + stat_value_offset);
                  call add_and_save_stats(critter, critter_id, stat, stat_value, true, true);
               end
               else if event_type == EVENT_TYPE_BURN then begin
                  call add_burn_effect_to_saved_arrays(critter, -1);

                  stat = get_array(event_queue_array, event_key + stat_offset);
                  stat_value = get_array(event_queue_array, event_key + stat_value_offset);
                  call add_and_save_stats(critter, critter_id, stat, stat_value, true, true);

                  stat = get_array(event_queue_array, event_key + stat2_offset);
                  stat_value = get_array(event_queue_array, event_key + stat2_value_offset);
                  call add_and_save_stats(critter, critter_id, stat, stat_value, true, true);
               end


               if PoisonMod > 0 andAlso was_add_poison <= 0 then begin
                  if get_poison(critter) > 0 andAlso get_array(id_to_poison_time, critter_id) <= 0 then begin
                     call queue_add_poison_event(critter_id, event_time + poison_repeat_ticks);
                     was_add_poison = 1;
                  end
               end
               if RegenMod > 0 then begin
                  critter_cur_hp = get_critter_stat(critter, STAT_current_hp);
                  critter_max_hp = get_critter_stat(critter, STAT_max_hp);
                  if was_add_regen <= 0 andAlso get_critter_stat(critter, STAT_heal_rate) >= min_hr_to_regen andAlso critter_cur_hp < critter_max_hp then begin
                     next_regen_time = get_array(id_to_regen_time, critter_id);
                     if next_regen_time <= 0 then begin
                        call queue_add_regen_event(critter_id, event_time + regen_repeat_ticks);
                        was_add_regen = 1;
                     end
                     else if next_regen_time <= event_time then begin
                        next_regen_time = regen_repeat_ticks - (event_time - next_regen_time) % regen_repeat_ticks;
                        call queue_add_regen_event(critter_id, event_time + next_regen_time);
                        was_add_regen = 1;
                     end
                  end
                  else if critter_cur_hp >= critter_max_hp then begin
                     cur_burn = get_array(id_to_burn_count, critter_id);
                     if cur_burn > 0 then begin
                        call add_burn_effect_to_saved_arrays(critter, -cur_burn);
                     end
                  end
               end

               next_event_key = get_array(event_queue_array, event_key + next_event_key_offset);
               set_first_event_key(critter_id, next_event_key);
               call queue_remove(critter_id, event_key);
               event_key = next_event_key;
               event_procces = 1;
               if no_break <= 0 then
                  break;
            end
            //not yet
            else begin
               event_key = 0;
            end
         end
      end
      if RegenMod > 0 then begin
         critter_cur_hp = get_critter_stat(critter, STAT_current_hp);
         critter_max_hp = get_critter_stat(critter, STAT_max_hp);
         if was_add_regen <= 0 andAlso get_critter_stat(critter, STAT_heal_rate) >= min_hr_to_regen andAlso critter_cur_hp < critter_max_hp then begin
            next_regen_time = get_array(id_to_regen_time, critter_id);
            if next_regen_time <= 0 then begin
               call queue_add_regen_event(critter_id, cur_game_time + regen_repeat_ticks);
               was_add_regen = 1;
            end
            else if next_regen_time <= cur_game_time then begin
               next_regen_time = regen_repeat_ticks - (cur_game_time - next_regen_time) % regen_repeat_ticks;
               call queue_add_regen_event(critter_id, cur_game_time + next_regen_time);
               was_add_regen = 1;
            end
         end
         else if critter_cur_hp >= critter_max_hp then begin
            cur_burn = get_array(id_to_burn_count, critter_id);
            if cur_burn > 0 then begin
               call add_burn_effect_to_saved_arrays(critter, -cur_burn);
            end
         end
      end


      if PoisonMod > 0 andAlso was_add_poison <= 0 then begin
         if get_poison(critter) > 0 andAlso get_array(id_to_poison_time, critter_id) <= 0 then begin
            call queue_add_poison_event(critter_id, cur_game_time + poison_repeat_ticks);
         end
      end
   end
   set_game_time_no_queue_check(cur_game_time);
   return event_procces;
end

procedure queue_original_check_events_all_with_custom_queue(variable cur_game_time, variable party_array, variable cur_critters_array) begin
   variable queueHeadAddress = 0x6648C0;
   variable queueHead = read_int(queueHeadAddress);
   variable queueNode = queueHead;
   variable nextNodeAddress;
   variable eventTime;
   variable eventType;
   variable eventOwner;
   variable eventData;
   variable eventTypeDescriptionAddress;
   variable HandlerProc;
   variable freeProc;
   variable prevNode;
   variable next_regen_time;
   variable critter_id;
   variable real_game_time = game_time;
   variable events;
   variable stop_proc;
   variable last_check_cutom_events;
   while (queueNode != 0) do begin
      eventTime = read_int(queueNode);
      if (eventTime > cur_game_time) then
         break;

      eventType = read_int(queueNode + eventType_offset);
      if resting andAlso (eventType == EVENT_TYPE_EXPLOSION orElse eventType == EVENT_TYPE_EXPLOSION_FAILURE orElse eventType == EVENT_TYPE_RADIATION) then begin
         set_game_time_no_queue_check(real_game_time);
         events = 1;
         while events do begin
            events = 0;
            foreach eventOwner in cur_critters_array begin
               if check_events_queue_critter(eventOwner, party_array, eventTime) then begin
                  events = 1;
                  continue;
               end
            end
         end
         call close_all_wins(get_game_mode);
         return;
      end
      if is_event_allowed(eventType) then begin
         set_game_time_no_queue_check(eventTime);

         eventOwner = read_int(queueNode + eventOwner_offset);
         if last_check_cutom_events < eventTime andAlso eventOwner > 0 andAlso obj_type(eventOwner) == OBJ_TYPE_CRITTER then begin
            events = 1;
            while events do begin
               events = 0;
               foreach eventOwner in cur_critters_array begin
                  if check_events_queue_critter(eventOwner, party_array, eventTime) then begin
                     events = 1;
                     continue;
                  end
               end
            end
            last_check_cutom_events = eventTime;
            stop_proc = 1;
         end

         if stop_proc <= 0 andAlso (eventOwner <= 0 orElse (eventOwner > 0 andAlso (PID_TYPE(obj_pid(eventOwner)) != OBJ_TYPE_CRITTER orElse (is_really_dead(eventOwner, critter_state(eventOwner), get_critter_stat(eventOwner, STAT_current_hp)) <= 0 andAlso get_array(death_array, eventOwner) <= 0)))) then begin
            nextNodeAddress = read_int(queueNode + eventNextNode_offset);


            eventTypeDescriptionAddress = 0x51C540 + (eventType * 0x18);
            if eventType == EVENT_TYPE_DRUG then
               HandlerProc = 0x47A198;
            else if eventType == EVENT_TYPE_WITHDRAWAL then begin
               HandlerProc = 0x47A384;
            end
            else if eventType == EVENT_TYPE_POISON then begin
               HandlerProc = 0x42D318;
            end
            else if eventType == EVENT_TYPE_RADIATION then begin
               HandlerProc = 0x47A384;
            end
            else
               HandlerProc = read_int(eventTypeDescriptionAddress);

            if HandlerProc > 0 andAlso HandlerProc < 0x10000000 then begin

               queueHead = read_int(queueHeadAddress);
               if (queueNode == queueHead) then begin
                  queueHead = nextNodeAddress;
                  write_int(queueHeadAddress, nextNodeAddress);
               end
               else begin
                  if (prevNode != 0) then
                     write_int(prevNode + eventNextNode_offset, nextNodeAddress);
               end

               eventData = read_int(queueNode + eventData_offset);

               if (HandlerProc != 0) then begin
                  stop_proc = call_offset_r2(HandlerProc, eventOwner, eventData);
               end

               if RegenMod > 0 andAlso eventOwner > 0 andAlso obj_type(eventOwner) == OBJ_TYPE_CRITTER then begin
                  critter_id = get_unique_id(eventOwner);
                  if get_critter_stat(eventOwner, STAT_heal_rate) >= min_hr_to_regen andAlso get_critter_stat(eventOwner, STAT_current_hp) < get_critter_stat(eventOwner, STAT_max_hp) then begin
                     next_regen_time = get_array(id_to_regen_time, critter_id);
                     if next_regen_time <= 0 then begin
                        call queue_add_regen_event(critter_id, eventTime + regen_repeat_ticks);
                     end
                     else if next_regen_time <= eventTime then begin
                        next_regen_time = regen_repeat_ticks - (eventTime - next_regen_time) % regen_repeat_ticks;
                        call queue_add_regen_event(critter_id, eventTime + next_regen_time);
                     end
                  end
               end


               if is_event_has_free_proc(eventType) then
                  freeProc = 0x4C5C24;
               else
                  freeProc = read_int(eventTypeDescriptionAddress + 0x04);

               if freeProc != 0 andAlso eventData != 0 then begin
                  call_offset_v1(freeProc, eventData);
               end


               if queueNode != 0 then
                  call_offset_v1(0x4C5C24, queueNode);
            end
            queueNode = nextNodeAddress;
         end
         if stop_proc > 0 then
            queueNode = read_int(queueHeadAddress);
         stop_proc = 0;
      end
      else begin
         prevNode = queueNode;
         queueNode = read_int(queueNode + eventNextNode_offset);
      end
   end
   set_game_time_no_queue_check(real_game_time);
end

procedure queue_original_check_allowed_events_critter(variable critter, variable cur_game_time) begin
   variable queueHeadAddress = 0x6648C0; // Start of the queue
   variable queueHead = read_int(queueHeadAddress);
   variable queueNode = queueHead; // First element of the queue
   variable nextNodeAddress;
   variable eventTime;
   variable eventType;
   variable eventOwner;
   variable eventData;
   variable eventTypeDescriptionAddress;
   variable handlerProc;
   variable freeProc;
   variable prevNode;
   variable real_game_time = game_time;
   variable sfall_handler;
   set_game_time_no_queue_check(cur_game_time);
   while (queueNode != 0) do begin
      eventTime = read_int(queueNode);
      if eventTime > cur_game_time then
         break;

      eventOwner = read_int(queueNode + eventOwner_offset);
      if eventOwner == critter then
         eventType = read_int(queueNode + eventType_offset);
      else
         eventType = -1;

      if is_event_allowed(eventType) then begin
         if is_event_real_timed(eventType) then
            set_game_time_no_queue_check(cur_game_time);
         else
            set_game_time_no_queue_check(eventTime);

         // Update the queue head/next node
         queueHead = read_int(queueHeadAddress);
         nextNodeAddress = read_int(queueNode + eventNextNode_offset);
         if (queueNode == queueHead) then begin
            queueHead = nextNodeAddress;
            write_int(queueHeadAddress, nextNodeAddress);
         end
         else begin
            if (prevNode != 0) then
               write_int(prevNode + eventNextNode_offset, nextNodeAddress);
         end


         eventTypeDescriptionAddress = 0x51C540 + (eventType * 0x18);
         if eventType == EVENT_TYPE_DRUG then
            HandlerProc = 0x47A198;
         else if eventType == EVENT_TYPE_WITHDRAWAL then begin
            HandlerProc = 0x47A384;
         end
         else if eventType == EVENT_TYPE_POISON then begin
            HandlerProc = 0x42D318;
         end
         else if eventType == EVENT_TYPE_RADIATION then begin
            HandlerProc = 0x47A384;
         end
         else
            HandlerProc = read_int(eventTypeDescriptionAddress);

         if HandlerProc >= 0x10000000 then
            sfall_handler = 1;

         if sfall_handler <= 0 then begin
            eventData = read_int(queueNode + eventData_offset);
            if is_event_has_free_proc(eventType) then
               freeProc = 0x4C5C24;
            else
               freeProc = read_int(eventTypeDescriptionAddress + 0x04);

            // Execute current event
            if (HandlerProc != 0) then begin
               call_offset_v2(HandlerProc, eventOwner, eventData);
            end

            // Clear current event data
            if freeProc != 0 andAlso eventData != 0 then begin
               call_offset_v1(freeProc, eventData);
            end

            // Free mem of current event
            call_offset_v1(0x4C5C24, queueNode);
         end
         sfall_handler = 0;
         queueNode = nextNodeAddress;
      end
      else begin
         prevNode = queueNode;
         queueNode = read_int(queueNode + eventNextNode_offset);
      end
   end
   set_game_time_no_queue_check(real_game_time);
end


procedure check_critter_events_in_combat(variable critter, variable critter_id, variable critter_in_party, variable real_game_time, variable cur_game_time, variable time_was_skip = 0) begin
   variable PoisonTickDmg;
   variable RegenTickHP;
   variable Full_PoisonTickDmg;
   variable Full_RegenTickHP;
   variable first_event_key;
   variable next_event_key;
   variable event_key;
   variable event_time;
   variable stat;
   variable stat_value;
   variable stat_and_value;
   variable i;
   variable skipped_time;
   variable skip_regen;
   variable skip_poison;
   variable regen_count;
   variable poison_count;
   variable last_critter_regen_time;
   variable last_critter_poison_time;
   variable decay_count;
   variable event_type;
   variable displayed_stat_value;
   variable critter_cur_poison;
   variable critter_cur_hp = get_critter_stat(critter, STAT_current_hp);
   variable critter_cur_hp_at_start;
   variable critter_max_hp;
   variable was_add_regen;
   variable was_add_poison;
   variable next_regen_time;
   variable cur_burn;
   variable creature_died;
   if is_really_dead(critter, critter_state(critter), critter_cur_hp) orElse get_array(death_array, critter) > 0 then
      return;

   critter_cur_poison = get_poison(critter);
   if critter_cur_poison > 0 then
      critter_cur_poison -= get_array(id_to_poison_fraction, critter_id);

   if RegenMod > 0 then begin
      if get_critter_stat(critter, STAT_heal_rate) >= min_hr_to_regen andAlso get_critter_stat(critter, STAT_current_hp) < get_critter_stat(critter, STAT_max_hp) then begin
         next_regen_time = get_array(id_to_regen_time, critter_id);
         if next_regen_time <= 0 then begin
            call queue_add_regen_event(critter_id, last_timed_event_time + regen_repeat_ticks);
         end
         else if next_regen_time <= last_timed_event_time then begin
            next_regen_time = regen_repeat_ticks - (last_timed_event_time - next_regen_time) % regen_repeat_ticks;
            call queue_add_regen_event(critter_id, last_timed_event_time + next_regen_time);
         end
      end
   end
   if PoisonMod > 0 then begin
      if critter_cur_poison > 0 andAlso get_array(id_to_poison_time, critter_id) <= 0 then begin
         call queue_add_poison_event(critter_id, last_timed_event_time + poison_repeat_ticks);
      end
   end

   event_key = get_first_event_key(critter_id);
   if event_key != 0 then begin
      while event_key != 0 do begin
         event_time = get_event_time(event_key);
         if event_time <= cur_game_time then begin
            set_game_time_no_queue_check(event_time);
            was_add_regen = 0;
            was_add_poison = 0;
            event_type = get_array(event_queue_array, event_key + event_type_offset);
            set_array(event_queue_array, event_key + event_type_offset, 0);
            if critter_cur_poison > 0 andAlso event_type == EVENT_TYPE_POISON_CUSTOM then begin
               PoisonTickDmg = calc_poison_dmg(critter, critter_id, critter_cur_poison, 1);
               if PoisonTickDmg > 0 then begin
                  critter_cur_hp -= PoisonTickDmg;
                  Full_PoisonTickDmg += PoisonTickDmg;
                  decay_count++;
                  if critter_cur_hp <= 0 then begin
                     creature_died = 1;
                     call critter_heal_regen_poison(critter, Full_RegenTickHP, Full_PoisonTickDmg, false, adjust_hp_poison);
                     break;
                  end
                  else
                     call critter_heal_regen_poison(critter, 0, PoisonTickDmg, true, true);

                  call queue_add_poison_event(critter_id, event_time + poison_repeat_ticks);
                  critter_cur_poison = decrease_poison(critter, critter_cur_poison, false, 1);
                  PoisonTickDmg = 0;
                  was_add_poison = 1;
               end
            end
            else if event_type == EVENT_TYPE_REGENERATION then begin
               RegenTickHP = get_regen_by_id(critter, critter_id, PoisonTickDmg, critter_cur_hp);
               if RegenTickHP >= 0 then begin
                  critter_cur_hp += RegenTickHP;
                  RegenTickHP = critter_heal_regen_poison(critter, RegenTickHP, 0, true, true);
                  call queue_add_regen_event(critter_id, event_time + regen_repeat_ticks);
                  Full_RegenTickHP += RegenTickHP;
                  was_add_regen = 1;
               end
               RegenTickHP = 0;
            end
            else if event_type == EVENT_TYPE_DRUG_CUSTOM then begin
               stat = get_array(event_queue_array, event_key + stat_offset);
               stat_value = get_array(event_queue_array, event_key + stat_value_offset);
               if critter == dude_obj then begin
                  if stat == STAT_current_hp then begin
                     critter_heal(dude_obj, stat_value);
                  end
                  else
                     set_critter_extra_stat(dude_obj, stat, get_critter_extra_stat(dude_obj, stat) + stat_value);

                  displayed_stat_value = stat_value;
                  set_array(delayed_dude_stats_display, len_array(delayed_dude_stats_display), stat * stat_FLAG_MULT + stat_FLAG_ADD + displayed_stat_value);
               end
               else
                  call add_and_save_stats(critter, critter_id, stat, stat_value, true, true);

               if stat == STAT_heal_rate then begin
                  if RegenMod > 0 andAlso get_critter_stat(critter, STAT_heal_rate) >= min_hr_to_regen andAlso (get_array(id_to_regen_time, critter_id) + regen_repeat_ticks) < event_time then begin
                     call queue_add_regen_event(critter_id, event_time + regen_repeat_ticks);
                     was_add_regen = 1;
                  end
               end
               else if stat == STAT_current_hp then begin
                  critter_cur_hp += stat_value;
               end
            end
            else if event_type == EVENT_TYPE_BURN then begin
               call add_burn_effect_to_saved_arrays(critter, -1);

               stat = get_array(event_queue_array, event_key + stat_offset);
               stat_value = get_array(event_queue_array, event_key + stat_value_offset);
               call add_and_save_stats(critter, critter_id, stat, stat_value, true, true);

               stat = get_array(event_queue_array, event_key + stat2_offset);
               stat_value = get_array(event_queue_array, event_key + stat2_value_offset);
               call add_and_save_stats(critter, critter_id, stat, stat_value, true, true);
            end

            if critter_cur_hp > 0 then
               call queue_original_check_allowed_events_critter(critter, event_time);

            if PoisonMod > 0 andAlso was_add_poison <= 0 then begin
               if get_poison(critter) > 0 andAlso get_array(id_to_poison_time, critter_id) <= 0 then begin
                  call queue_add_poison_event(critter_id, event_time + poison_repeat_ticks);
                  was_add_poison = 1;
               end
            end
            if RegenMod > 0 then begin
               //critter_cur_hp = get_critter_stat(critter, STAT_current_hp);
               critter_max_hp = get_critter_stat(critter, STAT_max_hp);
               if was_add_regen <= 0 andAlso get_critter_stat(critter, STAT_heal_rate) >= min_hr_to_regen andAlso critter_cur_hp < critter_max_hp then begin
                  next_regen_time = get_array(id_to_regen_time, critter_id);
                  if next_regen_time <= 0 then begin
                     call queue_add_regen_event(critter_id, event_time + regen_repeat_ticks);
                     was_add_regen = 1;
                  end
                  else if next_regen_time <= event_time then begin
                     next_regen_time = regen_repeat_ticks - (event_time - next_regen_time) % regen_repeat_ticks;
                     call queue_add_regen_event(critter_id, event_time + next_regen_time);
                     was_add_regen = 1;
                  end
               end
               else if critter_cur_hp >= critter_max_hp then begin
                  cur_burn = get_array(id_to_burn_count, critter_id);
                  if cur_burn > 0 then begin
                     call add_burn_effect_to_saved_arrays(critter, -cur_burn);
                  end
               end
            end

            next_event_key = get_array(event_queue_array, event_key + next_event_key_offset);
            set_first_event_key(critter_id, next_event_key);
            call queue_remove(critter_id, event_key);
            event_key = next_event_key;
         end
         //not yet
         else begin
            event_key = 0;
         end
      end
   end
   if creature_died <= 0 then begin
      call critter_heal_regen_poison(critter, Full_RegenTickHP, Full_PoisonTickDmg, false, false);
      if decay_count > 0 then
         call decrease_poison(critter, 0, true, decay_count);

      if critter == dude_obj andAlso len_array(delayed_dude_stats_display) > 0 then begin
         foreach stat_and_value in delayed_dude_stats_display begin
            stat = stat_and_value / stat_FLAG_MULT;
            stat_value = stat_and_value % stat_FLAG_MULT - stat_FLAG_ADD;
            call dude_apply_and_display_stat(stat, stat_value, true, true, false);
         end
         clear_array(delayed_dude_stats_display);
      end

      if not(is_really_dead(critter, critter_state(critter), critter_cur_hp)) andAlso get_array(death_array, critter) <= 0 then
         call queue_original_check_allowed_events_critter(critter, cur_game_time);

      if RegenMod > 0 then begin
         critter_cur_hp = get_critter_stat(critter, STAT_current_hp);
         critter_max_hp = get_critter_stat(critter, STAT_max_hp);
         if was_add_regen <= 0 andAlso get_critter_stat(critter, STAT_heal_rate) >= min_hr_to_regen andAlso critter_cur_hp < critter_max_hp then begin
            next_regen_time = get_array(id_to_regen_time, critter_id);
            if next_regen_time <= 0 then begin
               call queue_add_regen_event(critter_id, cur_game_time + regen_repeat_ticks);
               was_add_regen = 1;
            end
            else if next_regen_time <= cur_game_time then begin
               next_regen_time = regen_repeat_ticks - (cur_game_time - next_regen_time) % regen_repeat_ticks;
               call queue_add_regen_event(critter_id, cur_game_time + next_regen_time);
               was_add_regen = 1;
            end
         end
         else if critter_cur_hp >= critter_max_hp then begin
            cur_burn = get_array(id_to_burn_count, critter_id);
            if cur_burn > 0 then begin
               call add_burn_effect_to_saved_arrays(critter, -cur_burn);
            end
         end
      end
      if PoisonMod > 0 andAlso was_add_poison <= 0 then begin
         if get_poison(critter) > 0 andAlso get_array(id_to_poison_time, critter_id) <= 0 then begin
            call queue_add_poison_event(critter_id, cur_game_time + poison_repeat_ticks);
         end
      end
   end
   set_game_time_no_queue_check(real_game_time);
end

procedure queueGetNextEventTime_pois_regen begin
   variable queueHeadAddress = 0x6648C0;
   variable queueHead = read_int(queueHeadAddress);
   variable queueNode;
   variable eventTime;
   variable eventType;
   variable nextNodeAddress;
   if queueHead == 0 then
      return 0;

   queueNode = queueHead;
   while (queueNode != 0) do begin
      eventType = read_int(queueNode + eventType_offset);
      if is_event_allowed(eventType) then begin
         eventTime = read_int(queueNode);
         return eventTime;
      end
      else begin
         queueNode = read_int(queueNode + eventNextNode_offset);
      end
   end
   return 0;
end

inline procedure check_events_queue(variable cur_game_time) begin
   variable critter;
   variable cur_critters_array = list_as_array(LIST_CRITTERS);
   variable party_array = party_member_list(0);
   variable len = len_array(cur_critters_array);
   variable next_event_time;
   variable critter_id;
   variable forced;
   variable is_combatant;
   variable check_time;
   variable events;
   variable time_was_skip;
   call restore_saved_stats_party_lvl_up(party_array);
   critter = 0;
   time_was_skip = 0;
   if on_global_map <= 0 then begin
      set_window_flag(WINTYPE_PIPBOY, WIN_FLAG_HIDDEN, 1);
      set_window_flag(WINTYPE_IFACEBAR, WIN_FLAG_HIDDEN, 1);
   end
   if combat_is_initialized then begin
      if combat_end <= 0 andAlso cur_game_time > combat_turn_start_time then begin
         combat_turn_start_time = cur_game_time;
         call queue_original_check_events_all_with_custom_queue(cur_game_time, party_array, cur_critters_array);
         check_time = cur_game_time + 50;
         forced = 1;
      end
      else
         check_time = cur_game_time;

      foreach critter in cur_critters_array begin
         critter_id = check_id(critter);
         is_combatant = get_array(combatants_array, critter_id);
         if not(is_combatant) orElse (forced) then begin
            if not(is_combatant) orElse critter == combat_turn_critter then
               call check_critter_events_in_combat(critter, critter_id, is_in_array(critter, party_array), cur_game_time, cur_game_time);
            else
               call check_critter_events_in_combat(critter, critter_id, is_in_array(critter, party_array), cur_game_time, check_time);
         end
      end
   end
   else begin
      if last_timed_event_time + 1 < cur_game_time then begin
         time_was_skip = 1;
         call queue_original_check_events_all_with_custom_queue(cur_game_time, party_array, cur_critters_array);
         cur_critters_array = list_as_array(LIST_CRITTERS);
      end
      events = 1;
      while events do begin
         events = 0;
         foreach critter in cur_critters_array begin
            if check_events_queue_critter(critter, party_array, cur_game_time, map_enter) then begin
               if (time_was_skip) andAlso map_enter <= 0 then begin
                  events = 1;
                  continue;
               end
            end
         end
         if not(time_was_skip) then
            events = 0;
      end
   end
   if on_global_map <= 0 then begin
      set_window_flag(WINTYPE_PIPBOY, WIN_FLAG_HIDDEN, 0);
      set_window_flag(WINTYPE_IFACEBAR, WIN_FLAG_HIDDEN, 0);
      //if sfall_510 > 0 then begin
         call_offset_v1(0x45EBD8, false); //interfaceRenderHitPoints
         call_offset_v0(0x431A78); //displayMonitorRefresh
      //end
      //else
         //call_offset_v0(0x45EB98);// 0x45EB98
      //tile_refresh_display;
   end
end

procedure RESTTIMER begin
   variable gameticks = get_sfall_arg;
   variable eventtype = get_sfall_arg;
   variable cur_game_time = game_time;
   variable time_diff;
   if eventtype != 0 then begin
      resting = 0;
      time_diff = gameticks - cur_game_time;
      if time_diff > 0 then
         game_time_advance(time_diff);
      if dude_must_die > 0 then begin
         if game_ui_is_disabled andAlso (dude_turn == dude_obj orElse not(combat_is_initialized)) then
            game_ui_enable;
      end
   end
   else begin
      call float_msg_disable;
      resting = 1;
      after_rest_death = 1;
      game_time_resting = gameticks;
      time_diff = gameticks - cur_game_time;
      if time_diff > 0 then
         game_time_advance(time_diff);
   end

   // Hide cursor if not already hidden and event type is 0
   if cursor_is_hidden <= 0 andAlso eventtype == 0 then begin
      cursor_is_hidden = 1;
      set_cursor_hidden;
   end
   else if eventtype != 0 then begin
      cursor_is_hidden = 0;
   end

   if dude_must_die > 0 then begin
      resting = 0;
      after_rest_death = 0;
      if (get_game_mode bwand PIPBOY) then begin
         game_ui_enable;
         tap_key(DIK_ESCAPE);
      end
      set_sfall_return(1);
      return;
   end
end

procedure add_to_tmp_remove_from_cur_map_events(variable event_key) begin
   variable i;
   variable value;
   variable cur_key;
   for (i = 0; i < MAX_event_offset; i++) begin
      cur_key = event_key + i;

      value = get_array(event_queue_array, cur_key);
      if value != 0 then begin
         set_array(tmp_map_exit_event_array, cur_key, value);

         set_array(event_queue_array, cur_key, 0);
      end
   end
end


procedure set_tmp_event_array(variable critter) begin
   variable critter_id;
   variable next_event_key;
   variable event_key;
   variable event_type;
   variable stat;
   variable stat_value;
   variable cur_burn_count;
   critter_id = get_unique_id(critter);
   event_key = get_first_event_key(critter_id);
   if event_key != 0 then begin
      while event_key != 0 do begin
         next_event_key = get_array(event_queue_array, event_key + next_event_key_offset);
         call add_to_tmp_remove_from_cur_map_events(event_key);
         event_key = next_event_key;
      end
   end
end

procedure map_exit_p_proc begin
   variable critter;
   variable critter_id;
   variable party = party_member_list(1);
   variable critters_array = list_as_array(LIST_CRITTERS);
   variable time;
   variable map_is_saveable = call_offset_r0(0x4BFA64);
   if DISABLED <= 0 then begin
      if PoisonMod > 0 then begin
         clear_array(array_add_poison);
         if enemy_perception_disabled > 0 then call perception_enable;
      end

      if len_array(death_array) > 0 then
         call show_death_msg;

      if game_ui_is_disabled then
         game_ui_enable;
   end
   foreach critter in party begin
      critter_id = check_id(critter);
      call set_tmp_event_array(critter);
   end


   foreach critter in critters_array begin
      if is_in_array(critter, party) then
         continue;

      critter_id = get_unique_id(critter);
      if DISABLED <= 0 then
         critter_id = check_id(critter);

      if map_is_saveable <= 0 then begin
         if get_array(id_to_regen_time, critter_id) != 0 then
            set_array(id_to_regen_time, critter_id, 0);
         if get_array(id_to_poison_time, critter_id) != 0 then
            set_array(id_to_poison_time, critter_id, 0);
         if get_array(id_to_poison_fraction, critter_id) != 0 then
            set_array(id_to_poison_fraction, critter_id, 0);
         if get_array(id_to_burn_count, critter_id) != 0 then
            set_array(id_to_burn_count, critter_id, 0);
         call remove_from_saved_stats(critter_id);
         call queue_remove_all(critter_id);
      end
   end

   clear_array(ptr_to_id_array);
end


procedure delayed_add_burn begin
   variable critter;
   variable burn;
   variable burn_count;
   variable burn_amount;
   variable target_num;
   variable dmg;
   if aoe_dmg_type != DMG_fire andAlso aoe_dmg_type != DMG_plasma andAlso aoe_dmg_type != DMG_explosion then
      return;

   if len_array(import_alt_attack_aoe_targets_arr) > 0 then begin
      foreach critter:dmg in import_alt_attack_aoe_targets_arr begin
         if critter <= 0 then begin
            continue;
         end

         if PID_TYPE(obj_pid(critter)) != OBJ_TYPE_CRITTER then begin
            continue;
         end

         if dmg <= 0 orElse is_critter_dead(critter) orElse get_critter_stat(critter, STAT_current_hp) <= 0 then begin
            continue;
         end

         burn_count = calc_burn_count(critter, dmg);
         if burn_count > 0 then begin
            call add_burn_effect_to_saved_arrays(critter, burn_count);
         end
      end
   end
   if len_array(array_add_burn) > 0 then begin
      if combat_data > 0 then begin
         foreach critter:target_num in array_add_burn begin
            if critter <= 0 then begin
               continue;
            end

            if PID_TYPE(obj_pid(critter)) != OBJ_TYPE_CRITTER then begin
               continue;
            end

            if is_critter_dead(critter) orElse get_critter_stat(critter, STAT_current_hp) <= 0 then begin
               continue;
            end

            if target_num < aoe_main_target_num then begin
               dmg = get_object_data(combat_data, (0x6C + 4 * target_num));
            end
            //main target
            else if target_num == aoe_main_target_num then begin
               dmg = get_object_data(combat_data, C_ATTACK_DAMAGE_TARGET);
            end
            else if target_num == aoe_main_attacker_num then begin
               dmg = get_object_data(combat_data, C_ATTACK_DAMAGE_SOURCE);
            end
            burn_count = calc_burn_count(critter, dmg);
            if burn_count > 0 then begin
               call add_burn_effect_to_saved_arrays(critter, burn_count);
            end
         end
      end
      aoe_target_num = 0;
      clear_array(array_add_burn);
   end
end


procedure REAL_COMBATDAMAGE_RSULTS begin
   variable target;
   variable attacker;
   variable dmgtotar;
   variable dmgtoatkr;
   variable flagfortar;
   variable flagforatkr;
   variable weapon;
   variable bullet_count;
   variable atk_type;
   variable attacker_pid;
   variable pyromaniac;
   variable wpnpid;
   variable wpnanim;
   variable wpndmgtype;
   variable poison_mastery;
   variable wpn_name;
   variable wpn_poison;
   variable wpn_poison_perks;
   variable poison_perk_name;
   variable caliber;
   variable has_small_scorp_tail;
   variable has_scorp_tail;
   variable player_level;
   variable tar_kill_type;
   variable atk_kill_type;
   variable party;
   variable attacker_in_party;
   variable poison_to_add;
   variable poison_to_add_attacker;
   if combat_data > 0 then begin

      target = get_object_data(combat_data, C_ATTACK_TARGET);
      if target <= 0 then
         return;
      attacker = get_object_data(combat_data, C_ATTACK_SOURCE);
      dmgtotar = get_object_data(combat_data, C_ATTACK_DAMAGE_TARGET);
      dmgtoatkr = get_object_data(combat_data, C_ATTACK_DAMAGE_SOURCE);
      flagfortar = get_object_data(combat_data, C_ATTACK_FLAGS_TARGET);
      flagforatkr = get_object_data(combat_data, C_ATTACK_FLAGS_SOURCE);
      weapon = get_object_data(combat_data, C_ATTACK_WEAPON);
      bullet_count = get_object_data(combat_data, C_ATTACK_ROUNDS);
      atk_type = get_object_data(combat_data, C_ATTACK_HIT_MODE);

      player_level = get_pc_stat(PCSTAT_level);
      if player_level > 30 then
         player_level = 30;

      party = party_member_list(0);
      attacker_in_party = is_in_array(attacker, party);
      if weapon > 0 then begin
         wpnpid = obj_pid(weapon);
         wpndmgtype = weapon_dmg_type(weapon);
         wpnanim = get_proto_data(wpnpid, PROTO_WP_ANIM);
         caliber = get_proto_data(wpnpid, PROTO_WP_CALIBER);
         wpn_poison = PoisonedWeapons[wpnpid];
         if attacker_in_party then begin
            wpn_name = proto_data(wpnpid, 1);
            pyromaniac = has_trait(TRAIT_PERK, attacker, PERK_pyromaniac_perk);
            poison_mastery = has_fake_perk_npc(attacker, perk_poison_mastery_name);
            poison_perk_name = envenomed_msg + wpn_name;
            wpn_poison_perks = has_fake_perk_npc(attacker, poison_perk_name);
            if wpn_poison <= 0 andAlso wpn_poison_perks > 0 then begin
               wpn_poison = wpn_poison_perks + random(3, 7);
               if random(0, (2 + 5 * poison_mastery)) > 0 then begin
                  set_fake_perk_npc(attacker, poison_perk_name, (wpn_poison_perks - 1), 23, envenomed_description_msg);
                  if wpn_poison_perks <= 1 then
                     call rm_from_poisoned_perk_weapons(wpnpid);
               end
            end
         end
      end
      else begin
         attacker_pid = obj_pid(attacker);
         wpn_poison = PoisonedWeapons[attacker_pid];
         wpndmgtype = get_proto_data(attacker_pid, PROTO_CR_DMG_TYPE);
      end

      tar_kill_type = critter_kill_type(target);
      atk_kill_type = critter_kill_type(attacker);
      if wpn_poison == 0 andAlso dmgtotar > 0 andAlso tar_kill_type != KILL_TYPE_robot_kills then begin
         // all centaurs and floaters and scorps
         if (Fallout_2 <= 0 orElse target != real_dude_obj) andAlso (atk_kill_type == KILL_TYPE_floater_kills or atk_kill_type == KILL_TYPE_centaur_kills or atk_kill_type == KILL_TYPE_radscorpion_kills) andAlso random(0,1) then begin
            if atk_kill_type != KILL_TYPE_radscorpion_kills orElse target != real_dude_obj then
               wpn_poison += random(9, 21);
         end
         // poison atk for plant attacker
         else if atk_kill_type == KILL_TYPE_plant_kills andAlso random(0,2) then begin
            wpn_poison += random(7, 11);
         end
         // needler poison
         else if caliber == CALIBER_HN_NEEDLER andAlso dmgtotar > 0 then begin
            if not(attacker_in_party) orElse poison_mastery > 0 orElse (target != dude_obj andAlso has_skill(attacker,SKILL_SCIENCE) > 70) then
               wpn_poison += 15;
         end
         else begin
            // all non-companion npc attackers who carry radscorp tails
            has_scorp_tail = obj_is_carrying_obj_pid(attacker, PID_SCORPION_TAIL);
            if gPID_SMALL_SCORPION_TAIL > 0 then has_small_scorp_tail = obj_is_carrying_obj_pid(attacker, gPID_SMALL_SCORPION_TAIL);
            if (has_scorp_tail > 0 or has_small_scorp_tail > 0) andAlso not(attacker_in_party) andAlso (wpnanim == WPN_ANIM_KNIFE or wpnanim == WPN_ANIM_SPEAR) andAlso wpndmgtype == DMG_normal_dam then begin
               wpn_poison += random(4, 7) + player_level / 2;
            end
         end
      end

      aoe_poison_count = 0;
      if wpn_poison > 0 then begin
         aoe_poison_count = wpn_poison;
         if dmgtotar > 0 then begin
            poison_to_add += wpn_poison + get_array(array_add_poison, target);
            if poison_mastery > 0 then
               wpn_poison += 5 * poison_mastery;
            //burst poison
            if bullet_count > 1 then
               poison_to_add = random(poison_to_add, poison_to_add * bullet_count);
         end
         if dmgtoatkr > 0 andAlso (wpnanim <= WPN_ANIM_SPEAR or wpnanim == 0x0E or wpnanim == 0x0B or wpnanim == 0x0C) then
            poison_to_add_attacker += wpn_poison + get_array(array_add_poison, target);
      end

      // add burn effect from fire/plasma dmg (reduce healing rate) with delay
      if RegenMod > 0 andAlso (wpndmgtype == DMG_fire orElse wpndmgtype == DMG_plasma orElse wpnpid == PID_MOLOTOV_COCKTAIL) then begin
         aoe_dmg_type = wpndmgtype;
        //burn effect for target
         if target != get_object_data(combat_data, C_ATTACK_TARGET) then begin
            if target == get_object_data(combat_data, (C_ATTACK_TARGET1 + (4 * aoe_target_num))) then begin
               aoe_target_num += 1;
               if aoe_target_num > 6 then begin
                  aoe_target_num = 6;
               end
               set_array(array_add_burn, target, aoe_target_num);
            end
         end
         else if target != attacker then begin
            set_array(array_add_burn, target, aoe_main_target_num);
         end
         else if pyromaniac <= 0 then begin
            set_array(array_add_burn, attacker, aoe_main_attacker_num);
         end
      end

      //add poison with delay
      if ((poison_to_add > 0 andAlso dmgtotar > 0) orElse (poison_to_add_attacker > 0 andAlso dmgtoatkr > 0)) then begin
         if poison_to_add > 0 andAlso dmgtotar > 0 then begin
            if target != dude_obj andAlso is_in_array(target, party) > 0 then begin
               poison_to_add = (combat_diff) * poison_to_add / (1 + combat_diff);
               if poison_to_add <= 0 then poison_to_add = 1;
            end
            set_array(array_add_poison, target, poison_to_add);
         end
         if poison_to_add_attacker > 0 andAlso dmgtoatkr > 0 then begin
            if attacker != dude_obj andAlso is_in_array(attacker, party) > 0 then begin
               poison_to_add_attacker = (combat_diff) * poison_to_add_attacker / (1 + combat_diff);
               if poison_to_add_attacker <= 0 then poison_to_add_attacker = 1;
            end
            set_array(array_add_poison, attacker, poison_to_add_attacker);
         end
      end
   end
   if gOneTimeCall <= 0 andAlso (len_array(array_add_poison) > 0 orElse len_array(array_add_burn) > 0 orElse len_array(import_alt_attack_aoe_targets_arr) > 0) then begin
      gOneTimeCall = 1;
      call delayed_add_poison;
      call delayed_add_burn;
      call clear_imported_arr;
   end
end



procedure REAL_COMBATDAMAGE_add_timer begin
   add_global_timer_event(0, fixed_param_COMBATDAMAGE);
end


procedure disable_anim_priority begin
   if priority_disabled > 0 orElse sfall_510 > 0 then
      return;
   set_anim_priority_disabled;
   priority_disabled = 1;
end

procedure enable_anim_priority begin
   if priority_disabled <= 0 then
      return;
   set_anim_priority_enabled;
   priority_disabled = 0;
end

procedure change_perk_name begin
   variable old_name = modmsg(msg_perk_poison_mastery_name_old);
   variable perk_count;
   perk_count = has_fake_perk(old_name);
   if perk_count then begin
      set_selectable_perk(old_name, 0, 102, perk_poison_mastery_description);
      set_fake_perk(old_name, 0, 102, perk_poison_mastery_description);
      set_fake_perk(perk_poison_mastery_name, perk_count, 102, perk_poison_mastery_description);
      set_pc_stat_max(STAT_poison_resist, 100);
   end
   else if has_fake_perk(perk_poison_mastery_name) then
      set_pc_stat_max(STAT_poison_resist, 100);
end

procedure check_mod_perks(variable party_member) begin
   variable old_perk_name;
   variable weapon_name;
   variable weapon_pid;
   variable weapon_count;
   variable poison_weapon_perk;
   variable perk_name;
   variable poison_mastery;

   if party_member == real_dude_obj then begin
      call change_perk_name;
      if RegenMod < 1 then begin
         regen_perk_description = modmsg(msg_perk_regen_description);
         if has_fake_perk(regen_perk_name) > 0 then
            set_fake_perk(regen_perk_name, 0, 79, regen_perk_description);

      end
      if PoisonMod < 1 then begin
         PoisonAppliedWeapons = load_array("PoisonAppliedWeaponsMMR");
         PoisonableWeapons_rm = create_array_map;


         poison_mastery = has_fake_perk(perk_poison_mastery_name) ;
         if poison_mastery > 0 then begin
            set_fake_perk(perk_poison_mastery_name, 0, 102, perk_poison_mastery_description);
            set_perk_owed(get_perk_owed + poison_mastery);
         end
         set_selectable_perk(perk_poison_mastery_name, 0, 102, perk_poison_mastery_description);
      end
   end
   call rename_old_poisoned_weapons_perks(party_member);
   PoisonAppliedWeapons_len = len_array(PoisonAppliedWeapons);

   if PoisonMod < 1 then begin
      call check_decrease_poisoned_weapon_perk(party_member, -101, 0);
   end
end



procedure timed_event_p_proc begin
   variable timed_event = fixed_param;
   variable dec_value;
   variable critter;
   variable party;
   variable poison_mastery;
   variable call_next;
   variable i;
   variable next_time;
   variable next_timer_time;
   variable cur_game_time;
   if timed_event == fixed_param_all_in_one then begin
      cur_game_time = game_time;
      if on_global_map > 0 then begin
         next_time = queueGetNextEventTime_pois_regen;
         if next_time == 0 then
            next_time = all_in_one_repeat_time_global;
         else
            next_time -= game_time;

         if next_time > all_in_one_repeat_time_global orElse next_time <= 0 then
            next_time = all_in_one_repeat_time_global;

         add_global_timer_event(next_time, fixed_param_all_in_one);
      end
      else
         add_global_timer_event(all_in_one_repeat_time, fixed_param_all_in_one);

      call check_events_queue(cur_game_time);
      if RegenMod > 0 then
         call check_regen_tag;
      last_timed_event_time = cur_game_time;
   end
   else if timed_event == fixed_param_poison_perk_rm then begin
      PoisonableWeapons_timer = 0;
      if PoisonAppliedWeapons_len > 0 then begin
         cur_game_time = game_time;
         poison_mastery = has_fake_perk_npc(real_dude_obj, perk_poison_mastery_name);
         if poison_mastery <= 0 then begin
            if on_global_map <= 0 then begin
               next_time = poisoned_weapon_check_time;
            end
            else begin
               next_time = poisoned_weapon_check_time_WM;
            end
         end
         else begin
            next_time = poisoned_weapon_check_time_perk;
         end

         party = party_member_list(0);
         dec_value = cur_game_time - gPoisonableWeaponsRemoveTimeLast;
         dec_value = round(1.0 * dec_value / next_time);

         if PoisonMod > 0 then begin
            foreach (critter in party) begin
               call check_decrease_poisoned_weapon_perk(critter, dec_value, 1);
            end
         end

         PoisonableWeapons_timer = 1;
         add_global_timer_event(next_time, fixed_param_poison_perk_rm);
         gPoisonableWeaponsRemoveTimeLast = cur_game_time;
      end
   end
   else if timed_event == fixed_param_COMBATDAMAGE_add_timer then begin
      call enable_anim_priority;
      call REAL_COMBATDAMAGE_add_timer when (combat_data > 0 andAlso art_anim(obj_art_fid(get_object_data(combat_data, C_ATTACK_SOURCE))) == gEndAttackAnim andAlso get_object_data(get_object_data(combat_data, C_ATTACK_SOURCE), OBJ_DATA_CUR_FRM) == gEndAttackAnimFrame);
   end
   else if timed_event == fixed_param_COMBATDAMAGE then begin
      call REAL_COMBATDAMAGE_RSULTS;
   end
   else if timed_event == fixed_param_rm_mod then begin
      party = party_member_list(0);
      call check_mod_perks(real_dude_obj);
      foreach critter in party begin
         if critter == real_dude_obj then
            continue;
         call check_mod_perks(critter);
      end
   end
end


inline procedure restore_pid_flag_healing_item begin
   variable item_pid;
   variable flag_ext;
   flag_ext = 0;
   if item_pid > 0 then begin
      flag_ext = get_proto_data(item_pid, PROTO_FLAG_EXT);
      if (flag_ext bwand HEALING_ITEM) == 0 then begin
         set_proto_data(item_pid, PROTO_FLAG_EXT, (flag_ext bwor HEALING_ITEM));
      end
   end
end

inline procedure set_pid_flag_healing_item(variable item_pid) begin
   variable flag_ext;
   flag_ext = 0;
   if item_pid > 0 then begin
      flag_ext = get_proto_data(item_pid, PROTO_FLAG_EXT);
      if (flag_ext bwand HEALING_ITEM) == 0 then begin
         set_proto_data(item_pid, PROTO_FLAG_EXT, (flag_ext bwor HEALING_ITEM));
      end
   end
end

inline procedure unset_pid_flag_healing_item(variable item_pid) begin
   variable flag_ext;
   flag_ext = 0;
   if item_pid > 0 then begin
      flag_ext = get_proto_data(item_pid, PROTO_FLAG_EXT);
      if (flag_ext bwand HEALING_ITEM) != 0 then begin
         set_proto_data(item_pid, PROTO_FLAG_EXT, (flag_ext bwand NOT_HEALING_ITEM));
      end
   end
end

procedure COMBATTURN begin
   variable critter_turn_status = get_sfall_arg;
   variable critter = get_sfall_arg;
   variable party = party_member_list(1);
   variable critter_in_party = is_in_array(critter, party);
   variable critmaxhp = get_critter_stat(critter, STAT_max_hp);
   variable critter_cur_hp = get_critter_stat(critter, STAT_current_hp);
   variable crithr = get_critter_stat(critter, STAT_heal_rate);
   variable tardt = 0;
   variable tardr = 0;
   variable tar_name = obj_name(critter);
   variable critter_pid = obj_pid(critter);
   variable critter_int;
   variable radscrop_tail;
   variable tmp;
   variable rnd;
   variable has_scorp_tail;
   variable has_small_scorp_tail;
   variable has_antidote;
   variable has_super_antidote;
   variable critter_type;
   variable wpn;
   variable wpnname;
   variable rhpoison;
   variable critter_cur_frm;
   variable cur_game_time = game_time;
   variable next_game_time;
   variable dude_hp;
   variable RegenTickHP;
   variable PoisonTickDmg;
   variable next_regen_time;
   variable critter_id;
   variable critter_id_arr_key;
   variable critter_lvl;
   variable i;
   variable critter_stat;
   variable critter_cur_poison;
   tail_used = 0;
   dude_turn = 0;
   combat_end = 0;
   dude_hp = get_critter_stat(real_dude_obj, STAT_current_hp);
   if combat_turn_start_time != cur_game_time then begin
      clear_array(combatants_array);
   end
   combat_turn_start_time = cur_game_time;
   if not(is_really_dead(critter, critter_state(critter), critter_cur_hp)) andAlso get_array(death_array, critter) == 0 then begin

      if critter_turn_status == COMBAT_TURN_START then begin
         critter_id = set_unique_id(critter);
         if critter != real_dude_obj andAlso isPotentialPartyMember(critter) > 0 then begin
            if critter_id > 83535 orElse critter_id < 18000 then
               set_object_data(critter, OBJ_DATA_ID, (critter_pid bwand 0xFFFFFF) + 18000);

            if critter != real_dude_obj then begin
               critter_id = check_id(critter);
               critter_id_arr_key = get_saved_stats_key(critter_id);
               if has_saved_stats(critter_id_arr_key) > 0 then begin
                  critter_lvl = get_npc_level(critter_pid);
                  if critter_lvl < 0 then
                     critter_lvl = 0;
                  if critter_lvl != get_array(party_levels, critter_pid) then begin
                     set_array(party_levels, critter_pid, critter_lvl);
                     for (i = 0; i <= STAT_poison_resist; i++) begin
                        critter_stat = get_array(id_to_saved_stats, (critter_id_arr_key + i));
                        if critter_stat != 0 then begin
                           set_critter_extra_stat(critter, i, (get_critter_extra_stat(critter, i) + critter_stat));
                        end
                     end
                  end
               end
            end
         end


         if critter != dude_obj then begin
            critter_cur_poison = get_poison(critter);
            if critter_cur_poison > 0 then begin
               call modify_antidote_healing_flag(true);
               call modify_super_antidote_healing_flag(true);
               PoisonTickDmg = calc_poison_dmg(critter, critter_id, critter_cur_poison, 1);
            end
         end
         set_array(combatants_array, critter_id, 1);
         combat_turn_critter = critter;
      end

      if Critter == dude_obj then begin
         if critter_turn_status == COMBAT_TURN_START then begin
            call check_regen_tag in 0;
            dude_turn = dude_obj;
            if dude_turn_critter_dies > 0 then begin
               set_global_script_type(3);
               set_global_script_repeat(1);
            end
         end
         else
            call check_regen_tag in 0;
      end
      else begin
         if RegenMod > 0 andAlso critter_cur_hp > 0 andAlso dude_hp > 0 then begin
            if critter_turn_status <= COMBAT_TURN_END then begin
               if npc_overhealed > 0 then begin
                  call npc_max_hr_add_regen_items;
               end
            end
            else begin
               if crithr >= new_max_hr_npc_stop then begin
                  call npc_max_hr_rm_regen_items(critter);
               end
            end
         end
      end

         // uses scorp tail if have target to attack
         if PoisonMod > 0 andAlso critter != dude_obj andAlso critter_turn_status == COMBAT_TURN_START andAlso critter_cur_hp > 0 andAlso get_object_data(critter, OBJ_DATA_WHO_HIT_ME) != 0 andAlso not(is_really_dead(critter, critter_state(critter), critter_cur_hp)) andAlso not(critter_is_crippled(critter)) andAlso not(critter_is_fleeing(critter)) andAlso dude_hp > 0 then begin
            if tail_used <= 0 andAlso combat_med_tool_used <= 0 andAlso combat_direct_controll != 1 then begin
               call critter_try_use_antidote_heal(critter, critter_in_party, 0, PoisonTickDmg, 1);
               tail_used = 1;
            end
            if NPCsUsePoisonTails != 0  andAlso tail_used <= 0 andAlso combat_med_tool_used <= 0 andAlso combat_direct_controll != 1 then begin
               wpn = critter_inven_obj(critter, INVEN_TYPE_RIGHT_HAND);
               critter_type = critter_kill_type(critter);
               if wpn > 0 andAlso can_use_items(critter_type) then begin
                  wpnname = obj_name(wpn);
                  critter_int = get_critter_stat(critter, STAT_iq);
                  critter_cur_frm = get_object_data(critter, OBJ_DATA_CUR_FRM);
                  // enemy npc radscorpion tail if not crippled and not fleeing
                  if not(critter_in_party) andAlso critter_cur_frm == 0 andAlso not(critter_is_fleeing(critter)) andAlso (weapon_is_poisonable(wpn, false)) then begin
                     has_scorp_tail = obj_is_carrying_obj_pid(Critter, PID_SCORPION_TAIL);
                     if gPID_SMALL_SCORPION_TAIL > 0 andAlso get_proto_data (gPID_SMALL_SCORPION_TAIL, PROTO_IT_INV_FID) == 117440914 then
                        has_small_scorp_tail = obj_is_carrying_obj_pid(Critter, gPID_SMALL_SCORPION_TAIL);
                     if has_scorp_tail >= 2 then begin
                        tail_used = 1;
                        radscrop_tail = obj_carrying_pid_obj(critter, PID_SCORPION_TAIL);
                        call reg_anim_magic_hands_middle_combat(critter);
                        display_msg(parse_str_2(modmsg(msg_pois_appl_npc), tar_name,obj_name(wpn)));
                        tmp = rm_mult_objs_from_inven(critter, radscrop_tail, has_scorp_tail - 1);
                        destroy_object(radscrop_tail);
                     end
                     if has_small_scorp_tail >= 2 andAlso has_scorp_tail <= 0 then begin
                        tail_used = 1;
                        radscrop_tail = obj_carrying_pid_obj(critter, gPID_SMALL_SCORPION_TAIL);
                        call reg_anim_magic_hands_middle_combat(critter);
                        display_msg(parse_str_2(modmsg(msg_pois_appl_npc), tar_name,obj_name(wpn)));
                        tmp = rm_mult_objs_from_inven(critter, radscrop_tail, has_small_scorp_tail - 1);
                        destroy_object(radscrop_tail);
                     end
                  end
                   // companion npc use radscorpion tail if not crippled and not fleeing
                  else if NPCsUsePoisonTails >= 2 andAlso critter_in_party andAlso (combat_direct_controll != 1 andAlso combat_direct_controll != 2) andAlso critter_cur_frm == 0 andAlso (weapon_is_poisonable(wpn, false)) then begin
                     rhpoison = has_fake_perk_npc(Critter, (envenomed_msg + wpnname));
                     has_scorp_tail = obj_is_carrying_obj_pid(Critter, PID_SCORPION_TAIL);
                     if gPID_SMALL_SCORPION_TAIL > 0 andAlso get_proto_data (gPID_SMALL_SCORPION_TAIL, PROTO_IT_INV_FID) == 117440914 then
                        has_small_scorp_tail = obj_is_carrying_obj_pid(Critter, gPID_SMALL_SCORPION_TAIL);
                     rnd = random (0, 100);
                     if has_scorp_tail > 0 andAlso has_small_scorp_tail < 1 andAlso rnd - (30 - critter_int * 3) * 4 > rhpoison * 14 then begin
                        tail_used = 1;
                        radscrop_tail = obj_carrying_pid_obj(critter, PID_SCORPION_TAIL);
                        call reg_anim_magic_hands_middle_combat(critter);
                        set_self(critter);
                        set_self(critter);
                        use_obj_on_obj(radscrop_tail, critter);
                        set_self(0);
                     end
                     if has_small_scorp_tail > 0 andAlso rnd - (30 - critter_int * 3) * 4 > rhpoison * 14 then begin
                        tail_used = 1;
                        radscrop_tail = obj_carrying_pid_obj(critter, gPID_SMALL_SCORPION_TAIL);
                        call reg_anim_magic_hands_middle_combat(critter);
                        set_self(critter);
                        set_self(critter);
                        use_obj_on_obj(radscrop_tail, critter);
                        set_self(0);
                     end
                  end
               end
            end
         end

      if (critter_turn_status == COMBAT_TURN_END orElse (critter_turn_status <= COMBAT_END_ABRUPT andAlso Critter == dude_obj andAlso Critter != real_dude_obj)) andAlso get_array(death_array, critter) <= 0 then begin
         combat_end = 1;
         critter_id = get_unique_id(critter);
         next_game_time = combat_turn_start_time + 50;
         call check_critter_events_in_combat(critter, critter_id, critter_in_party, cur_game_time, next_game_time);
      end
   end
   if critter_turn_status <= COMBAT_TURN_END andAlso dude_hp > 0 then begin
      if critter == dude_obj then
         call restore_saved_stats_party_lvl_up(party_member_list(1));

      //if critter_turn_status == COMBAT_END_NORMAL then begin
         //next_game_time = 10;
         //if next_game_time > lowest_timer / 3 then
            //next_game_time = lowest_timer / 3;
//
         //remove_timer_event(fixed_param_all_in_one);
         //add_global_timer_event(51 + next_game_time, fixed_param_all_in_one);
      //end
      if dude_turn_critter_dies > 0 then begin
         set_global_script_type(3);
         set_global_script_repeat(1);
      end

      call modify_antidote_healing_flag(false);
      call modify_super_antidote_healing_flag(false);
   end
   if dude_hp > 0 andAlso critter_turn_status <= COMBAT_END_ABRUPT andAlso (get_poison(real_dude_obj) > 0 orElse get_critter_stat(real_dude_obj, STAT_heal_rate) >= min_hr_to_regen) then begin
      float_msg(real_dude_obj, "", FLOAT_MSG_NORMAL);
   end
   if dude_must_die == real_dude_obj then begin
      set_sfall_return(-1);
      return;
   end
end

procedure ADJUSTPOISON begin
   variable critter = get_sfall_arg;
   variable original_poison_add;
   variable poison_amount;
   variable actual_poison_amount;
   variable critter_id = check_id(critter);
   variable critter_cur_hp;
   variable critter_poison;
   variable critter_poison_resist;
   variable kill_type;
   variable party;
   variable critter_in_party;
   variable poison_overdose_amount;
   variable amount_was_ret;
   variable cur_poison_end_count;
   variable game_mode;
   variable cur_game_time;
   variable next_poison_tick;
   if Critter <= 0 then
      return;

   critter_cur_hp = get_critter_stat(critter, STAT_current_hp);
   kill_type = critter_kill_type(critter);
   // prevent robots and corpses from being poisoned
   if kill_type == KILL_TYPE_robot_kills orElse is_really_dead(critter, critter_state(critter), critter_cur_hp) orElse get_array(death_array,critter) > 0 then begin
      set_sfall_return(0);
      set_sfall_arg(1, 0);
      amount_was_ret = 1;
      actual_poison_amount = 0;
      if sfall_508 > 0 then begin
         set_sfall_return(0);
         set_sfall_arg(2, 0);
         set_sfall_return(0);
      end
      if get_array(id_to_poison_time, critter_id) != 0 then
         set_array(id_to_poison_time, critter_id, 0);

      if get_array(id_to_poison_fraction, critter_id) != 0 then
         set_array(id_to_poison_fraction, critter_id, 0);

      return;
   end
   original_poison_add = get_sfall_arg;
   critter_poison_resist = get_critter_stat(critter, STAT_poison_resist);
   critter_poison = get_poison_float(critter, critter_id);
   party = party_member_list(0);
   critter_in_party = is_in_array(critter, party);

   if original_poison_add > 0 then begin
      poison_amount = original_poison_add - (original_poison_add * critter_poison_resist / 100);
   end
   else begin
      poison_amount = original_poison_add;
   end
   actual_poison_amount = poison_amount;
   poison_overdose_amount = calc_poison_overdose(critter);

   // Sfall 4 Display message 'You have been poisoned!' when adding > 0 poison (original message is disabled)
   if sfall_ver_maj < 5 andAlso Critter == dude_obj andAlso original_poison_add > 0 then begin
      display_msg(message_str_game(GAME_MSG_MISC, 3000));
   end

   if (critter_in_party) then begin
      if poison_amount > 0 orElse (sfall_508 > 0) then begin
         //Preventing death from sudden poisoning by huge amounts of poison
         if poison_amount >= poison_overdose_amount then begin
            poison_amount = poison_overdose_amount - 1;

            if poison_amount <= 0 then poison_amount = 1;
            set_sfall_return(poison_amount);
            set_sfall_arg(1, poison_amount);
            actual_poison_amount = poison_amount - (poison_amount * critter_poison_resist / 100);
            amount_was_ret = 1;
         end
         else if critter != dude_obj then begin
            poison_amount = (combat_diff) * poison_amount / (1 + combat_diff);
            if poison_amount <= 0 then poison_amount = 1;
            set_sfall_return(poison_amount);
            set_sfall_arg(1, poison_amount);
            actual_poison_amount = poison_amount - (poison_amount * critter_poison_resist / 100);
            amount_was_ret = 1;
         end
         if sfall_508 > 0 then begin
            if amount_was_ret <= 0 then begin
               set_sfall_return(original_poison_add);
               set_sfall_arg(1, original_poison_add);
            end
            set_sfall_return(0);
            set_sfall_arg(2, 0);
            set_sfall_return(0);//cancel add to que
         end
      end
   end
   cur_poison_end_count = critter_poison + actual_poison_amount;

   if cur_poison_end_count < 0 then
      cur_poison_end_count = 0;

   // add to poisoned critters array;
   if cur_poison_end_count > 0 then begin
      next_poison_tick = get_array(id_to_poison_time, critter_id);
      if next_poison_tick <= 0 then begin
            cur_game_time = game_time;

         if next_poison_tick < cur_game_time then begin
            next_poison_tick = cur_game_time + poison_repeat_ticks;
            if combat_is_initialized andAlso critter != combat_turn_critter andAlso get_array(combatants_array, critter_id) > 0 then
               next_poison_tick += 50;
            call queue_add_poison_event(critter_id, next_poison_tick);
         end
      end
   end
   // rm from poisoned critters array;
   else begin
      set_array(id_to_poison_time, critter_id, 0);
      if get_array(id_to_poison_fraction, critter_id) != 0 then
         set_array(id_to_poison_fraction, critter_id, 0);
   end


   if critter_cur_hp > 0 andAlso cur_poison_end_count >= poison_overdose_amount then begin
      combat_delete_critter(critter);
      poison_overdose_amount = ((get_critter_stat(critter, STAT_max_hp) + get_critter_stat(critter, STAT_max_hp)) * 3);
      if critter == real_dude_obj then begin
         display_msg(modmsg(msg_player_reach_poison_lethal_value));
      end
      else begin
         if combat_is_initialized then
            float_msg(critter, "-" + poison_overdose_amount, FLOAT_MSG_LIGHT_RED);

         display_msg(parse_str_2(modmsg(msg_npc_reach_poison_lethal_value), obj_name(critter), 0));
      end
      call critter_inflict_poison_dmg(critter, poison_overdose_amount, true);
   end
end

procedure map_enter_p_proc begin
   variable critter;
   variable critter_id;
   variable critter_id_arr_key;
   variable critter_cur_hp;
   variable critter_outdoorsman;
   variable critter_type;
   variable critter_stat;
   variable critter_pid;
   variable rnd;
   variable has_scorp_tail;
   variable has_small_scorp_tail;
   variable has_antidote;
   variable wpn;
   variable has_stim;
   variable invenArr;
   variable count;
   variable i;
   variable item;
   variable new_wpn;
   variable party;
   variable critter_in_party;
   variable ecco_dragon_skin_poison;
   variable cur_game_time;
   variable critters_array = list_as_array(LIST_CRITTERS);
   variable cur_map;
   variable cur_map_event_array_name;
   variable cur_map_saved_stats_array_name;
   if on_global_map > 0 then begin
      call merge_event_arrays_after_global;
   end
   map_enter = 1;
   cur_map = cur_map_index;
   cur_map_saved_stats_array_name = saved_stats_array_name + cur_map;
   id_to_saved_stats = load_array(cur_map_saved_stats_array_name);
   if not(array_exists(id_to_saved_stats)) then begin
      id_to_saved_stats = create_array_map;
      save_array(cur_map_saved_stats_array_name, id_to_saved_stats);
   end

   cur_map_event_array_name = event_queue_array_name + cur_map;
   event_queue_array = load_array(cur_map_event_array_name);
   if not(array_exists(event_queue_array)) then begin
      event_queue_array = create_array_map;
      save_array(cur_map_event_array_name, event_queue_array);
   end
   call merge_event_arrays;


   if DISABLED <= 0 then begin
      cur_game_time = game_time;
      party = party_member_list(1);
      if PoisonMod > 0 then begin
         if game_ui_is_disabled andAlso (dude_turn == dude_obj orElse not(combat_is_initialized)) then
            game_ui_enable;

         if party_member_remove > 0 then begin
            foreach critter in party begin
               if is_in_array(get_unique_id(critter),party_member_remove_arr) then begin
                  kill_critter(critter, get_object_data(critter, OBJ_DATA_CUR_FRM));
               end
            end
            clear_array(party_member_remove_arr);
            party_member_remove = 0;
         end
         //add radscorpion tail to npc at first map loading
         if ((PoisonMod > 0 andAlso NPCsUsePoisonTails > 0) or RegenMod > 0) andAlso cur_game_time > ONE_GAME_DAY * 14 andAlso (metarule(METARULE_TEST_FIRSTRUN,0) or days_since_visited > 40) then begin
            //party = party_member_list(0);
            foreach (critter in critters_array) begin
                  critter_in_party = is_in_array(critter, party);
                  critter_cur_hp = get_critter_stat(critter, STAT_current_hp );
                  critter_pid = obj_pid(critter);
                  //critter_body_type = get_proto_data(critter_pid, PROTO_CR_BODY_TYPE);
                  critter_type = critter_kill_type(critter);
               if obj_is_visible_flag(critter) andAlso not(is_really_dead(critter, critter_state(critter), critter_cur_hp)) andAlso critter != real_dude_obj andAlso not(critter_in_party) andAlso critter_type != KILL_TYPE_robot_kills andAlso can_use_items(critter_type) then begin
                  has_stim = obj_is_carrying_obj_pid(Critter, PID_STIMPAK);
                  if RegenMod > 0  andAlso has_stim <= 0 then begin
                     rnd = random(0, 1000);
                     if (rnd < critter_cur_hp - 50) orElse (military_fid(critter) andAlso rnd < 75) then begin
                        if Sonora <= 0 andAlso military_fid(critter) then begin
                           add_mult_objs_to_inven(critter, create_object_sid(PID_STIMPAK, 0, 0, -1), random(1,2));
                           add_mult_objs_to_inven(critter, create_object_sid(PID_PLASMA_GRENADE, 0, 0, -1), random(0,2));
                        end
                        else begin
                           add_mult_objs_to_inven(critter, create_object_sid(PID_STIMPAK, 0, 0, -1), 1);
                        end
                        if critter_pid == PID_END_BOSS then begin
                           add_mult_objs_to_inven(critter, create_object_sid(PID_STIMPAK, 0, 0, -1), 1);
                           add_mult_objs_to_inven(critter, create_object_sid(PID_PLASMA_GRENADE, 0, 0, -1), 7);
                           add_mult_objs_to_inven(critter, create_object_sid(PID_MICRO_FUSION_CELL, 0, 0, -1), 2);
                           add_mult_objs_to_inven(critter, create_object_sid(PID_PSYCHO, 0, 0, -1), 1);
                        end
                     end
                  end
                  //if cur_game_time > ONE_GAME_DAY * 19 then begin
                     if PoisonMod > 0 then
                        has_antidote = obj_is_carrying_obj_pid(Critter, PID_ANTIDOTE);
                     if PoisonMod > 0 andAlso has_antidote <= 0 then begin
                        rnd = random(0,120);
                        if rnd < 1 then begin
                           add_mult_objs_to_inven(critter, create_object_sid(PID_ANTIDOTE, 0, 0, -1), random(1,3));
                        end
                     end
                  //end
                  has_scorp_tail = obj_is_carrying_obj_pid(Critter, PID_SCORPION_TAIL);
                  if gPID_SMALL_SCORPION_TAIL > 0 andAlso get_proto_data (gPID_SMALL_SCORPION_TAIL, PROTO_IT_INV_FID) == 117440914 then has_small_scorp_tail = obj_is_carrying_obj_pid(Critter, gPID_SMALL_SCORPION_TAIL);
                  item = critter_inven_obj2(critter, INVEN_TYPE_RIGHT_HAND);
                  new_wpn = 1;
                  //if the weapon is not equipped, try to find it in the inventory
                  if weapon_is_poisonable(item, false) then begin
                     wpn = item;
                  end
                  else begin
                     count = inven_count(critter);
                     invenArr = temp_array_list(count);
                     for (i = 0; i < count; i++) begin
                        invenArr[i] = inven_ptr(critter, i);
                     end
                     foreach (item in invenArr) begin
                        if obj_item_subtype(item) == item_type_weapon then begin
                           //wpnpid = obj_pid(item);
                           if weapon_is_poisonable(item, false) then begin
                              wpn = item;
                              new_wpn = 3;
                              break;
                           end
                        end
                     end
                  end
                   // add npc radscorpion tail
                  if wpn > 0 andAlso NPCsUsePoisonTails > 0 andAlso has_scorp_tail <= 1 andAlso has_small_scorp_tail <= 1 then begin
                     critter_outdoorsman = has_skill(critter, SKILL_OUTDOORSMAN);
                     if critter_outdoorsman < 40 then critter_outdoorsman = 40;
                     if new_wpn <= 0 then new_wpn = 1;
                     critter_outdoorsman = critter_outdoorsman / new_wpn;
                     rnd = random(0, 80);
                     if rnd <= critter_outdoorsman then begin
                        if Sonora <= 0 andAlso gPID_SMALL_SCORPION_TAIL > 0 andAlso get_proto_data(gPID_SMALL_SCORPION_TAIL, PROTO_IT_INV_FID) == 117440914 andAlso has_small_scorp_tail >= has_scorp_tail then begin
                           add_mult_objs_to_inven(critter, create_object_sid(gPID_SMALL_SCORPION_TAIL, 0, 0, -1), random(2,3) - has_small_scorp_tail);
                        end
                        if (gPID_SMALL_SCORPION_TAIL > 0 andAlso get_proto_data(gPID_SMALL_SCORPION_TAIL, PROTO_IT_INV_FID) != 117440914) or has_small_scorp_tail < has_scorp_tail then begin
                           add_mult_objs_to_inven(critter, create_object_sid(PID_SCORPION_TAIL, 0, 0, -1), random(2,3) - has_scorp_tail);
                        end
                     end
                  end
               end
            end
         end
      end

      call set_drugs_proto;
      //clear_array(id_to_ptr_array);
      foreach critter in critters_array begin
         critter_cur_hp = get_critter_stat(critter, STAT_current_hp);
         if critter == real_dude_obj orElse is_really_dead(critter, critter_state(critter), critter_cur_hp) orElse get_array(death_array, critter) > 0 then begin
            continue;
         end

          //skip party critters
         if isPotentialPartyMember(critter) > 0 then begin
            critter_id = get_unique_id(critter);
            if critter_id > 83535 orElse critter_id < 18000 then begin
               critter_id = (obj_pid(critter) bwand 0xFFFFFF) + 18000;
               set_object_data(critter, OBJ_DATA_ID, critter_id);
            end
            set_array(ptr_to_id_array, critter, critter_id);
            continue;
         end
         else
            critter_id = set_unique_id(critter);

         set_array(ptr_to_id_array, critter, critter_id);
         if sfall_510 > 0 orElse sfall_508 > 0 then
            continue;

         critter_id_arr_key = get_saved_stats_key(critter_id);
         if has_saved_stats(critter_id_arr_key) > 0 then begin
            for (i = 0; i <= STAT_poison_resist; i++) begin
               critter_stat = get_array(id_to_saved_stats, (critter_id_arr_key + i));
               if critter_stat != 0 then begin
                  set_critter_extra_stat(critter, i, (get_critter_extra_stat(critter, i) + critter_stat));
               end
            end
         end
      end
      if not(combat_is_initialized) then
         call check_events_queue(cur_game_time);
   end
   else begin
      foreach critter in critters_array begin
         call disabled_scr_events_queue_critter(critter);
      end
   end

   map_enter = 0;
end

procedure get_new_drug_description(variable drug_pid) begin
   variable new_item_description = (" "+Sonora_drug_desc_separator);
   variable i;
   variable stat;
   variable stat_name;
   variable stat_value;
   variable rnd_value = 39910162;
   variable sign;
   variable was_add;

   for (i := 0; i <= 2; i++) begin
      stat = get_proto_data(drug_pid, PROTO_DR_STAT_A + (4 * i));
      if stat == -1 then
         continue;
      else if stat == -2 then begin
         rnd_value = get_proto_data(drug_pid, PROTO_DR_AMOUNT_1_A + (4 * i));
      end
      else begin
         stat_value = get_proto_data(drug_pid, PROTO_DR_AMOUNT_1_A + (4 * i));
         if stat_value > 0 then
            sign = "+";
         else if stat_value < 0 then
            sign = "";
         else if rnd_value == 39910162 then
            continue;

         if rnd_value != 39910162 then begin
            if stat_value == 0 then begin
               if rnd_value > 0 then
                  sign = "+";
               else if rnd_value < 0 then
                   sign = "";
               else
                  continue;
            end
            stat_value = "("+rnd_value+"-"+stat_value+")";
            rnd_value = 39910162;
         end


         stat_value = sign + stat_value;

         stat_name = message_str_game(GAME_MSG_STAT, 100 + stat);
         if was_add > 0 then
            new_item_description += ",";
         new_item_description += " "+stat_value + " " + stat_name;
         was_add = 1;
      end
   end

   return new_item_description +".";
end

procedure DESCRIPTIONOBJ begin
   variable obj = get_sfall_arg;
   variable objPid;
   variable item_description;
   variable burn_count;
   //if obj_type(obj) == OBJ_TYPE_CRITTER then begin
      //burn_count = get_array(id_to_burn_count, get_unique_id(obj));
      //if burn_count > 0 then begin
         //if burn_count > 100 then begin
            //set_sfall_return("6");
         //end
         //else if burn_count > 80 then begin
            //set_sfall_return("5");
         //end
         //else if burn_count > 60 then begin
            //set_sfall_return("4");
         //end
         //else if burn_count > 60 then begin
            //set_sfall_return("3");
         //end
         //else if burn_count > 20 then begin
            //set_sfall_return("2");
         //end
         //else begin
            //set_sfall_return("1");
         //end
      //end
   //end
   if (obj_item_subtype(obj) != item_type_drug) then begin
      objPid = obj_pid(obj);
      item_description = proto_data(objPid, it_description);
      item_description = get_array(string_split(item_description, Sonora_drug_desc_separator), 0);
      //set_sfall_return(item_description + get_new_drug_description(objPid));
      set_sfall_return(item_description);
   end
end

procedure AFTERHITROLL begin
   variable attacker = get_sfall_arg_at(1);
   variable target = get_sfall_arg_at(2);
   variable weapon = get_object_data(combat_data, C_ATTACK_WEAPON);
   variable attack_type = get_object_data(combat_data, C_ATTACK_HIT_MODE);
   variable attack_anim_last = get_attack_anim_last(attacker, target, weapon, attack_type);
   gOneTimeCall = 0;
   //gCombatDamagePoison = 0;

   call disable_anim_priority;
   gEndAttackAnim = attack_anim_last;
   add_global_timer_event(0, fixed_param_COMBATDAMAGE_add_timer);
end

procedure COMBATDAMAGE begin
   variable target;
   variable attacker;
   variable dmgtotar;
   variable dmgtoatkr;
   variable flagfortar;
   variable flagforatkr;
   variable weapon;
   variable bullet_count;
   variable atk_type;
   variable attacker_pid;
   variable pyromaniac;
   variable wpnpid;
   variable wpnanim;
   variable wpndmgtype;
   variable poison_mastery;
   variable wpn_name;
   variable wpn_poison;
   variable wpn_poison_perks;
   variable poison_perk_name;
   variable caliber;
   variable has_small_scorp_tail;
   variable has_scorp_tail;
   variable player_level;
   variable tar_kill_type;
   variable atk_kill_type;
   variable party;
   variable attacker_in_party;
   variable poison_to_add;
   variable poison_to_add_attacker;
   variable actual_target = get_object_data(combat_data, C_ATTACK_TARGET);
   variable actual_attack;
   if ((attacker != dude_obj andAlso actual_target > 0) orElse (attacker == dude_obj)) then begin
      //gCombatDamagePoison = 1;
      actual_attack = 1;
      target = get_sfall_arg;
      attacker = get_sfall_arg;
      dmgtotar = get_sfall_arg;
      dmgtoatkr = get_sfall_arg;
      flagfortar = get_sfall_arg;
      flagforatkr = get_sfall_arg;
      weapon = get_sfall_arg;
      bullet_count = get_sfall_arg_at(9);
      atk_type = get_sfall_arg_at(11);
   end
   if actual_attack > 0 then begin
      player_level = get_pc_stat(PCSTAT_level);
      if player_level > 30 then
         player_level = 30;

      party = party_member_list(0);
      attacker_in_party = is_in_array(attacker, party);
      if weapon > 0 then begin
         wpnpid = obj_pid(weapon);
         wpndmgtype = weapon_dmg_type(weapon);
         wpnanim = get_proto_data(wpnpid, PROTO_WP_ANIM);
         caliber = get_proto_data(wpnpid, PROTO_WP_CALIBER);
         wpn_poison = PoisonedWeapons[wpnpid];
         if attacker_in_party then begin
            wpn_name = proto_data(wpnpid, 1);
            pyromaniac = has_trait(TRAIT_PERK, attacker, PERK_pyromaniac_perk);
            poison_mastery = has_fake_perk_npc(attacker, perk_poison_mastery_name);
            poison_perk_name = envenomed_msg + wpn_name;
            wpn_poison_perks = has_fake_perk_npc(attacker, poison_perk_name);
            if wpn_poison <= 0 andAlso wpn_poison_perks > 0 then begin
               wpn_poison = wpn_poison_perks + random(3, 7);
               if random(0, (2 + 5 * poison_mastery)) > 0 then begin
                  set_fake_perk_npc(attacker, poison_perk_name, (wpn_poison_perks - 1), 23, envenomed_description_msg);
                  if wpn_poison_perks <= 1 then
                     call rm_from_poisoned_perk_weapons(wpnpid);
               end
            end
         end
      end
      else begin
         attacker_pid = obj_pid(attacker);
         wpn_poison = PoisonedWeapons[attacker_pid];
         wpndmgtype = get_proto_data(attacker_pid, PROTO_CR_DMG_TYPE);
      end

      tar_kill_type = critter_kill_type(target);
      atk_kill_type = critter_kill_type(attacker);
      if wpn_poison == 0 andAlso dmgtotar > 0 andAlso tar_kill_type != KILL_TYPE_robot_kills then begin
         // all centaurs and floaters and scorps
         if (Fallout_2 <= 0 orElse target != real_dude_obj) andAlso (atk_kill_type == KILL_TYPE_floater_kills or atk_kill_type == KILL_TYPE_centaur_kills or atk_kill_type == KILL_TYPE_radscorpion_kills) andAlso random(0,1) then begin
            if atk_kill_type != KILL_TYPE_radscorpion_kills orElse target != real_dude_obj then
               wpn_poison += random(9, 21);
         end
         // poison atk for plant attacker
         else if atk_kill_type == KILL_TYPE_plant_kills andAlso random(0,2) then begin
            wpn_poison += random(7, 11);
         end
         // needler poison
         else if caliber == CALIBER_HN_NEEDLER andAlso dmgtotar > 0 then begin
            if not(attacker_in_party) orElse poison_mastery > 0 orElse (target != dude_obj andAlso has_skill(attacker,SKILL_SCIENCE) > 70) then
               wpn_poison += 15;
         end
         else begin
            // all non-companion npc attackers who carry radscorp tails
            has_scorp_tail = obj_is_carrying_obj_pid(attacker, PID_SCORPION_TAIL);
            if gPID_SMALL_SCORPION_TAIL > 0 then has_small_scorp_tail = obj_is_carrying_obj_pid(attacker, gPID_SMALL_SCORPION_TAIL);
            if (has_scorp_tail > 0 or has_small_scorp_tail > 0) andAlso not(attacker_in_party) andAlso (wpnanim == WPN_ANIM_KNIFE or wpnanim == WPN_ANIM_SPEAR) andAlso wpndmgtype == DMG_normal_dam then begin
               wpn_poison += random(4, 7) + random(1, player_level / 2 + 1);
            end
         end
      end

      aoe_poison_count = 0;
      if wpn_poison > 0 then begin
         aoe_poison_count = wpn_poison;
         if dmgtotar > 0 then begin
            poison_to_add += wpn_poison + get_array(array_add_poison, target);
            if poison_mastery > 0 then
               wpn_poison += 5 * poison_mastery;
            //burst poison
            if bullet_count > 1 then
               poison_to_add = random(poison_to_add, poison_to_add * bullet_count);
         end
         if dmgtoatkr > 0 andAlso (wpnanim <= WPN_ANIM_SPEAR or wpnanim == 0x0E or wpnanim == 0x0B or wpnanim == 0x0C) then
            poison_to_add_attacker += wpn_poison + get_array(array_add_poison, target);
      end

      // add burn effect from fire/plasma dmg (reduce healing rate) with delay
      if RegenMod > 0 andAlso (wpndmgtype == DMG_fire orElse wpndmgtype == DMG_plasma orElse wpnpid == PID_MOLOTOV_COCKTAIL) then begin
         aoe_dmg_type = wpndmgtype;
        //burn effect for target
         if target != get_object_data(combat_data, C_ATTACK_TARGET) then begin
            if target == get_object_data(combat_data, (C_ATTACK_TARGET1 + (4 * aoe_target_num))) then begin
               aoe_target_num += 1;
               if aoe_target_num > 6 then begin
                  aoe_target_num = 6;
               end
               set_array(array_add_burn, target, aoe_target_num);
            end
         end
         else if target != attacker then begin
            set_array(array_add_burn, target, aoe_main_target_num);
         end
         else if pyromaniac <= 0 then begin
            set_array(array_add_burn, attacker, aoe_main_attacker_num);
         end
      end

      //add poison with delay
      if ((poison_to_add > 0 andAlso dmgtotar > 0) orElse (poison_to_add_attacker > 0 andAlso dmgtoatkr > 0)) then begin
         if poison_to_add > 0 andAlso dmgtotar > 0 then begin
            if target != dude_obj andAlso is_in_array(target, party) > 0 then begin
               poison_to_add = (combat_diff) * poison_to_add / (1 + combat_diff);
               if poison_to_add <= 0 then poison_to_add = 1;
            end
            set_array(array_add_poison, target, poison_to_add);
         end
         if poison_to_add_attacker > 0 andAlso dmgtoatkr > 0 then begin
            if attacker != dude_obj andAlso is_in_array(attacker, party) > 0 then begin
               poison_to_add_attacker = (combat_diff) * poison_to_add_attacker / (1 + combat_diff);
               if poison_to_add_attacker <= 0 then poison_to_add_attacker = 1;
            end
            set_array(array_add_poison, attacker, poison_to_add_attacker);
         end
         //poison overdose death
         //if dmgtotar > 0 andAlso poison_to_add > 0 andAlso (flagfortar bwand (DAM_DEAD)) == 0 andAlso get_critter_stat(target, STAT_current_hp) > dmgtotar then begin
            //if (get_poison_float(target, get_unique_id(target)) + (poison_to_add - ((poison_to_add * get_critter_stat(target,STAT_poison_resist)) / 100)) >= calc_poison_overdose(target)) then begin
               //flagfortar = DAM_KNOCKED_OUT bwor DAM_DEAD;
               //flagforatkr = DAM_HIT;
               //if target == dude_obj then begin
                  //dmgtotar = 1 + get_critter_stat(dude_obj, STAT_max_hp);
               //end
               //set_sfall_return(dmgtotar);
               //set_sfall_arg(2, dmgtotar);
               //set_sfall_return(dmgtoatkr);
               //set_sfall_arg(3, dmgtoatkr);
               //set_sfall_return(flagfortar);
               //set_sfall_arg(4, flagfortar);
               //set_sfall_return(flagforatkr);
               //set_sfall_arg(5, flagforatkr);
            //end
         //end
      end
   end
end

procedure get_config_set_float(variable ini_path, variable default_value) begin
   variable cur_value;
   cur_value = get_ini_string(ini_path);
   if (cur_value == "") then
      return default_value;
   else begin
      if cur_value == "0" orElse cur_value == "0.0" then
         return 0;
      else
         return atof(cur_value);
   end
end

procedure get_config_set_int(variable ini_path, variable default_value) begin
   variable cur_value;
   cur_value = get_ini_string(ini_path);
   if (cur_value == "") then
      return default_value;
   else begin
      if cur_value == "0" orElse cur_value == "0.0" then
         return 0;
      else
         return atoi(cur_value);
   end
end

procedure set_pois_wpn begin
   variable Poisoned_Weapon_arr_1;
   variable Poisoned_Weapon_arr_2;
   variable Poisoned_Weapon_arr_1_len;
   variable Poisoned_Weapon_arr_2_len;
   variable i;
   if PoisonAppliedWeapons_len > 0 then begin
      PoisonableWeapons_timer = 1;
      add_global_timer_event(30, fixed_param_poison_perk_rm);
   end

   PoisonableWeapons = get_ini_string("mods\\F2MechanicsMiniRework.ini|Poison|PoisonableWeapons");
   if PoisonableWeapons != "" then begin
      PoisonableWeapons = string_split_ints(PoisonableWeapons, ",");
      fix_array(PoisonableWeapons);
   end
   else
      PoisonableWeapons = 0;

   Poisoned_Weapon_arr_1 = get_ini_string("mods\\F2MechanicsMiniRework.ini|Poison|PoisonedWeapons");
   if Poisoned_Weapon_arr_1 != "" then begin
      Poisoned_Weapon_arr_1 = string_split(Poisoned_Weapon_arr_1, ",");
      Poisoned_Weapon_arr_1_len = len_array(Poisoned_Weapon_arr_1);
   end
   if Poisoned_Weapon_arr_1_len > 0 then begin
      PoisonedWeapons = create_array_map;
      for (i := 0; i < Poisoned_Weapon_arr_1_len; i++) begin
         Poisoned_Weapon_arr_2 = string_split_ints(Poisoned_Weapon_arr_1[i], ":");
         set_array(PoisonedWeapons, Poisoned_Weapon_arr_2[0], Poisoned_Weapon_arr_2[1]);
      end
   end
   if Megamod > 0 then begin
      if not(array_exists(PoisonedWeapons)) then begin
         PoisonedWeapons = create_array_map;
      end
      if get_array(PoisonedWeapons, 700) <= 0 then
         set_array(PoisonedWeapons, 700, 8);
      if get_array(PoisonedWeapons, 701) <= 0 then
         set_array(PoisonedWeapons, 701, 10);
      if get_array(PoisonedWeapons, 703) <= 0 then
         set_array(PoisonedWeapons, 703, 12);
   end
end

procedure game_close begin
   variable msg = "All set. Restart the game";
   game_ui_enable;
   sfall_func2("message_box", msg, MSGBOX_NORMAL);
   display_msg(msg);
   write_byte(0x481B2A, 0xB8);
   write_int(0x481B2B, 27);
   sfall_func0("signal_close_game");
end

procedure ecco_heal_mod_handler begin
   variable disable_ecco;
   disable_ecco = message_box(
      modmsg(msg_ecco_healing_drugs_1)+"\n"
      + modmsg(msg_ecco_healing_drugs_2)+"\n"
      + modmsg(msg_ecco_healing_drugs_3)+"\n"
      + modmsg(msg_ecco_healing_drugs_4)+"\n"
      + modmsg(msg_ecco_healing_drugs_5));
   return disable_ecco;
end

procedure game_exit_to_menu begin
   write_byte(0x481B2A, 0xB8);
   write_int(0x481B2B, 27);
   sfall_func0("signal_close_game");
end

procedure start begin
   variable max_potential_party_pids_count;
   variable potential_party_mem_pid;
   variable cur_game_time;
   variable i;
   variable critter_lvl;
   variable ECCO_heal_tweak;
   if (game_loaded) then begin
      sfall_ver_maj = sfall_ver_major;
      ver_minor = sfall_ver_minor;
      ver_build = sfall_ver_build;
      if sfall_ver_maj >= 5 then begin
         if ver_build >= 8 orElse sfall_ver_maj > 5 orElse ver_minor > 0 then begin
            sfall_508 = 1;
            if ver_minor > 0 then begin
               sfall_510 = 1;
               unsafe_script;
            end
         end
      end
      RegenMod = get_ini_setting ("mods\\F2MechanicsMiniRework.ini|Main|RegenMod");
      PoisonMod = get_ini_setting("mods\\F2MechanicsMiniRework.ini|MAIN|PoisonMod");
      new_regpois_msg = add_extra_msg_file("gl_RegPoisMod.msg");
      old_envenomed_msg = modmsg(2001);
      envenomed_msg = modmsg(msg_envenomed);
      perk_poison_mastery_name = modmsg(msg_perk_poison_mastery_name);
      envenomed_description_msg = modmsg(msg_envenomed_description);
      perk_poison_mastery_description = modmsg(msg_perk_poison_mastery_description);
      regen_perk_name = modmsg(msg_perk_regen);

      if RegenMod > 0 orElse PoisonMod > 0 then begin
         if PoisonMod > 0 andAlso sfall_508 orElse sfall_510 then begin
            if get_ini_setting("ddraw.ini|Misc|NPCPoisonDamage") > 0 then begin
               set_ini_setting("ddraw.ini|Misc|NPCPoisonDamage", 0);
            end
         end
         sfall_unsafescripting = get_ini_setting("ddraw.ini|Debugging|AllowUnsafeScripting");
         if RegenMod > 0 then begin
            ECCO_heal_tweak = get_ini_setting("mods\\ecco\\misc.ini|HEALING_DRUGS|skill_max");
            if ECCO_heal_tweak > 0 then begin
               if ecco_heal_mod_handler <= 0 then begin
                  set_ini_setting("mods\\F2MechanicsMiniRework.ini|Main|RegenMod", 0);
               end
               else begin
                  set_ini_setting("mods\\ecco\\misc.ini|HEALING_DRUGS|skill_max", 0);
                  if sfall_unsafescripting < 1 orElse (sfall_510 <= 0 andAlso sfall_unsafescripting < 2) then begin
                     set_ini_setting("ddraw.ini|Debugging|AllowUnsafeScripting", 2 - sfall_510);
                     sfall_unsafescripting = 2;
                  end
               end
               if sfall_unsafescripting < 2 then
                  call game_exit_to_menu;
               else
                  call game_exit_to_menu in 1;
               return;
            end
         end

         if sfall_unsafescripting < 2 then begin
            if sfall_510 > 0 andAlso sfall_unsafescripting > 0 then begin
               set_stat_max(STAT_heal_rate, new_max_hr);
               set_stat_min(STAT_heal_rate, -new_max_hr);
            end
            else begin
               set_ini_setting("ddraw.ini|Debugging|AllowUnsafeScripting", 2 - sfall_510);
               call game_close in 1;
            end
         end
         else begin
            set_stat_max(STAT_heal_rate, new_max_hr);
            set_stat_min(STAT_heal_rate, -new_max_hr);
         end
         if sfall_510 <= 0 then
            anim_priority_byte = read_byte(0x413C20);

         tmp_map_exit_event_array = create_array_map;
         event_free_key_array = load_array(event_key_array_name);
         if not event_free_key_array then begin
            event_free_key_array = create_array_map;
            save_array(event_key_array_name, event_free_key_array);
            //set_free_key_queue_event_array_char("A");
            set_free_key_queue_event_array(INT32_MIN);
         end
         ptr_to_id_array = create_array_map;
         party_levels = create_array_map;
         foreach i in party_member_list(1) begin
            if i == real_dude_obj orElse obj_type(i) != OBJ_TYPE_CRITTER then
               continue;
            potential_party_mem_pid = obj_pid(i);
            critter_lvl = get_npc_level(potential_party_mem_pid);
            if critter_lvl < 0 then
               critter_lvl = 0;
            set_array(party_levels, potential_party_mem_pid, critter_lvl);
         end


         if sfall_510 <= 0 then begin
            F2MMR_POTENTIAL_PARTY_PIDs_ARRAY = load_array(POTENTIAL_PARTY_PIDs_ARRAY_name);
            if F2MMR_POTENTIAL_PARTY_PIDs_ARRAY <= 0 then begin
               F2MMR_POTENTIAL_PARTY_PIDs_ARRAY = create_array_map;
               save_array(POTENTIAL_PARTY_PIDs_ARRAY_name, F2MMR_POTENTIAL_PARTY_PIDs_ARRAY);
               max_potential_party_pids_count = read_int(0x519D9C);
               for (i = 0; i < max_potential_party_pids_count; i++) begin
                  potential_party_mem_pid = read_int(read_int(0x519DA0) + 4 * i);
                  set_array(F2MMR_POTENTIAL_PARTY_PIDs_ARRAY, potential_party_mem_pid, 1);
               end
            end
         end

         cur_game_time = game_time;

         if combat_is_initialized then
            combat_turn_start_time = cur_game_time;
         last_timed_event_time = cur_game_time;
         iface_tag_regen = add_iface_tag;
         iface_tag_burn = add_iface_tag;
         set_iface_tag_text(iface_tag_regen,modmsg(msg_heal_tag), 0);
         set_iface_tag_text(iface_tag_burn,modmsg(msg_burn_tag), 1);
         id_to_burn_count = create_array_map;
         fix_array(id_to_burn_count);
         combatants_array = load_array(combatants_array_name);
         if not combatants_array then begin
            combatants_array = create_array_map;
            save_array(combatants_array_name, combatants_array);
         end

         delayed_dude_stats_display = create_array_map;
         fix_array(delayed_dude_stats_display);
         death_array = create_array_map;
         fix_array(death_array);

         id_to_first_event_array = load_array(id_to_event_key_array_name);
         if not id_to_first_event_array then begin
            id_to_first_event_array = create_array_map;
            save_array(id_to_event_key_array_name, id_to_first_event_array);
         end

         //enable HOOK_COMBATTURN for DAM_KNOCKED_OUT and out of range critters
         //write_byte(0x422600, 0xC9);
         //write_byte(0x4222EC, 0x90);
         //write_byte(0x4222ED, 0x90);

         combat_diff = (combat_difficulty + 1);

         register_hook_proc(HOOK_COMBATTURN, COMBATTURN);
         register_hook_proc(HOOK_RESTTIMER, RESTTIMER);
         register_hook_proc_spec(HOOK_AFTERHITROLL, AFTERHITROLL);
         //register_hook_proc_spec(HOOK_COMBATDAMAGE, COMBATDAMAGE);
         register_hook_proc_spec(HOOK_USEOBJON, USEOBJON);
         register_hook_proc(HOOK_GAMEMODECHANGE, GAMEMODECHANGE);
         register_hook_proc_spec(HOOK_DEATHANIM2, DEATHANIM2);
         register_hook_proc_spec(HOOK_ONDEATH, ONDEATH);

         set_global_script_type(3);
         set_global_script_repeat(0);
         if get_proto_data(PID_SMALL_TAIL, PROTO_IT_INV_FID) == 0x7000192 then gPID_SMALL_SCORPION_TAIL = PID_SMALL_TAIL;
         Nevada = get_ini_setting ("mods\\F2MechanicsMiniRework.ini|Main|Nevada");
         Sonora = get_ini_setting ("mods\\F2MechanicsMiniRework.ini|Main|Sonora");
         Resurrection = get_ini_setting ("mods\\F2MechanicsMiniRework.ini|Main|Resurrection");
         ET_TU = get_ini_setting ("mods\\F2MechanicsMiniRework.ini|Main|et_tu");
         //
         if Nevada <= 0 andAlso Sonora <= 0 andAlso Resurrection <= 0 andAlso ET_TU <= 0 then begin
            Fallout_2 = 1;
            if get_proto_data(542, PROTO_FID) == 197 then begin
               Megamod = 1;
            end
            if get_proto_data(595, PROTO_FID) == 171 then begin
               Olympus2207 = 1;
            end
         end
         RegenMod = get_ini_setting ("mods\\F2MechanicsMiniRework.ini|Main|RegenMod");
         sfall_mods_config = get_ini_string("ddraw.ini|Scripts|IniConfigFolder");
         if sfall_mods_config <= 0 then sfall_mods_config = "";
         combat_direct_controll = get_ini_setting(sfall_mods_config+"\\sfall-mods.ini|CombatControl|Mode");
         if RegenMod > 0 then begin
            register_hook_proc(HOOK_CALCAPCOST, CALCAPCOST);
            register_hook_proc(HOOK_REMOVEINVENOBJ, REMOVEINVENOBJ);
            MedToolsMod = get_ini_setting("mods\\F2MechanicsMiniRework.ini|Main|MedToolsMod");
            regen_repeat_ticks = get_config_set_float("mods\\F2MechanicsMiniRework.ini|Regeneration|RegenTimer", 5.0);
            regen_repeat_ticks = round(regen_repeat_ticks * 10);
            if regen_repeat_ticks < 1 then
               regen_repeat_ticks = 1;

            regen_stimpak_ticks = get_config_set_int("mods\\F2MechanicsMiniRework.ini|Regeneration|StimpakTicks", 3);
            if regen_stimpak_ticks < 1 then
               regen_stimpak_ticks = 1;

            id_to_regen_time = load_array(id_to_regen_time_array_name);
            if not id_to_regen_time then begin
               id_to_regen_time = create_array_map;
               save_array(id_to_regen_time_array_name, id_to_regen_time);
            end

             regen_array_time = create_array_map;
             array_add_burn = create_array_map;
             TraitsPlus = get_ini_setting("mods\\F2MechanicsMiniRework.ini|Main|TraitsPlus");
             if TraitsPlus > 0 then begin
                fast_metabolism_plus = get_ini_setting("mods\\F2MechanicsMiniRework.ini|TraitsPlus|Fast_Metabolism");
             end
             WAHR = get_ini_setting("mods\\F2MechanicsMiniRework.ini|CRITTER|WAHR");
             TWAHR = get_ini_setting("mods\\F2MechanicsMiniRework.ini|CRITTER|TWAHR");
             WAQHR = get_ini_setting("mods\\F2MechanicsMiniRework.ini|CRITTER|WAQHR");
             CENHR = get_ini_setting("mods\\F2MechanicsMiniRework.ini|CRITTER|CENHR");
             MCENHR = get_ini_setting("mods\\F2MechanicsMiniRework.ini|CRITTER|MCENHR");

            RegenBaseHP = get_config_set_float("mods\\F2MechanicsMiniRework.ini|Regeneration|RegenBaseHP", 0);

            RegenMaxHPpercentMult = get_config_set_float("mods\\F2MechanicsMiniRework.ini|Regeneration|RegenMaxHPpercentMult", 1.0);

            HealingRateMult = get_config_set_float("mods\\F2MechanicsMiniRework.ini|Regeneration|RegenBaseHP", 0.1);

            StimUninjure = get_ini_setting("mods\\F2MechanicsMiniRework.ini|Regeneration|StimUninjure");
            //UnsafeRegenModScripting = get_ini_setting ("mods\\F2MechanicsMiniRework.ini|Regeneration|UnsafeRegenModScripting");
         end
         PoisonMod = get_ini_setting("mods\\F2MechanicsMiniRework.ini|MAIN|PoisonMod");
         ShowModMSG = get_ini_setting("mods\\F2MechanicsMiniRework.ini|MAIN|ShowMSG");
         ShowFloatMSG = get_ini_setting("mods\\F2MechanicsMiniRework.ini|MAIN|ShowFloatMSG");
         if PoisonMod > 0 then begin
            gPoisonableWeaponsRemoveTimeLast = cur_game_time;
            poison_repeat_ticks = get_config_set_float("mods\\F2MechanicsMiniRework.ini|Poison|PoisonTimer", 5.0);
            poison_repeat_ticks = round(poison_repeat_ticks * 10);
            if poison_repeat_ticks < 1 then
               poison_repeat_ticks = 1;
            register_hook_proc(HOOK_WITHINPERCEPTION, WITHINPERCEPTION);

            id_to_poison_fraction = load_array(id_to_poison_fraction_array_name);
            if not id_to_poison_fraction then begin
               id_to_poison_fraction = create_array_map;
               save_array(id_to_poison_fraction_array_name, id_to_poison_fraction);
            end

            id_to_poison_time = load_array(id_to_poison_timer_array_name);
            if not id_to_poison_time then begin
               id_to_poison_time = create_array_map;
               save_array(id_to_poison_timer_array_name, id_to_poison_time);
            end

            register_hook_proc_spec(HOOK_ADJUSTPOISON, ADJUSTPOISON);
            PoisonableWeapons_rm = create_array_map;
            PoisonAppliedWeapons = load_array("PoisonAppliedWeaponsMMR");

            PoisonAppliedWeapons_len = len_array(PoisonAppliedWeapons);
            if PoisonAppliedWeapons_len < 0 then begin
               PoisonAppliedWeapons_len = 0;
               call check_poisoned_weapons_perks;
            end

            call set_pois_wpn;

            if get_ini_setting("mods\\F2MechanicsMiniRework.ini|Main|MedToolsMod") > 0 then begin
               NPCsUseMedTools = get_ini_setting ("mods\\F2MechanicsMiniRework.ini|MedToolsMod|NPCsUseMedTools");
               if Sonora > 0 then begin
                  doc_bag_pid = Sonora_doc_bag_pid;
               end
            end
            array_add_poison = create_array_map;
            //disabling the dependence of the poison timer on poison amount
            if sfall_ver_maj < 5 then begin
               write_byte(0x42D33A, 0xB9); //disable "You take damage from poison" MISC.MSG
               write_byte(0x42D2D5, 0xFF); // Disable message №3000 to prevent displaying 'You have been poisoned!' if poison amount = 0
               write_byte(0x42D2E1, 0xB9); //MISC.MSG №3002 changed

               //disable original poison add que
               write_byte(0x42D2CC, 0x90);
               write_byte(0x42D2CD, 0x90);
               write_byte(0x42D2CE, 0x90);
               write_byte(0x42D2CF, 0x90);
               write_byte(0x42D2D0, 0x90);
            end

            msg_u_feel_better = message_str_game(GAME_MSG_MISC, 3002);
            Poison_overdose = get_config_set_float("mods\\F2MechanicsMiniRework.ini|Poison|Poison_overdose", 100);

            Poison_overdose_max_hp_value = get_config_set_float("mods\\F2MechanicsMiniRework.ini|Poison|PoisonOverdoseMaxHPMult", 0);

            PoisonBaseDMG = get_ini_string("mods\\F2MechanicsMiniRework.ini|Poison|PoisonBaseDMG");
            if (PoisonBaseDMG == "") then
               PoisonBaseDMG = 0;
            else
               PoisonBaseDMG = atof(PoisonBaseDMG);


            PoisonMaxHPpercentMult = get_ini_string("mods\\F2MechanicsMiniRework.ini|Poison|PoisonMaxHPpercentMult");
            if (PoisonMaxHPpercentMult == "") then
               PoisonMaxHPpercentMult = 1.0;
            else
               PoisonMaxHPpercentMult = atof(PoisonMaxHPpercentMult);

            EnemyPoisonMult = get_ini_string("mods\\F2MechanicsMiniRework.ini|Poison|EnemyPoisonMult");
            if EnemyPoisonMult == "" then
               EnemyPoisonMult = 1.5;
            else
               EnemyPoisonMult = atof(EnemyPoisonMult);

            PoisonDecayMult = get_ini_string("mods\\F2MechanicsMiniRework.ini|Poison|PoisonDecayMult");
            if PoisonDecayMult == "" then
               PoisonDecayMult = 0.1;
            else
               PoisonDecayMult = atof(PoisonDecayMult);


            PoisonDecayConst = get_ini_string("mods\\F2MechanicsMiniRework.ini|Poison|PoisonDecayConst");
            if PoisonDecayConst == "" then
               PoisonDecayConst = 2;
            else
               PoisonDecayConst = atof(PoisonDecayConst);

            PoisonDMGMult = get_ini_string("mods\\F2MechanicsMiniRework.ini|Poison|PoisonDMGMult");
            if PoisonDMGMult == "" then
               PoisonDMGMult = 0.1;
            else
               PoisonDMGMult = atof(PoisonDMGMult);
         end
         NPCsUsePoisonTails = get_ini_setting("mods\\F2MechanicsMiniRework.ini|Poison|NPCsUsePoisonTails");
         HR_fog_of_war = get_ini_setting("f2_res.ini|MAPS|FOG_OF_WAR");

         regen_perk_acquired_msg = modmsg(msg_perk_regen_acquired);
         regen_perk_description = modmsg(msg_perk_regen_description);
         right_hand_healed_msg = modmsg(msg_right_hand_healed);
         right_leg_healed_msg = modmsg(msg_right_leg_healed);
         left_hand_healed_msg = modmsg(msg_left_hand_healed);
         left_leg_healed_msg = modmsg(msg_left_leg_healed);
         eyes_healed_msg = modmsg(msg_eyes_healed);
         failed_sneak_use_msg = modmsg(msg_failed_poison_sneak);

         if RegenMod > 0 andAlso Sonora > 0 then begin
            Sonora_drug_desc_separator = modmsg(80);
            register_hook_proc_spec(HOOK_DESCRIPTIONOBJ, DESCRIPTIONOBJ);
         end

         call map_enter_p_proc();
         last_use_hr_drug = (cur_game_time + 600);
         //check regen perk
         if RegenMod > 0 then begin
            call get_PERK_faster_healing_bonus;
            call newperks();
            faster_healing_bonus = -99;
         end

         if regen_repeat_ticks > poison_repeat_ticks then
            lowest_timer = poison_repeat_ticks;
         else
            lowest_timer = regen_repeat_ticks;

         if lowest_timer <= 0 then begin
            if regen_repeat_ticks < poison_repeat_ticks then
               lowest_timer = poison_repeat_ticks;
            else
               lowest_timer = regen_repeat_ticks;
         end

         if lowest_timer > 0 then begin
            all_in_one_repeat_time = lowest_timer / 10;
            if all_in_one_repeat_time <= 0 then
               all_in_one_repeat_time = 1;
            else if all_in_one_repeat_time > 50 then
               all_in_one_repeat_time = 50;


            all_in_one_repeat_time = 1;
            add_global_timer_event(all_in_one_repeat_time, fixed_param_all_in_one);
            global_map_speed_mult = get_ini_setting("ddraw.ini|Misc|WorldMapTimeMod");
            if global_map_speed_mult > 0 then begin
               if global_map_speed_mult > 100 then
                  global_map_speed_mult = 100;
               all_in_one_repeat_time_global = 6000 / (101 - global_map_speed_mult);
               if all_in_one_repeat_time_global < 600 then
                  all_in_one_repeat_time_global = 600;
            end
            else
               all_in_one_repeat_time_global = all_in_one_repeat_time;

         end
         if RegenMod > 0 then
            call check_regen_tag;

         add_global_timer_event(0, fixed_param_rm_mod);
      end
      else begin
         DISABLED = 1;
         ptr_to_id_array = create_array_map;
         id_to_poison_fraction = load_array(id_to_poison_fraction_array_name);
         id_to_poison_time = load_array(id_to_poison_timer_array_name);
         id_to_regen_time = load_array(id_to_regen_time_array_name);
         id_to_first_event_array = load_array(id_to_event_key_array_name);
         add_global_timer_event(0, fixed_param_rm_mod);
         call map_enter_p_proc();
         //call check_regen_tag;
         if sfall_510 <= 0 then begin
            free_array(ptr_to_id_array);
            free_array(id_to_poison_fraction);
            free_array(id_to_poison_time);
            free_array(id_to_regen_time);
            free_array(id_to_first_event_array);
            exit;
         end
      end
   end
   else begin
      if (dude_must_die > 0 or dude_turn_critter_dies > 0) andAlso not(game_ui_is_disabled) then begin
         game_ui_disable2;
         if dude_turn_critter_dies > 0 then begin
            set_cursor_animated_watch;
            call show_death_msg in 2;
         end
      end
   end
end
