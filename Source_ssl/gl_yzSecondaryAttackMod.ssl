#define SFALL_SC_EVALUATION   (true)  // short - circuit evaluation
#define msg_file "gl_SecondaryAttackMod.msg"
#define critter_anim_fid(objFid, animType, rot)       ((rot * 0x10000000) bwor ((animType * 0x10000) bwand 0xFF0000) bwor (objFid bwand 0xF00FFFF))
//#define combat_msg_file "COMBAT.msg"
#define is_critter(obj)   (obj_type(obj) == OBJ_TYPE_CRITTER)
#define is_multihex(critter_obj)  (get_flags(critter_obj) bwand FLAG_MULTIHEX)
#define critter_art_anim(critter_obj)   (art_anim(obj_art_fid(critter_obj)))
#define fid_art_anim(art_fid)   (art_anim(art_fid))
#define is_in_prone_anim(critter_anim)  ((critter_anim >= ANIM_fall_back andAlso critter_anim <= ANIM_fall_front_blood) orElse (critter_anim >= ANIM_fall_back_sf andAlso critter_anim <= ANIM_fall_front_blood_sf))
#define is_dead(critter_obj) (critter_state(critter_obj) == CRITTER_IS_DEAD)
#define critter_art_fid(critter_obj)   (obj_art_fid(critter_obj) bwand 0xFFFF0FFF)
#define ShootThru(obj)   ((get_flags(obj) bwand FLAG_SHOOTTHRU) != 0 orElse (obj_type(obj) == OBJ_TYPE_CRITTER))
//#define no_block_elec(obj)   ((obj_type(obj) == OBJ_TYPE_CRITTER))
#define weapon_attack_mode1(pid)                        (get_proto_data(pid, PROTO_FLAG_EXT) bwand 0x0000000F)
#define weapon_attack_mode2(pid)                        ((get_proto_data(pid, PROTO_FLAG_EXT) bwand 0x000000F0) / 0x10)
#define weapon_attack_mode(pid, attackType)             (weapon_attack_mode1(pid) if (attackType == ATKTYPE_LWEP1 or attackType == ATKTYPE_RWEP1) else weapon_attack_mode2(pid))

#define MAX(x, y)    ((x > y) * x + (x <= y) * y)


#define power_armor_fid(critter_fid)   (critter_fid == FID_HAPOWR or \
                                       critter_fid == FID_NAPOWR or \
                                       critter_fid == FID_HANPWR or \
                                       critter_fid == FID_MABOSS or \
                                       critter_fid == FID_NMSUPA or \
                                       critter_fid == FID_NMCAPA or \
                                       critter_fid == FID_NMVIPA or \
                                       critter_fid == FID_NMMYPA)

#define KILL_TYPE_big_boss            18

#define EXPLOSION_EMP_FID 0x5000002
#define INVISIBLE_MISC_FID 83886081
#define TRNBLK_FID 0x5000019

#define FLAGS_GHOST_OBJECT (0xA000101D) //OBJECT_NO_SAVE,FLAG_NOBLOCK,FLAG_SHOOTTHRU,OBJECT_HIDDEN,FLAG_FLAT,FLAG_LIGHTTHRU,FLAG_NOHIGHLIGHT
#define FLAGS_OBJECT_INERT (0x80000014) //OBJECT_NO_SAVE,FLAG_NOBLOCK,FLAG_SHOOTTHRU
#define FLAGS_OBJECT_PROJECTILE (0xA0000035) //OBJECT_HIDDEN,OBJECT_NO_SAVE,FLAG_NOBLOCK,FLAG_LIGHTING,FLAG_LIGHTTHRU,FLAG_SHOOTTHRU
#define FLAGS_OBJECT_PROJECTILE_visible (0xA0000034) //OBJECT_HIDDEN,OBJECT_NO_SAVE,FLAG_NOBLOCK,FLAG_LIGHTING,FLAG_LIGHTTHRU,FLAG_SHOOTTHRU

#define MASK_OBJ_REMOVE_DEAD_FLAGS (0xFFFEFFE7)


#define _combat_turn_running read_int(0x51093C)

#define combat_disable_display write_int(0x510950, 0)
#define combat_enable_display  write_int(0x510950, 1)

#define tile_refresh_display_disable  call_offset_v0(0x4B12A8)
#define tile_refresh_display_enable  call_offset_v0(0x4B12B4)


#define modmsg(x) message_str_game(SecondaryAttackMod_msg, x)
#define msg_hit 1
#define msg_hit_add 2
#define msg_critical_hit 3
#define msg_critical_hit_add 4
#define msg_dmg_KO random(5,9)
#define msg_death random(10,13)
#define msg_death_dude 23
#define msg_instant_death random(14,15)
#define msg_hit_no_dmg 16
#define msg_hit_no_dmg_dude 24
#define msg_gift_exp_start 17
#define msg_gift_exp_end 18
#define msg_hit_1_hp 19
#define msg_hit_add_1_hp 20
#define msg_critical_hit_1_hp 21
#define msg_critical_hit_add_1_hp 22
#define msg_and 108 // " and "
#define get_active_item(critter)  critter_inven_obj(critter, (2 - active_hand) if critter == dude_obj else INVEN_TYPE_RIGHT_HAND)
#define obj_team(obj)   (has_trait(TRAIT_OBJECT, obj, OBJECT_TEAM_NUM))
#define combat_msg_you 506

#define combat_msg_hit_dmg 513
#define combat_msg_hit_1_dmg 523
#define combat_msg_hit_no_dmg 527

#define get_combat_free_move sfall_func0("get_combat_free_move")

#define PID_SONORA_SMALL_ENERGY_CELL 1
#define PID_SONORA_MICRO_FUSION_CELL 2

#define pid_ka_pow (0x5000030)
#define pid_scroll_block (0x500000C)
#define pid_trans_block (0x5000005)
#define pid_sonora_railgun 183
#define pid_sonora_railgun_proj (0x05000036)
#define SONORA_COMBAT_EXP_GLOBAL_NUM 20
#define DMG_DODGE -5
#define DMG_IGNORE -10
#define DMG_ZERO -15
#define CRITICAL_MISS          0
#define MISS                   1
#define HIT                    2
#define CRITICAL_HIT           3
#define LEFT_HAND              0
#define RIGHT_HAND             1
#define base_alt_ammo_cost     1
#define set_frame_no_refresh(obj,frame) call_offset_v3(0x48AA84, obj, frame, 0)
#define is_alt_fire_aimed(attacker, target, target_bodypart) (target_bodypart == BODY_HIT_TORSO orElse (attack_is_aimed andAlso obj_type(real_orig_target) != OBJ_TYPE_CRITTER andAlso attacker == dude_obj) orElse ((attacker != dude_obj) andAlso (target_bodypart == BODY_UNCALLED orElse target_bodypart < 0)))
#define PROTO_CR_BASE_DT(damage_type) (104 + (4 * damage_type))
#define PROTO_CR_BONUS_DT(damage_type) (244 + (4 * damage_type))
#define PROTO_CR_BASE_DR(damage_type) (132 + (4 * damage_type))
#define PROTO_CR_BONUS_DR(damage_type) (272 + (4 * damage_type))
#define reg_anim_animate_and_move(object, tile, animID, delay)                 sfall_func4("reg_anim_animate_and_move", object, tile, animID, delay)
#define set_obj_script_fixed_value(obj_sid, value) call_offset_v2(0x4A3B34, obj_sid, value)
#define set_obj_script_objects(obj_sid, source, target) call_offset_v3(0x4A3B0C, obj_sid, source, target)
#define exec_obj_script_proc(obj_sid, script_proc_type) call_offset_v2(0x4A4810, obj_sid, script_proc_type)
#define get_combat_exp read_int(0x56D398)
#define set_combat_exp(value) write_int(0x56D398,value)
#define inc_kill_count(kill_type) call_offset_v1(0x42D878, kill_type)
#define set_who_hit_me(critter,obj,attacker_critter_obj) call_offset_v2(0x42E4C0,critter,obj,attacker_critter_obj)
#define get_critter_xp(critter_obj) (get_proto_data(obj_pid(critter_obj), PROTO_CR_EXP_VAL))
#define game_ui_disable2 call_offset_v1(0x443BFC,1)
#define set_cursor_animated_watch call_offset_v1(0x44C840,26)
#define COMBAT_DIFFICULTY_EASY 0
#define COMBAT_DIFFICULTY_NORMAL 1
#define COMBAT_DIFFICULTY_HARD 2

#define DMG_TYPE_FLAG_BURST 16
#define DMG_TYPE_FLAG_BURST_HEAVY 32
#define DMG_FLAG_MULT 100000
#define OUTLINE_BLINKING_CYAN 0xEBF0
#define OUTLINE_BLINKING_ORANGE 0xEE48
#define combat_speed_mem_adr 0x66399C
#define player_speedup_mem_adr 0x663984
#define SavePrefs_adr 0x492CB0


//#define COMBAT_SPEED_MAX 127
//#define COMBAT_SPEED_MAX sfall_510+ 50
#define COMBAT_SPEED_MIN 0
#define COMBAT_SPEED_ELEC    35
#define COMBAT_SPEED_ELEC_Sfall_510    50
#define COMBAT_SPEED_LASER   25
#define COMBAT_SPEED_GAUSS   90

#define injure_allowed_flags_addr 0x45AF10
#define set_anim_priority_disabled write_byte(0x413C20, 0xC3)
#define set_anim_priority_enabled write_byte(0x413C20, anim_priority_byte)

#define reg_anim_callback_delay(arg0, arg1, proc, delay) call_offset_v4(0x414E98, arg0, arg1, proc, delay);
#define reg_anim_set_scr_fix_val(obj_sid, value, delay) call_offset_v4(0x414E98, obj_sid, value, 0x4A3B34, delay)
#define reg_anim_set_scr_source(obj_sid, source, delay) call_offset_v4(0x414E98, obj_sid, source, 0x4A3B0C, delay)
#define reg_anim_exe_scr_proc(obj_sid, script_proc_type, delay) call_offset_v4(0x414E98, obj_sid, script_proc_type, 0x4A4810, delay)

#define reg_anim_heal_critter(critter_obj, amount, delay) call_offset_v4(0x414E98, critter_obj, amount, 0x42D1A4, delay)

#define reg_anim_toggle_outline(critter_obj, outline_bool, delay) call_offset_v3(0x4153A8, critter_obj, outline_bool, delay)
#define tile_num_beyond(start_tile, next_tile, range) call_offset_r3(0x4B1B84, start_tile, next_tile, range)
#define FLAG_OBJECT_HIDDEN 0x01
#define hide_obj_without_flag(obj) call_offset_v2(0x48AE68, obj, read_int(0x51964C))

#define set_animate_to_move_and_wait \
   if (move_and_wait <= 0) then begin \
      /* AnimateAndMoveStraight */ \
      if (sfall_510 > 0) then begin \
         write_byte(0x416F93, 0x80); \
         write_byte(0x416F94, 0xCA); \
         write_byte(0x416F95, 0x02); \
      end else\
         write_byte(0x41471F, 0x3); \
      move_and_wait = 1; \
   end

#define set_animate_to_move \
   if (move_and_wait > 0) then begin \
      /* MoveStraightToTile */ \
      if (sfall_510 > 0) then begin \
         write_byte(0x416F93, 0xB2); \
         write_byte(0x416F94, 0x02); \
         write_byte(0x416F95, 0x90); \
      end else\
         write_byte(0x41471F, 0x2); \
      move_and_wait = 0; \
   end


#define alt_fire_gauss 1
#define alt_fire_laser 2
#define alt_fire_plasma 4
#define alt_fire_pulse 8
#define alt_fire_aimed_burst 16
#define alt_fire_double_tap 32

#define InterfaceBarEnabled_adr 0x518F10


//sfall 5.1
#define REG_ANIM_CLEAR_FORCE                          (4)
#define REG_ANIM_PRIORITY                             (5)
#define REG_ANIM_FLAG_UNSET                           (220)
#define REG_ANIM_FLAG_SET                             (221)

#define reg_anim_clear_forced(who)                    if sfall_510 <= 0 then call reg_anim_clear_forced_sfall_4(who); else reg_anim_func(REG_ANIM_CLEAR_FORCE, who)
#define reg_anim_set_priority                         if sfall_510 <= 0 then call_offset_v1(0x413C20, true); else reg_anim_func(REG_ANIM_PRIORITY, 1)
#define reg_anim_set_flag(object, flag, delay)        if sfall_510 <= 0 then call_offset_v3(0x415034, object, flag, delay); else metarule3(REG_ANIM_FLAG_SET,   object, flag, delay)
#define reg_anim_unset_flag(object, flag, delay)      if sfall_510 <= 0 then call_offset_v3(0x4150A8, object, flag, delay); else metarule3(REG_ANIM_FLAG_UNSET, object, flag, delay)
#define art_max_frames(artFID)                        sfall_func2("art_frame_data", artFID, -1)

#define hitLocationGetName_str_ptr(critter, hitLocation) call_offset_r2(0x42612C, critter, hitLocation)

//#define INTERFACE_ITEM_ACTION_DEFAULT -1
//#define INTERFACE_ITEM_ACTION_USE 0
#define INTERFACE_ITEM_ACTION_PRIMARY 1
#define INTERFACE_ITEM_ACTION_PRIMARY_AIMING 2
#define INTERFACE_ITEM_ACTION_SECONDARY 3
#define INTERFACE_ITEM_ACTION_SECONDARY_AIMING 4
#define INTERFACE_ITEM_ACTION_RELOAD 5
//#define INTERFACE_ITEM_ACTION_COUNT 6

#define get_active_weapon(critter)  critter_inven_obj(critter, (2 - active_hand) if critter == dude_obj else INVEN_TYPE_RIGHT_HAND)

#define gSoundEffectsEnabled_Address  (0x518E48)
//#define SoundEffectsIsEnabled         call_offset_r0(0x4502E4)
#define SoundEffectsIsEnabled         read_int(gSoundEffectsEnabled_Address)
#define SoundEffectsEnable            call_offset_v0(0x4502BC)  // soundEffectsEnable()
#define SoundEffectsDisable           call_offset_v0(0x4502D0)  // soundEffectsDisable()
#define soundEffectsCacheFlush        call_offset_v0(0x4A9148)
#define Reset_gsound_active_effect_counter  write_int(0x518E4C,0)

#define Enable_SoundEffects \
   if gSoundEffectsWasDisabled != 0 then begin \
      write_byte(0x4514F0, gSoundEffectsWasDisabled); \
      gSoundEffectsWasDisabled = 0; \
   end

#define Disable_SoundEffects \
   if SoundEffectsIsEnabled > 0 andAlso gSoundEffectsWasDisabled == 0 then begin \
      gSoundEffectsWasDisabled = read_byte(0x4514F0); \
      if gSoundEffectsWasDisabled != 0xC3 then \
         write_byte(0x4514F0, 0xC3); \
      else \
         gSoundEffectsWasDisabled = 0; \
   end

#define OUTLINE_TYPE_MASK 0xFFFFFF
#define OUTLINE_DISABLED 0x80000000

#include "define_extra.h"
#include "DEFINE.H"
#include "sfall.h"
#include "lib.strings.h"
#include "dik.h"
#include "mouse.h"
#include "miscpid.h"
//#include "F2MMR.h"

variable g_art_handle;
variable g_art_fid;

variable gAttackerFid;
variable gAttackerFlags;
variable gCurrentAttacker;
variable gCurrentTarget;
variable gCurrentMainTarget;
variable gDoubleTapHitChance;
variable gAttackerX;
variable gAttackerY;


variable sfall_ver_maj;
variable ver_build;
variable ver_minor;
variable sfall_510;
variable YAAM_active;
variable COMBAT_SPEED_MAX;

variable SecondaryAttackMod_msg;
variable LaserSecondaryAttackMod;
//variable LaserLineWidth;
variable LaserHitChance;
variable LaserForced;
variable LaserCustomPids;
variable LaserAmmoBaseCost;
variable LaserFID;
variable LaserFID_expl;
variable Line_targets_array;
variable Line_end_tile;
variable Laser_targets_array_reverse;
variable new_flags_array;
variable gProjToHideOnTargetHit;
variable ElecSecondaryAttackMod;
variable ElecMaxTargets;
variable ElecRadius;
variable ElecDamageReductionPerTarget;
variable ElecDmgMin = 50;
variable ElecDmgMax = 100;
variable ElecHitChance;
variable ElecForced;
variable ElecSameTargets;
//variable ElecRNDTargets;
variable ElecCustomPids;
variable ElecLastMaxRange;
variable laser_new_main_target;
variable laser_new_target_npc;
variable GaussSecondaryAttackMod;
//variable GaussLineWidth;
variable GaussHitChance;
variable GaussDamageReductionPerTarget;
variable GaussDamageReduction;
variable GaussForced;
variable GaussCustomPids;
variable PlasmaSecondaryAttackMod;
variable PlasmaBlastRadius;
variable PlasmaDamageReductionPerTile;
variable PlasmaForced;
variable PlasmaCustomPids;
variable ShotgunSecondaryAttackMod;
variable ShotgunKnockbackMin;
variable ShotgunKnockbackMax;
variable ShotgunForced;
variable PistolSecondaryAttackMod;
variable PistolDoubleTapForced;
variable PistolDoubleTapToHitPenalty;
variable AimedBurstMod;
variable AimedBurstModAnyWeapon;
variable AllowSniperPerk;
variable show_float_dmg;
variable Sonora;

variable dude_will_die;
variable target_bodypart;
variable atk_rslt =-1;
//variable combat_dmg;
//variable combat_flags_tar;
//variable combat_flags_atkr;
//variable orig_attacker;
//variable orig_target;
variable real_orig_target;
variable real_orig_target_unset_FLAG_SHOOTTHRU;

variable gauss_targets_array_reverse;
variable plasma_dmg_array;
variable elec_targets_array;
variable elec_dmg_array;
variable gPotentialTargetsArray;
variable gauss_target_num_key;
variable laser_target_num_key;
variable death_array;
variable altAttackResults;
variable crit_power_roll;
variable friendly_targets_count;
variable enemy_targets_count;
variable enemy_team;
variable laser_cur_ammo;
variable gauss_new_main_target;
variable laser_max_targets;
variable last_target_on_a_line;
variable remainder;
variable ka_pow_fid_changed;
variable proj_pid_changed;
variable perk_id_changed = -1;
variable max_dmg_changed = -1;
variable min_dmg_changed = -1;
variable weapon_proj_pid_changed;
variable weapon_pid_perk_changed;
variable weapon_pid_dmg_changed;
variable ammo_pid_changed;
variable ammo_ac_mod_changed = -1;
variable ammo_dr_mod_changed = -1;
variable ammo_dmg_div_changed = -1;
variable ammo_dmg_mult_changed = -1;
variable bonus_crit_power_roll;
variable bonus_ranged_damage;
variable living_anatomy;
variable gPyromaniac_perk;
variable gPyromaniac_bonus;
variable gLivingAnatomyBonus;
variable night_vision;
variable sniper;
variable sharpshooter;
variable weapon_handling;
variable bloody_mess;
variable one_hander;
variable one_hander_bonus;
variable finesse;
variable gWeapon;
variable gWeaponPid;
variable weapon_anim;
variable weapon_flags;
variable weapon_ammo_pid;
variable weapon_caliber;
variable gWeaponDamageType;
variable gWeaponRange;
variable weapon_min_st;
variable gWeaponMinDmg;
variable gWeaponMaxDmg;
variable weapon_perk;
variable gWeaponProjPid;
//variable weapon_proj_pid_max_frames;
variable weapon_cur_ammo;
variable weapon_ammo_cost;
variable weapon_point_max_frames;
//variable weapon_sfx_hit;
variable move_and_wait = 1;
variable dmg_was_set_to_zero;
variable gCurAtkType;
variable gLastCritterCalledTarget;
variable gLastCritterCalledTargetTorsoName;

variable ammo_mult;
variable ammo_div;
variable ammo_dr_mod;
variable ammo_ac_mod;
variable laser_max_targets_two_handed_micro_fusion;
variable laser_max_targets_one_handed_micro_fusion;
variable laser_max_targets_two_handed_small_cell;
variable laser_max_targets_one_handed_small_cell;

variable alt_fire_selected;
variable attacker_frm = -1;
variable is_single_shot;
variable gShotgunCaliber;
variable cleanup_required;
variable orig_target_alt_attack_dmg;
variable orig_target_was_dmg;
//variable gCombatHighlight;
variable EXPLOSION_TARGET_COUNT = (6);
variable alt_atk_wait_for_report;

variable traits_plus;
variable kamikaze;
variable allow_critical;
variable finesse_plus;
//variable bloody_mess_plus;
//variable anim_priority_byte;
//variable priority_disabled;
//variable aimed_byte = read_byte(0x478E5C);
variable aimed_burst_allowed;
variable is_aimed_burst;
variable aimed_burst_crit_hit;
variable aimed_burst_max_hit;
variable gAimedBurstTarget;
variable critter_injure_ORIG;
variable critter_injure_modded;
variable last_combat_speed = -1;
variable last_ap_cost_aimed;
variable InterfaceBarWindow;
variable SoundEffectsEnabled = -1;
variable PlayerSpeedup1;
variable player_speedup_was_enabled;
variable combat_targets_array;
variable shootthru_obj_array;
variable shootthru_was_set;
variable combat_target_atk_result;
variable one_time_AFTERHITROLL;
variable one_time_COMBATDAMAGE;
variable one_time_TOHIT;
variable get_new_targets;
variable cur_attack_results_arr;
variable gSoundHitTarget;
variable gGaussInitialDmg = -1;
variable gGaussWeaponDmg = -1;
variable gGaussWeaponDmgCombatTarget;
variable gAllowProjHitSound;
variable gPulseTileNext;
variable gPulseTileRefreshOutlineArray;
variable gPulseTileNextDistance;
variable gPulseTileAttackedArray;
variable gPulseTileAttackedCount;
variable noblock_obj_array;
variable noblock_was_set;
variable gPulseNextTileCritter;
variable gPulseExplToDestroyArray;
//variable gPulseBackward;
variable gPulseBackwardKey;
variable gSoundEffectsWasDisabled;

variable pre_last_item_action;

variable offsetTester;
variable offsetX;
variable offsetY;

variable ecco_ammocost_map;

variable aimed_burst_hit_penalty;

export variable import_alt_attack_aoe_targets_arr;


procedure reg_anim_clear_forced_sfall_4(variable who) begin
   variable original_byte = read_byte(0x413C8C);

   write_byte(0x413C8C, 0xEB);
   reg_anim_clear(who);

   write_byte(0x413C8C, original_byte);
end

procedure get_art_max_frames(variable obj_fid, variable new_anim = -1) begin
   variable frame;
   variable max_frames;
   variable old_fid;
   variable test_obj;
   variable test_fid;
   variable arg3;

   if sfall_510 > 0 then begin
      test_fid = obj_fid;

      if new_anim >= 0 then begin

         if new_anim < 0 then
            new_anim = art_anim(test_fid);

         if (new_anim != ANIM_fire_dance andAlso new_anim >= ANIM_fall_back andAlso new_anim <= ANIM_fall_front_blood) then
            arg3 = 1;

         test_fid = critter_anim_fid(test_fid, new_anim, arg3);
      end

      max_frames = art_max_frames(test_fid);
      return max_frames;
   end

   test_obj = create_object_sid(0x05000009, 0, 0, -1);

   old_fid = obj_fid;

   if new_anim >= 0 then begin

      if new_anim < 0 then
         new_anim = art_anim(old_fid);

      if (new_anim != ANIM_fire_dance andAlso new_anim >= ANIM_fall_back andAlso new_anim <= ANIM_fall_front_blood) then
         arg3 = 1;

      test_fid = critter_anim_fid(old_fid, new_anim, arg3);
      set_object_data(test_obj, OBJ_DATA_FID, test_fid);
   end
   else begin
      set_object_data(test_obj, OBJ_DATA_FID, old_fid);
   end

   while max_frames < 101 do begin
      set_frame_no_refresh(test_obj, max_frames);
      frame = get_object_data(test_obj, OBJ_DATA_CUR_FRM);

      if frame != max_frames then
         break;

      max_frames++;
   end

   destroy_object(test_obj);

   return max_frames;
end

//procedure disable_anim_priority begin
   //if priority_disabled > 0 orElse sfall_510 > 0 then
      //return;
   //set_anim_priority_disabled;
   //priority_disabled = 1;
//end
//
//procedure enable_anim_priority begin
   //if priority_disabled <= 0 then
      //return;
   //set_anim_priority_enabled;
   //priority_disabled = 0;
//end

procedure add_to_export_arr(variable critter, variable dmg) begin
   set_array(import_alt_attack_aoe_targets_arr, critter, get_array(import_alt_attack_aoe_targets_arr, critter) + dmg);
end

procedure restore_weapon_proj_pid begin
   if weapon_proj_pid_changed > 0 then begin
      set_proto_data(weapon_proj_pid_changed, PROTO_WP_PROJ_PID, proj_pid_changed);
      proj_pid_changed = -1;
      weapon_proj_pid_changed = 0;
   end
end

procedure change_weapon_proj_pid(variable pid_weapon, variable pid_proj) begin
   if weapon_proj_pid_changed > 0 then begin
      call restore_weapon_proj_pid;
   end
   if pid_weapon <= 0 then
      return;

   set_proto_data(pid_scroll_block, PROTO_FID, INVISIBLE_MISC_FID);
   proj_pid_changed = get_proto_data(pid_weapon, PROTO_WP_PROJ_PID);
   if proj_pid_changed != pid_proj then begin
      if pid_proj < 0 then
         pid_proj = 0;

      set_proto_data(pid_weapon, PROTO_WP_PROJ_PID, pid_proj);
      weapon_proj_pid_changed = pid_weapon;
      if weapon_proj_pid_changed == gWeaponPid then
         gWeaponProjPid = pid_proj;
   end
   else begin
      proj_pid_changed = -1;
   end
end

procedure restore_weapon_min_max_dmg begin
   if weapon_pid_dmg_changed > 0 then begin
      if min_dmg_changed >= 0 then begin
         set_proto_data(weapon_pid_dmg_changed, PROTO_WP_DMG_MIN, min_dmg_changed);
         min_dmg_changed = -1;
      end
      if max_dmg_changed >= 0 then begin
         set_proto_data(weapon_pid_dmg_changed, PROTO_WP_DMG_MAX, max_dmg_changed);
         max_dmg_changed = -1;
      end
      weapon_pid_dmg_changed = 0;
   end
end

procedure restore_weapon_perk begin
   if weapon_pid_perk_changed > 0 then begin
      set_proto_data(weapon_pid_perk_changed, PROTO_WP_PERK, perk_id_changed);
      perk_id_changed = -1;
      weapon_pid_perk_changed = 0;
   end
end

procedure change_weapon_perk(variable pid_weapon, variable perk_id) begin
   if weapon_pid_perk_changed > 0 then begin
      call restore_weapon_perk;
   end
   if pid_weapon <= 0 then
      return;

   perk_id_changed = get_proto_data(pid_weapon, PROTO_WP_PERK);
   if perk_id_changed != perk_id then begin
      if perk_id < 0 then
         perk_id = 0;

      set_proto_data(pid_weapon, PROTO_WP_PERK, perk_id);
      weapon_pid_perk_changed = pid_weapon;
   end
   else begin
      perk_id_changed = -1;
   end
end


procedure restore_ammo_properties begin
   if ammo_pid_changed > 0 then begin
      if ammo_ac_mod_changed >= 0 then begin
         set_proto_data(ammo_pid_changed, PROTO_AM_AC_MOD, ammo_ac_mod_changed);
         ammo_ac_mod_changed = -1;
      end
      if ammo_dr_mod_changed >= 0 then begin
         set_proto_data(ammo_pid_changed, PROTO_AM_DR_MOD, ammo_dr_mod_changed);
         ammo_dr_mod_changed = -1;
      end
      if ammo_dmg_div_changed >= 0 then begin
         set_proto_data(ammo_pid_changed, PROTO_AM_DMG_DIV, ammo_dmg_div_changed);
         ammo_dmg_div_changed = -1;
      end
      if ammo_dmg_mult_changed >= 0 then begin
         set_proto_data(ammo_pid_changed, PROTO_AM_DMG_MULT, ammo_dmg_mult_changed);
         ammo_dmg_mult_changed = -1;
      end
      ammo_pid_changed = 0;
   end
end

procedure get_one_hander_bonus(variable weapon_flags) begin
   variable one_hander_bonus;
   if weapon_flags bwand WEAPON_2HAND then begin
      one_hander_bonus = -40;
   end
   else begin
      one_hander_bonus = 20;
   end
   return one_hander_bonus;
end

procedure obj_get_visible_light(variable critter) begin
   variable target_tile_light = call_offset_r1(0x48AD04, critter);
   return target_tile_light;
end

procedure get_ranged_weapon_skill_lvl(variable attacker, variable weapon) begin
   variable wpn_flags;
   variable wpn_dmg_type;
   variable weapon_skill;
   if weapon <= 0 then
      return has_skill(attacker, SKILL_UNARMED_COMBAT);

   wpn_flags = get_proto_data(obj_pid(weapon), PROTO_FLAG_EXT);
   wpn_dmg_type = get_proto_data(obj_pid(weapon), PROTO_WP_DMG_TYPE);

   if ((wpn_flags bwand WEAPON_ENERGY) == WEAPON_ENERGY) or wpn_dmg_type == DMG_laser or wpn_dmg_type == DMG_plasma or wpn_dmg_type == DMG_electrical then begin
      weapon_skill = has_skill(attacker, SKILL_ENERGY_WEAPONS);
   end
   else begin
      if (wpn_flags bwand WEAPON_BIGGUN ) == WEAPON_BIGGUN then begin
         weapon_skill = has_skill(attacker, SKILL_BIG_GUNS);
      end
      else begin
         weapon_skill = has_skill(attacker, SKILL_SMALL_GUNS);
      end
   end
   return weapon_skill;
end

// reproduced fallout 2 hit chance pseudo code for ranged weapons excluding throwing
procedure get_ranged_chance_to_hit(variable attacker,variable target, variable targets_num_between = 0, variable multihex_targets_num_between = 0, variable aimed_burst = 0) begin
   variable target_ac;
   variable attacker_team = has_trait(TRAIT_OBJECT, attacker, OBJECT_TEAM_NUM);
   variable attacker_pe = get_critter_stat(attacker, STAT_pe);
   variable attacker_st = (get_critter_stat(attacker, STAT_st) + weapon_handling);
   variable attacker_is_blind = Is_Blind(attacker);
   variable difficulty = combat_difficulty;
   variable tar_cur_frm = get_object_data(target, OBJ_DATA_CUR_FRM);
   variable obj_visible_light = obj_get_visible_light(target);
   variable bodypart_hit_modifier;
   variable blocking_penalty = 5;//in Fallout 2 the default is 10
   variable multihex_blocking_penalty = 10;//in Fallout 2 the default is 20
   variable weapon_skill;
   variable hit_chance;
   variable distance_beyond_visibility;// if attacker is blind
   variable PERK_bonus_distance;// if attacker is blind
   variable perception_bonus_mult = 2;
   variable min_effective_dist;
   variable perception_bonus;
   variable distance_mod = tile_distance_objs(attacker, target);
   variable combat_target = get_object_data(combat_data, C_ATTACK_TARGET);
   //distance_objs(distance_mod, attacker, target);
   //distance_mod -= 1;
   if obj_type(target) == OBJ_TYPE_CRITTER then begin
      target_ac = get_critter_stat(target, STAT_ac);

   end
   //if targets_num_between <= 0 then
      //targets_num_between = new_targets_count;

   //if multihex_targets_num_between <= 0 then
      //multihex_targets_num_between = multihex_targets_count;

   //get attacker weapon_skill level
   weapon_skill = get_ranged_weapon_skill_lvl(attacker, gWeapon);

   hit_chance = weapon_skill + 4;

   if weapon_perk == PERK_weapon_long_range then
       perception_bonus_mult = 4;
   else if weapon_perk == PERK_weapon_scope_range then begin
       perception_bonus_mult = 5;
       min_effective_dist = 8;
   end

   // get sharpshooter bonus to Perception. Works past 10 Perception
   if sharpshooter then begin
      attacker_pe = attacker_pe + 2 * sharpshooter;
   end

   if distance_mod >= min_effective_dist then begin
      if attacker == dude_obj andAlso sfall_510 <= 0 then
         perception_bonus = perception_bonus_mult * (attacker_pe - 2);
      else
         perception_bonus = perception_bonus_mult * attacker_pe;

      distance_mod -= perception_bonus;
   end
   else
       distance_mod += min_effective_dist;

   if distance_mod < -2 * attacker_pe then
      distance_mod = -2 * attacker_pe;

   if (distance_mod >= 0) then begin
      if attacker_is_blind then
         distance_mod *= -12;
      else
         distance_mod *= -4;
   end
   else
      distance_mod *= -4;

   //apply distance mod to hit
   hit_chance += distance_mod;

   //penalty for critters on line of fire
   if targets_num_between > 0 then
      hit_chance -= blocking_penalty + targets_num_between;
   if multihex_targets_num_between then
      hit_chance -= multihex_blocking_penalty + multihex_targets_num_between;

   //penalty -40 or bonus +20 for TRAIT_one_hander
   if one_hander_bonus != 0 then
      hit_chance += one_hander_bonus;


   // get weapon_handling_perk bonus to Strength. Works past 10 Strength
   if weapon_handling then begin
      attacker_st = attacker_st + 3 * weapon_handling;
   end
   // get strength penalty
   if attacker_st < weapon_min_st then begin
      hit_chance += - 20 * (weapon_min_st - attacker_st);
   end

      // net +20% to_hit bonus for PERK_weapon_accurate
   if weapon_perk == PERK_weapon_accurate then begin
      hit_chance += 20;
   end

   // + 15% bonus to hit chance if target has FLAG_MULTIHEX
   if is_multihex(target) then begin
      hit_chance += 15;
   end

   //darkness to_hit penalty in low light(considering PERK_night_vision) without PERK_weapon_night_sight
   // not only for dude!
   if weapon_perk != PERK_weapon_night_sight andAlso obj_visible_light <= 52428 then begin
      if obj_visible_light <= 26214 then begin
         hit_chance -= 40;
      end
      else if obj_visible_light <= 39321 then begin
         hit_chance -= 25;
      end
      else if obj_visible_light <= 52428 then begin
         hit_chance -= 10;
      end
   end

   // penalty if attacker is blind
   if attacker_is_blind then
      hit_chance -= 25;


   if aimed_burst <= 0 then begin
      if target == combat_target then
         bodypart_hit_modifier = get_bodypart_hit_modifier(target_bodypart);

      // bodypart_hit_modifier penalty
      if bodypart_hit_modifier != 0 then begin
         hit_chance += bodypart_hit_modifier;
      end
      //bonus if target is prone
      if is_in_prone_anim(critter_art_anim(target)) then begin
         hit_chance = hit_chance + 40;
      end
      // Modify target AC by ammo_ac_mod
      if ammo_ac_mod then begin
         target_ac = target_ac + ammo_ac_mod;
      end
      // AC cannot be negative
      if target_ac < 0 then target_ac = 0;

      hit_chance -= target_ac;
   end

   // get the number of non-multihex targets between target and attacker
   if multihex_targets_num_between < 0 then multihex_targets_num_between = 0;
   if multihex_targets_num_between > 0 then begin
      targets_num_between = targets_num_between - multihex_targets_num_between;
      if targets_num_between < 0 then targets_num_between = 0;
   end

   if attacker_team != TEAM_PLAYER then begin
      if difficulty == 0 then
         hit_chance -= 20;
      else if difficulty == 2 then
         hit_chance += 20;
   end

   return hit_chance;
end

procedure restore_PlayerSpeedup begin
   if player_speedup_was_enabled then begin
      write_int(player_speedup_mem_adr, 0);
      player_speedup_was_enabled = 0;
   end
end

procedure restore_combat_speed begin
   call restore_PlayerSpeedup;

   if last_combat_speed < 0 then
      return;

   write_int(combat_speed_mem_adr, last_combat_speed);
   call_offset_v1(SavePrefs_adr, 0);
   last_combat_speed = -1;
end

procedure lvar_full_reset begin
   call restore_combat_speed;
   call restore_weapon_proj_pid;
   call restore_weapon_perk;
   call restore_weapon_min_max_dmg;
   Enable_SoundEffects
   gWeapon = 0;
   one_time_AFTERHITROLL = 0;
   one_time_COMBATDAMAGE = 0;
   one_time_TOHIT = 0;
   alt_fire_selected = 0;
   Line_end_tile = 0;
   orig_target_was_dmg = 0;
   friendly_targets_count = 0;
   enemy_targets_count = 0;
   attacker_frm = -1;
   is_single_shot = 0;
   real_orig_target = 0;
   target_bodypart = -1;
   atk_rslt = -1;
   finesse = 0;
   kamikaze = 0;
   bloody_mess = 0;
   one_hander = 0;
   weapon_handling = 0;
   sharpshooter = 0;
   bonus_crit_power_roll = 0;
   bonus_ranged_damage = 0;
   living_anatomy = 0;
   night_vision = 0;
   sniper = 0;
   one_hander_bonus = 0;
   gWeaponPid = 0;
   weapon_flags = 0;
   weapon_ammo_pid = 0;
   gWeaponDamageType = 0;
   gWeaponRange = 0;
   gWeaponMinDmg = 0;
   gWeaponMaxDmg = 0;
   weapon_perk = 0;
   gWeaponProjPid = 0;
   weapon_cur_ammo = 0;
   weapon_ammo_cost = 0;
   ammo_mult = 0;
   ammo_div = 0;
   ammo_dr_mod = 0;
   ammo_ac_mod = 0;
   one_hander_bonus = 0;
   gSoundHitTarget = 0;
   gGaussWeaponDmg = -1;
   gGaussInitialDmg = -1;
   gGaussWeaponDmgCombatTarget = 0;
   gAllowProjHitSound = 0;
   gProjToHideOnTargetHit = 0;
   gPulseTileNext = 0;
   gPulseTileNextDistance = 0;
   gPulseTileAttackedCount = 0;
end

procedure is_hit_from_front(variable attacker_tile, variable target) begin
   variable tar_rot;
   variable rot_to_atk;
   if attacker_tile <= 0 orElse target <= 0 then
      return 1;

   tar_rot = has_trait(TRAIT_OBJECT, target, OBJECT_CUR_ROT);
   rot_to_atk = rotation_to_tile(tile_num(target), attacker_tile);
   if tar_rot == rot_to_atk or (tar_rot + 1)%6 == rot_to_atk or (tar_rot + 5)%6 == rot_to_atk then begin
      return 1;
   end
   else begin
      return 0;
   end
end

//Checking Line of fire is(not) blocked
procedure get_first_non_critter_block_shoot(variable obj, variable target_tile, variable chance_to_find_critter = 0) begin
   variable source_tile = tile_num(obj);
   variable current_obj = obj;
   variable iterations;
   variable max_iterations = 20;
   variable obstacle;
   variable obstacle_tile;
   variable last_obstacle;
   variable last_obstacle_tile;

   if obj <= 0 orElse target_tile <= 0 then
      return -1;

   if (source_tile == target_tile) then
      return 0;

   while (iterations < max_iterations) do begin
      iterations += 1;

      obstacle = obj_blocking_line(current_obj, target_tile, BLOCKING_TYPE_SHOOT);

      if (obstacle == 0) then
         return 0;

      obstacle_tile = tile_num(obstacle);

      if (obstacle_tile == target_tile) then
         return 0;

      if (obstacle == last_obstacle orElse obstacle_tile == last_obstacle_tile) then
         return obstacle;

      if (obj_type(obstacle) != OBJ_TYPE_CRITTER) then
         return obstacle;

      // If it's a critter, check if we should return it based on percentage chance
      if (chance_to_find_critter > 0) then begin
         // Random 1-100, check if <= chance_to_find_critter
         if (random(1, 100) <= chance_to_find_critter) then
            return obstacle;
      end

      last_obstacle_tile = obstacle_tile;
      last_obstacle = obstacle;
      current_obj = obstacle;
   end

   return 0;
end

//checking that there are no BLOCKING_TYPE_BLOCK obstacles between objects
procedure get_electricity_path_block(variable obj_from, variable obj_to) begin
   variable tile_to = tile_num(obj_to);
   variable obstacle = obj_blocking_line(obj_from, tile_to, BLOCKING_TYPE_BLOCK);

   if obstacle > 0 andAlso obstacle != obj_to andAlso tile_num(obstacle) != tile_to then
      return obstacle;

   return 0;
end

//so far without taking into account CRITTER_KILL_TYPE critical hit tables
procedure get_crit_mult(variable crit_power_roll,variable target) begin
   variable crit_mult = 1;
   variable target_kill_type = metarule(METARULE_CRITTER_KILL_TYPE, target);
   if crit_power_roll <= 0 then begin
      crit_mult = 1;
   end
   else if crit_power_roll <= 45 then begin
      crit_mult = 1.5;
   end
   else if crit_power_roll <= 90 then begin
      crit_mult = 2.0;
   end
   else if crit_power_roll > 90 then begin
      crit_mult = 3.5;
   end
   //if boss kill type
   if target_kill_type > 17 then begin
      if crit_mult >= 2 then crit_mult = 1.5;
   end
   return crit_mult;
end

procedure calc_dmg_electric(variable attacker, variable target, variable add_to_exort_arr = 0) begin
   variable attacker_lu = get_critter_stat(attacker, STAT_lu);
   variable critical_chance = get_critter_stat(attacker, STAT_crit_chance);
   variable target_dt;
   variable target_dr;
   variable weapon_dmg = random(gWeaponMinDmg, gWeaponMaxDmg);
   variable rnd = random(0, 100);
   variable crit_roll = rnd;
   variable crit_mult = 1;
   variable min_dmg = 1;
   variable dmg;
   variable flags = DAM_HIT;
   variable attacker_team = has_trait(TRAIT_OBJECT, attacker, OBJECT_TEAM_NUM);
   variable target_team = has_trait(TRAIT_OBJECT, target, OBJECT_TEAM_NUM);
   variable orig_target_team;
   variable target_cr_flags = get_proto_data(obj_pid(target), PROTO_CR_FLAGS);
   variable kill_type;
   if (target_cr_flags bwand CFLG_INVULN) != 0 then
      return -1;

   if ElecDmgMin >= ElecDmgMax then ElecDmgMin = ElecDmgMax;

      target_dt = get_critter_stat(target, STAT_dmg_thresh + gWeaponDamageType);
      target_dr = get_critter_stat(target, STAT_dmg_resist + gWeaponDamageType);

   //Increase target_dr if it attacker has TRAIT_finesse
   if finesse then begin
      target_dr = target_dr + 30;
   end

   if gWeaponDamageType != DMG_emp then begin
      //not for moving lightning
      //if weapon_perk == PERK_weapon_penetrate then begin
         //target_dt = target_dt * 0.2;
      //end
       //if YAAM ammo active
      if YAAM_active > 0 then begin
         if ammo_dr_mod != 0 then begin
            target_dt = target_dt - ammo_dr_mod;

            if target_dt < 0 then begin
               target_dr = target_dr + target_dt * 10;
               target_dt = 0;
            end
         end
      end
      else
         target_dr += ammo_dr_mod;
   end

   crit_power_roll = 0;
   //PERK_sniper crit chance bonus
   if allow_critical > 0 andAlso(crit_roll <= critical_chance or (sniper andAlso random(1,10) <= attacker_lu)) then begin
      crit_power_roll = random(1, (100 + bonus_crit_power_roll));
      crit_mult = get_crit_mult(crit_power_roll,target);

      //if crit_mult > 2 then crit_mult = 2;
      flags = flags bwor DAM_CRITICAL;
      if gWeaponDamageType != DMG_emp then begin
         if crit_mult < 2 then begin
            target_dt = target_dt * 0.8;
            target_dr = target_dr * 0.8;
         end
         else begin
            if not(random(0,2)) then begin
               flags = flags bwor DAM_KNOCKED_DOWN;
            end
            target_dt = target_dt * 0.2;
            target_dr = target_dr * 0.2;
         end
      end
      if crit_mult > 2 then crit_mult = 2;
   end
   if target_dt < 0 then target_dt = 0;
   if target_dr > 90 andAlso gWeaponDamageType != DMG_emp then target_dr = 90;
   if target_dr < 0 then target_dr = 0;


   weapon_dmg = random(gWeaponMinDmg, gWeaponMaxDmg);

   if ElecDamageReductionPerTarget != 0 then
       weapon_dmg = weapon_dmg * (ElecDamageReductionPerTarget ^ gPulseTileAttackedCount);

   dmg = round(((weapon_dmg - target_dt) * (100 - target_dr) / 100.0) * crit_mult);

   if gLivingAnatomyBonus > 0 then begin
      kill_type = critter_kill_type(target);
      if kill_type != KILL_TYPE_alien_kills andAlso kill_type != KILL_TYPE_robot_kills then
         dmg += gLivingAnatomyBonus * living_anatomy;
   end

   if gWeaponDamageType == DMG_fire andAlso gPyromaniac_perk then
      dmg += gPyromaniac_perk * gPyromaniac_bonus;

   if dmg < min_dmg then begin
      return DMG_ZERO;
   end

   flags = flags * DMG_FLAG_MULT;
   dmg = ceil(random(ElecDmgMin, ElecDmgMax) * dmg / 100.0);

   if add_to_exort_arr > 0 then
      call add_to_export_arr(target, dmg);

   return (dmg + flags);
end

procedure calc_dmg_laser_main_target(variable attacker, variable target, variable attacker_flags) begin
   variable target_dt;
   variable target_dr;
   variable weapon_dmg;
   variable crit_power;
   variable crit_mult = 1;
   variable min_dmg = 1;
   variable dmg;
   variable target_cr_flags;
   variable kill_type = critter_kill_type(target);
   if obj_type(target) != OBJ_TYPE_CRITTER then
      return 0;

   target_cr_flags = get_proto_data(obj_pid(target), PROTO_CR_FLAGS);
   if ((target_cr_flags bwand CFLG_INVULN) != 0) orElse (gWeaponDamageType == DMG_emp andAlso kill_type != KILL_TYPE_robot_kills) then
      return 0;
   target_dt = get_critter_stat(target,STAT_dmg_thresh_laser);
   target_dr = get_critter_stat(target,STAT_dmg_resist_laser);
   weapon_dmg = random(gWeaponMinDmg, gWeaponMaxDmg);
   //Increase target_dr if it attacker has TRAIT_finesse
   if finesse then begin
      target_dr = target_dr + 30;
   end
   //guaranteed increase in laser armor-piercing when using an alternative firing mode
   if weapon_perk == PERK_weapon_penetrate then begin
      target_dt = target_dt * 0.1;
      target_dr = target_dr * 0.1;
   end
   else begin
      target_dt = target_dt * 0.2;
      target_dr = target_dr * 0.2;
   end

   // if YAAM ammo active
   if YAAM_active > 0 then begin
      if ammo_dr_mod != 0 then begin
         target_dt = target_dt - ammo_dr_mod;

         if target_dt < 0 then begin
            target_dr = target_dr + target_dt * 10;
            target_dt = 0;
         end
      end
   end
   else
      target_dr += ammo_dr_mod;

   //is crit
   if ((attacker_flags bwand DAM_CRITICAL) != 0) then begin
      crit_power = random(1, (100 + bonus_crit_power_roll));
      crit_mult = get_crit_mult(crit_power, target);
   end

   if target_dt < 0 then target_dt = 0;
   if target_dr > 90 then target_dr = 90;
   if target_dr < 0 then target_dr = 0;

   dmg = round(((weapon_dmg - target_dt) * (100 - target_dr) / 100.0) * crit_mult);

   if gLivingAnatomyBonus > 0 then begin
      kill_type = critter_kill_type(target);
      if kill_type != KILL_TYPE_alien_kills andAlso kill_type != KILL_TYPE_robot_kills then
         dmg += gLivingAnatomyBonus * living_anatomy;
   end

   if gWeaponDamageType == DMG_fire andAlso gPyromaniac_perk then
      dmg += gPyromaniac_perk * gPyromaniac_bonus;

   if dmg < min_dmg then begin
      dmg = 0;
   end
   return dmg;
end

procedure calc_dmg_laser(variable attacker, variable target, variable laser_targets_count = 0, variable laser_targets_count_multihex = 0) begin
   variable attacker_lu = get_critter_stat(attacker, STAT_lu);
   variable attacker_team = has_trait(TRAIT_OBJECT, attacker, OBJECT_TEAM_NUM);
   variable critical_chance = get_critter_stat(attacker, STAT_crit_chance);
   variable target_dt = get_critter_stat(target,STAT_dmg_thresh_laser);
   variable target_dr = get_critter_stat(target,STAT_dmg_resist_laser);
   variable target_team = has_trait(TRAIT_OBJECT, target, OBJECT_TEAM_NUM);
   variable orig_target_team;
   variable weapon_dmg = random(gWeaponMinDmg, gWeaponMaxDmg);
   variable rnd = random(0, 100);
   variable crit_power;
   variable crit_roll = rnd;
   variable crit_mult = 1;
   variable min_dmg = 1;
   variable hit_chance;
   variable miss_local;
   variable flags = (DAM_HIT bwor DAM_BYPASS);
   variable dmg;
   variable target_cr_flags = get_proto_data(obj_pid(target), PROTO_CR_FLAGS);
   variable HitChance = 1;
   variable cur_attack_dmg;
   variable cur_combat_target = get_object_data(combat_data, C_ATTACK_TARGET);
   variable kill_type;
   cur_attack_dmg = get_array(cur_attack_results_arr, target);
   if cur_attack_dmg != 0 then
      return cur_attack_dmg;

   if (target_cr_flags bwand CFLG_INVULN) != 0 then begin
      dmg = DMG_DODGE;
      return dmg;
   end

   if target == cur_combat_target then begin
      if combat_target_atk_result <= MISS then
         miss_local = 1;
   end
   // hit chance calculation start
   else if HitChance > 0 then begin

      // 5% guaranteed chance to hit
      if rnd > 4 then begin
         if is_critter(target) then hit_chance = get_ranged_chance_to_hit(attacker, target, laser_targets_count, laser_targets_count_multihex);

         if hit_chance <= 0 orElse (rnd > hit_chance) orElse rnd > 95 then begin
            miss_local = 1;
         end
      end
   end

   //if miss
   if miss_local > 0 then begin
      dmg = DMG_DODGE;
      return dmg;
   end
      //if hit
      else begin
      //Increase target_dr if it attacker has TRAIT_finesse
      if finesse then begin
         target_dr = target_dr + 30;
      end

      // if YAAM ammo active
      if YAAM_active > 0 then begin
         if ammo_dr_mod != 0 then begin
            target_dt = target_dt - ammo_dr_mod;

            if target_dt < 0 then begin
               target_dr = target_dr + target_dt * 10;
               target_dt = 0;
            end
         end
      end
      else
         target_dr += ammo_dr_mod;

      //guaranteed increase in laser armor-piercing when using an alternative firing mode
      if weapon_perk == PERK_weapon_penetrate then begin
         target_dt = target_dt * 0.1;
         target_dr = target_dr * 0.1;
      end
      else begin
         target_dt = target_dt * 0.2;
         target_dr = target_dr * 0.2;
      end



      if ((allow_critical > 0 andAlso target != cur_combat_target) orElse (target == real_orig_target andAlso combat_target_atk_result >= CRITICAL_HIT)) andAlso (crit_roll <= critical_chance orElse (sniper andAlso random(1,10) <= attacker_lu)) then begin
         crit_power = random(1, (100 + bonus_crit_power_roll));
         crit_mult = get_crit_mult(crit_power, target);
         flags = flags bwor DAM_CRITICAL;
         if gWeaponDamageType != DMG_emp then begin
            if crit_mult < 2 then begin
               target_dt = target_dt * 0.8;
               target_dr = target_dr * 0.8;
            end
            else begin
               if random(0,1) then begin
                  flags = flags bwor DAM_KNOCKED_DOWN;
               end
               target_dt = target_dt * 0.5;
               target_dr = target_dr * 0.5;
            end
         end
      end
      if target_dt < 0 then target_dt = 0;
      if target_dr > 90 then target_dr = 90;
      if target_dr < 0 then target_dr = 0;

      dmg = round(((weapon_dmg - target_dt) * (100 - target_dr) / 100.0) * crit_mult);

      if gLivingAnatomyBonus > 0 then begin
         kill_type = critter_kill_type(target);
         if kill_type != KILL_TYPE_alien_kills andAlso kill_type != KILL_TYPE_robot_kills then
            dmg += gLivingAnatomyBonus * living_anatomy;
      end

      if gWeaponDamageType == DMG_fire andAlso gPyromaniac_perk then
         dmg += gPyromaniac_perk * gPyromaniac_bonus;

      if dmg < min_dmg then begin
         dmg = DMG_ZERO;
      end
      else if flags > 0 then begin
         dmg = dmg + flags * DMG_FLAG_MULT;
      end
      return dmg;
   end
end

procedure calc_dmg(variable attacker, variable target, variable weapon_dmg, variable gWeaponDamageType, variable can_crit = 1) begin
   variable attacker_lu = get_critter_stat(attacker, STAT_lu);
   variable critical_chance = get_critter_stat(attacker, STAT_crit_chance);
   variable target_dt = get_critter_stat(target, STAT_dmg_thresh + gWeaponDamageType);
   variable target_dr = get_critter_stat(target, STAT_dmg_resist + gWeaponDamageType);
   variable rnd = random(0, 100);
   variable crit_roll = rnd;
   variable crit_power_roll;
   variable crit_mult = 1;
   variable min_dmg = 1;
   variable dmg;
   variable flags = DAM_HIT;
   variable target_cr_flags = get_proto_data(obj_pid(target), PROTO_CR_FLAGS);
   variable kill_type;

   if (target_cr_flags bwand CFLG_INVULN) != 0 then begin
      return DMG_DODGE;
   end
   kill_type = critter_kill_type(target);

   if weapon_dmg == 0 orElse (gWeaponDamageType == DMG_emp andAlso kill_type != KILL_TYPE_robot_kills) then begin
      return DMG_ZERO;
   end

   if finesse then begin
      target_dr = target_dr + 30;
   end

   if YAAM_active > 0 andAlso gWeaponDamageType != DMG_emp then begin
      if ammo_dr_mod != 0 then begin
         target_dt = target_dt - ammo_dr_mod;
         if target_dt < 0 then begin
            target_dr = target_dr + target_dt * 10;
            target_dt = 0;
         end
      end
   end
   else if gWeaponDamageType != DMG_emp then begin
      target_dr += ammo_dr_mod;
   end

   if weapon_perk == PERK_weapon_penetrate then begin
      target_dt = target_dt * 0.2;
   end

   if can_crit andAlso (crit_roll <= critical_chance orElse (sniper andAlso random(1, 10) <= attacker_lu)) then begin
      crit_power_roll = random(1, (100 + bonus_crit_power_roll));
      crit_mult = get_crit_mult(crit_power_roll, target);
      flags = flags bwor DAM_CRITICAL;

      if gWeaponDamageType != DMG_emp then begin
         if crit_mult >= 2 then begin
            if random(0, 1) then begin
               flags = flags bwor DAM_KNOCKED_DOWN;
            end
            if random(0, 1) then begin
               flags = flags bwor DAM_BYPASS;
               target_dt = target_dt * 0.2;
               target_dr = target_dr * 0.2;
            end
         end
      end
   end

   if target_dt < 0 then
      target_dt = 0;

   if target_dr > 90 andAlso gWeaponDamageType != DMG_emp then
      target_dr = 90;
   else if target_dr < 0 then
      target_dr = 0;

   dmg = round(((weapon_dmg - target_dt) * (100.0 - target_dr) / 100.0) * crit_mult);

   if gLivingAnatomyBonus > 0 then begin
      if kill_type != KILL_TYPE_alien_kills andAlso kill_type != KILL_TYPE_robot_kills then
         dmg += gLivingAnatomyBonus * living_anatomy;
   end

   if gWeaponDamageType == DMG_fire andAlso gPyromaniac_perk then
      dmg += gPyromaniac_perk * gPyromaniac_bonus;
   if dmg < min_dmg then begin
      return DMG_ZERO;
   end

   flags = flags * DMG_FLAG_MULT;

   return (dmg + flags);
end

procedure calc_dmg_gauss(variable attacker, variable target, variable lof_targets_count = 0, variable lof_targets_count_multihex = 0, variable lof_targets_count_missed = 0) begin
   variable attacker_lu = get_critter_stat(attacker, STAT_lu);
   variable critical_chance = get_critter_stat(attacker, STAT_crit_chance);
   variable target_dt = get_critter_stat(target, STAT_dmg_thresh);
   variable target_dr = get_critter_stat(target, STAT_dmg_resist);
   variable rnd = random(0, 100);
   variable crit_power;
   variable crit_roll = rnd;
   variable crit_mult = 1;
   variable min_dmg = 1;
   variable hit_chance;
   variable miss_local;
   variable flags = (DAM_HIT bwor DAM_BYPASS);
   variable dmg;
   variable target_cr_flags = get_proto_data(obj_pid(target), PROTO_CR_FLAGS);
   variable cur_attack_dmg;
   variable cur_combat_target = get_object_data(combat_data, C_ATTACK_TARGET);
   variable cur_target_num;
   variable cur_dmg_reduction_dt;
   variable cur_dmg_reduction;
   variable reduction_for_next_target = 0;
   variable weapon_dmg = gGaussWeaponDmg;
   variable kill_type = critter_kill_type(target);
   variable HitChance = 1;
   cur_attack_dmg = get_array(cur_attack_results_arr, target);
   if cur_attack_dmg != 0 then
      return cur_attack_dmg;

   if weapon_dmg == 0 orElse (gWeaponDamageType == DMG_emp andAlso kill_type != KILL_TYPE_robot_kills) then begin
      dmg = DMG_ZERO;
      return dmg;
   end

   if (target_cr_flags bwand CFLG_INVULN) != 0 then begin
      dmg = DMG_DODGE;
      return dmg;
   end

   if target == cur_combat_target then begin
      if combat_target_atk_result <= MISS then
         miss_local = 1;
   end
   // hit chance
   else if HitChance > 0 then begin
      // 5% guaranteed chance to hit
      if rnd > 4 then begin
         if is_critter(target) then hit_chance = get_ranged_chance_to_hit(attacker, target, lof_targets_count, lof_targets_count_multihex);

         if (rnd > hit_chance) orElse rnd > 95 then begin
            miss_local = 1;
         end
      end
   end

   //if miss
   if miss_local > 0 then begin
      dmg = DMG_DODGE;
      return dmg;
   end
   //if hit
   else begin
      //Increase target_dr if it attacker has TRAIT_finesse
      if finesse then begin
         target_dr = target_dr + 30;
      end

      // if YAAM ammo active
      if YAAM_active > 0 then begin
         if ammo_dr_mod != 0 then begin
            target_dt = target_dt - ammo_dr_mod;

            if target_dt < 0 then begin
               target_dr = target_dr + target_dt * 10;
               target_dt = 0;
            end
         end
      end
      else
         target_dr += ammo_dr_mod;

      if weapon_perk == PERK_weapon_penetrate orElse Sonora > 0 then begin
         target_dt = target_dt * 0.1;
         target_dr = target_dr * 0.1;
      end
      else begin
         target_dt = target_dt * 0.2;
         target_dr = target_dr * 0.2;
      end

      if ((allow_critical > 0 andAlso target != cur_combat_target) orElse (target == real_orig_target andAlso combat_target_atk_result >= CRITICAL_HIT)) andAlso (crit_roll <= critical_chance orElse (sniper andAlso random(1, 10) <= attacker_lu)) then begin
         crit_power = random(1, (100 + bonus_crit_power_roll));
         crit_mult = get_crit_mult(crit_power, target);
         flags = flags bwor DAM_CRITICAL;
         if crit_mult < 2 then begin
            target_dt = target_dt * 0.8;
            target_dr = target_dr * 0.8;
         end
         else begin
            if random(0, 1) then begin
               flags = flags bwor DAM_KNOCKED_DOWN;
            end
            target_dt = target_dt * 0.4;
            target_dr = target_dr * 0.4;
         end
      end

      if target_dt < 0 then target_dt = 0;
      if target_dr > 90 then target_dr = 90;
      if target_dr < 0 then target_dr = 0;

      dmg = round((((weapon_dmg) - target_dt) * (100 - target_dr) / 100.0) * crit_mult);

      if GaussDamageReductionPerTarget > 0 then begin
         cur_dmg_reduction_dt = 2 * target_dt;
         cur_dmg_reduction = 2 * target_dr;

         if cur_dmg_reduction < GaussDamageReductionPerTarget then begin
            cur_dmg_reduction = GaussDamageReductionPerTarget;
         end

         if gGaussWeaponDmg > 0 then begin
            reduction_for_next_target = gGaussInitialDmg * (cur_dmg_reduction / 100.0);
            gGaussWeaponDmg = gGaussWeaponDmg - reduction_for_next_target - cur_dmg_reduction_dt;

            if gGaussWeaponDmg < 0 then begin
               gGaussWeaponDmg = 0;
            end
         end
      end

      if dmg < min_dmg then begin
         dmg = DMG_ZERO;
      end
      else if flags > 0 then begin
         dmg = dmg + flags * DMG_FLAG_MULT;
      end

      if lof_targets_count == 1 orElse dmg > 0 then begin
         if gLivingAnatomyBonus > 0 then begin
            kill_type = critter_kill_type(target);
            if kill_type != KILL_TYPE_alien_kills andAlso kill_type != KILL_TYPE_robot_kills then
               dmg += gLivingAnatomyBonus * living_anatomy;
         end
         if gWeaponDamageType == DMG_fire andAlso gPyromaniac_perk then
            dmg += gPyromaniac_perk * gPyromaniac_bonus;
      end

      return dmg;
   end
end

procedure calc_dmg_plasma(variable attacker, variable target, variable distance, variable add_to_exort_arr = 0) begin
   variable attacker_lu = get_critter_stat(attacker, STAT_lu);
   variable critical_chance = get_critter_stat(attacker, STAT_crit_chance);
   variable target_dt = get_critter_stat(target, STAT_dmg_thresh_plasma);
   variable target_dr = get_critter_stat(target, STAT_dmg_resist_plasma);
   variable weapon_dmg = random(gWeaponMinDmg, gWeaponMaxDmg);
   variable rnd = random(0, 100);
   variable crit_power;
   variable crit_roll = rnd;
   variable crit_mult = 1;
   variable min_dmg = 1;
   variable hit_chance;
   variable flags = DAM_HIT;
   variable dmg;
   variable target_cr_flags = get_proto_data(obj_pid(target), PROTO_CR_FLAGS);
   variable cur_attack_dmg;
   variable cur_combat_target = get_object_data(combat_data, C_ATTACK_TARGET);
   variable disatance_dmg_mult;
   variable dmg_mult = 1;
   variable kill_type;
   cur_attack_dmg = get_array(cur_attack_results_arr, target);

   if cur_attack_dmg != 0 then
      return cur_attack_dmg;

   if (target_cr_flags bwand CFLG_INVULN) != 0 then begin
      dmg = DMG_ZERO;
      return dmg;
   end

   disatance_dmg_mult = (100.0 - PlasmaDamageReductionPerTile) / 100.0;

   if disatance_dmg_mult != 0 then begin
      if distance > 1 then
         dmg_mult = (disatance_dmg_mult ^ distance);
      if dmg_mult == 0 then
         dmg_mult = 1;
   end

   // TRAIT_finesse
   if finesse then begin
      target_dr = target_dr + 30;
   end

   if weapon_perk == PERK_weapon_penetrate then begin
      target_dt = target_dt * 0.2;
   end

   // YAAM
   if YAAM_active > 0 then begin
      if ammo_dr_mod != 0 then begin
         target_dt = target_dt - ammo_dr_mod;

         if target_dt < 0 then begin
            target_dr = target_dr + target_dt * 10;
            target_dt = 0;
         end
      end
   end
   else begin
      target_dr += ammo_dr_mod;
   end

   if ((allow_critical > 0 andAlso target != cur_combat_target) orElse (target == real_orig_target andAlso combat_target_atk_result >= CRITICAL_HIT)) andAlso (crit_roll <= critical_chance orElse (sniper andAlso random(1,10) <= attacker_lu)) then begin
      crit_power = random(1, (100 + bonus_crit_power_roll));
      crit_mult = get_crit_mult(crit_power, target);
      flags = flags bwor DAM_CRITICAL;

      if gWeaponDamageType != DMG_emp then begin
         if crit_mult < 2 then begin
            target_dt = target_dt * 0.8;
            target_dr = target_dr * 0.8;
         end
         else begin
            if random(0,1) then begin
               flags = flags bwor DAM_KNOCKED_DOWN;
            end
            target_dt = target_dt * 0.4;
            target_dr = target_dr * 0.4;
         end
      end
      if crit_mult > 2 then crit_mult = 2;
   end


   if target_dr > 90 then target_dr = 90;
   if target_dt < 0 then target_dt = 0;
   if target_dr < 0 then target_dr = 0;

   dmg = ceil(((weapon_dmg - target_dt) * (100 - target_dr) / 100.0) * dmg_mult * crit_mult);

   if gLivingAnatomyBonus > 0 then begin
      kill_type = critter_kill_type(target);
      if kill_type != KILL_TYPE_alien_kills andAlso kill_type != KILL_TYPE_robot_kills then
         dmg += gLivingAnatomyBonus * living_anatomy;
   end

   if gWeaponDamageType == DMG_fire andAlso gPyromaniac_perk then
      dmg += gPyromaniac_perk * gPyromaniac_bonus;

   if add_to_exort_arr > 0 then
      call add_to_export_arr(target, dmg);
   if dmg < min_dmg then begin
      dmg = DMG_ZERO;
   end
   else if flags > 0 then begin
      dmg = dmg + flags * DMG_FLAG_MULT;
   end

   return dmg;
end

procedure re_count(variable counter) begin
   variable counter_floor = floor(counter);
   if (floor(remainder + counter) > counter_floor) then begin
      remainder = remainder + counter - floor(remainder + counter);
      return floor(counter + 1);
   end
   else begin
      remainder = remainder + (counter - counter_floor);
      return counter_floor;
   end
end

procedure get_targets_on_projectile_path_line_gauss(variable attacker, variable target, variable range, variable is_wide = 0) begin
   variable weapon_dmg = random(gWeaponMinDmg, gWeaponMaxDmg);
   variable attacker_tile = tile_num(attacker);
   variable attacker_team = has_trait(TRAIT_OBJECT, attacker, OBJECT_TEAM_NUM);
   variable target_tile = tile_num(target);
   variable orig_target_tile = target_tile;
   variable line_elevation = elevation(attacker);
   variable attacker_rotation_to_target = rotation_to_tile(attacker_tile, target_tile);
   variable start_tile = tile_num_in_direction(attacker_tile, attacker_rotation_to_target, 1);
   variable temp_dist = tile_distance(start_tile, target_tile);
   variable temp_rot = rotation_to_tile(start_tile, target_tile);
   variable check_tile;
   variable temp_tile_in_dir;
   variable temp_dist_in_dir;
   variable temp_rot_in_dir;
   variable side,counter,tile_count;
   variable tile_blocking_obj;
   variable new_target_arr;
   variable new_target;
   variable new_target_team;
   variable new_target_cur_hp;
   variable dmg_with_flags;
   variable end_tile;
   variable lof_targets_count;
   variable lof_targets_count_multihex;
   variable lof_targets_count_missed;
   variable object_ignored;
   variable is_behind_target;
   variable target_index;
   variable first_obj;
   variable arr_len;
   variable exit_all;
   gauss_new_main_target = 0;
   if array_exists(Line_targets_array) then
      clear_array(Line_targets_array);
   else
      Line_targets_array = create_array_map;

   //point blank range and right above/below on the vertical
   if temp_dist <= 0 orElse (temp_rot == 3 andAlso attacker_rotation_to_target == 2) orElse
      (temp_rot == 5 andAlso attacker_rotation_to_target == 0) then begin

      start_tile = attacker_tile;
      temp_dist = tile_distance(start_tile, target_tile);
      temp_rot = rotation_to_tile(start_tile, target_tile);
   end
   else if temp_dist == 1 then begin
      if ((temp_rot == 2 orElse temp_rot == 0) andAlso attacker_rotation_to_target == 1) orElse
         ((temp_rot == 3 orElse temp_rot == 5) andAlso attacker_rotation_to_target == 4) then begin

         target_tile = tile_num_in_direction(target_tile, temp_rot, 1);
         target_tile = tile_num_in_direction(target_tile, attacker_rotation_to_target, 1);
         temp_dist = tile_distance(start_tile, target_tile);
         temp_rot = rotation_to_tile(start_tile, target_tile);
      end
   end

   if temp_rot == 4 then begin
      if tile_distance(tile_num_in_direction(start_tile, temp_rot, temp_dist), target_tile) > tile_distance(tile_num_in_direction(start_tile, 5, temp_dist), target_tile) then
         temp_rot = 5;
      else if tile_distance(tile_num_in_direction(start_tile, temp_rot, temp_dist), target_tile) > tile_distance(tile_num_in_direction(start_tile, 3, temp_dist), target_tile) then
         temp_rot = 3;
   end
   else if temp_rot == 1 then begin
      if tile_distance(tile_num_in_direction(start_tile, temp_rot, temp_dist), target_tile) > tile_distance(tile_num_in_direction(start_tile, 0, temp_dist), target_tile) then
         temp_rot = 0;
      else if tile_distance(tile_num_in_direction(start_tile, temp_rot, temp_dist), target_tile) > tile_distance(tile_num_in_direction(start_tile, 2, temp_dist), target_tile) then
         temp_rot = 2;
   end

   temp_tile_in_dir = tile_num_in_direction(start_tile, temp_rot, temp_dist);
   temp_dist_in_dir = tile_distance(temp_tile_in_dir, target_tile);
   temp_rot_in_dir = rotation_to_tile(temp_tile_in_dir, target_tile);

   remainder = 0;
   tile_count = 0;
   temp_dist *= 1.0;

   if temp_dist_in_dir == 0 then begin
      side = 0;
   end
   else begin
      if temp_rot_in_dir == (temp_rot + 2) % 6 then begin
         side = 1;
      end
      else begin
         if temp_rot_in_dir == (temp_rot + 4) % 6 then begin
            side = 5;
         end
      end
   end
   if side != 0 then begin
      counter = temp_dist / temp_dist_in_dir / 1.5;
   end
   else begin
      counter = 50.0;
   end

   while tile_count < range andAlso exit_all == 0 do begin
      if counter >= 1.0 then begin
         if check_tile == 0 then
            check_tile = start_tile;
         else
            check_tile = tile_num_in_direction(check_tile, temp_rot, 1);
         object_ignored = 0;
         counter -= 1.0;
         end_tile = check_tile;
         //create_object(33555753, check_tile, line_elevation);
      end
      else begin
         check_tile = tile_num_in_direction(check_tile, ((temp_rot+side) % 6), 1);
         counter = temp_dist / temp_dist_in_dir + re_count(counter) - 1.0;
         if is_wide > 0 then begin
            object_ignored = 0;
            end_tile = check_tile;
         end
         else
            object_ignored = 1;
         //create_object(205, check_tile, line_elevation);
      end
      tile_count += 1;

      // check for new targets
      if object_ignored <= 0 then begin
         new_target_arr = tile_get_objs(check_tile, line_elevation);
      end
      else if check_tile != orig_target_tile then
         continue;

      if check_tile == orig_target_tile then begin
         arr_len = len_array(new_target_arr);
         if arr_len > 0 then begin
            first_obj = get_array(new_target_arr, 0);
            if first_obj != target then begin
               target_index = scan_array(new_target_arr, target);
               set_array(new_target_arr, 0, target);
               if target_index > 0 then begin
                  set_array(new_target_arr, target_index, first_obj);
               end
               else if target_index == -1 then begin
                  resize_array(new_target_arr, arr_len + 1);
                  set_array(new_target_arr, arr_len, first_obj);
               end
            end
         end
         else begin
            new_target_arr = temp_array_list(1);
            set_array(new_target_arr, 0, target);
         end
      end

      foreach new_target in new_target_arr begin
         if new_target > 0 andAlso new_target != attacker andAlso (new_target == target orElse (get_flags(new_target) bwand FLAG_SHOOTTHRU == 0) orElse obj_type(new_target) == OBJ_TYPE_CRITTER) then begin
            if new_target == target then
               is_behind_target = 1;
            //check lOS
            else begin
               if not(obj_is_visible_flag(new_target)) orElse is_in_array(new_target, Line_targets_array) then
                  continue;

               tile_blocking_obj = get_first_non_critter_block_shoot(attacker, check_tile);
               if tile_blocking_obj > 0 then begin
                  last_target_on_a_line = tile_blocking_obj;
                  if is_behind_target > 0 then begin
                     exit_all = 1;
                     break;
                  end
                  else
                     continue;
               end
            end


            if obj_type(new_target) == OBJ_TYPE_CRITTER andAlso not(is_dead(new_target)) andAlso get_array(death_array,new_target) <= 0 then begin
               new_target_cur_hp = get_critter_stat(new_target, STAT_current_hp);
               if new_target_cur_hp <= 0 then
                  continue;

               if target == real_orig_target then begin
                  new_target_team = has_trait(TRAIT_OBJECT, new_target, OBJECT_TEAM_NUM);
                  if new_target_team == enemy_team then begin
                     enemy_targets_count += 1;
                  end
                  else if attacker_team == new_target_team then begin
                     friendly_targets_count += 1;
                  end
               end

               if not(is_dead(new_target)) andAlso get_array(death_array,new_target) <= 0 then begin
                  dmg_with_flags = calc_dmg_gauss(attacker, new_target, lof_targets_count, lof_targets_count_multihex, lof_targets_count_missed);
                  set_array(Line_targets_array, new_target, dmg_with_flags);
               end
               else
                  dmg_with_flags = DMG_IGNORE;



            end
            else begin
               dmg_with_flags = -1;
               //terminate procedure if reached original non critter non FLAG_SHOOTTHRU target
               if new_target == target orElse is_behind_target > 0 then begin
                  last_target_on_a_line = new_target;
                  if get_flags(new_target) bwand FLAG_SHOOTTHRU == 0 then begin
                     //set_array(Line_targets_array, new_target, DMG_ZERO);
                     exit_all = 1;
                     break;
                  end
               end
            end
            lof_targets_count += 1;
            if dmg_with_flags < 0 then
               lof_targets_count_missed += 1;

            if is_multihex(new_target) then
               lof_targets_count_multihex += 1;

            //set new main_target if the damage is not enough to penetrate all targets
            if dmg_with_flags <= DMG_ZERO then begin
               exit_all = 1;
               break;
            end
         end
      end
      if exit_all then
         break;
   end

   if is_behind_target <= 0 andAlso gauss_new_main_target <= 0 then begin
      gauss_new_main_target = last_target_on_a_line;
      if gauss_new_main_target == attacker then
         gauss_new_main_target = 0;
   end

   Line_end_tile = end_tile;
   return end_tile;
end

procedure get_targets_on_projectile_path_line_laser(variable attacker, variable target, variable range, variable is_wide = 0) begin
   variable weapon_dmg = random(gWeaponMinDmg, gWeaponMaxDmg);
   variable attacker_tile = tile_num(attacker);
   variable attacker_team = has_trait(TRAIT_OBJECT, attacker, OBJECT_TEAM_NUM);
   variable target_tile = tile_num(target);
   variable orig_target_tile = target_tile;
   variable line_elevation = elevation(attacker);
   variable attacker_rotation_to_target = rotation_to_tile(attacker_tile, target_tile);
   //variable start_tile = tile_num_in_direction(attacker_tile, attacker_rotation_to_target, 1);// OLD
   variable start_tile = attacker_tile;
   variable temp_dist = tile_distance(start_tile, target_tile);
   variable temp_rot = rotation_to_tile(start_tile, target_tile);
   variable check_tile;
   variable temp_tile_in_dir;
   variable temp_dist_in_dir;
   variable temp_rot_in_dir;
   variable side,counter,tile_count;
   variable tile_blocking_obj;
   variable new_target_arr;
   variable new_target;
   variable new_target_team;
   variable new_target_cur_hp;
   variable dmg_with_flags;
   variable end_tile;
   variable is_behind_target;
   variable lof_targets_count;
   variable lof_targets_count_multihex;
   variable lof_targets_count_missed;
   variable object_ignored;
   variable is_laser_alt_fire;
   variable last_blocker;
   variable arr_len;
   variable first_obj;
   variable target_index;
   variable exit_all;
   variable force_dodge_targets_before_main;
   laser_new_main_target = 0;

   if laser_max_targets > laser_cur_ammo then
      laser_max_targets = laser_cur_ammo;

   if array_exists(Line_targets_array) then
      clear_array(Line_targets_array);
   else
      Line_targets_array = create_array_map;

   //point blank range and right above/below on the vertical // OLD
   //if temp_dist <= 0 orElse (temp_rot == 3 andAlso attacker_rotation_to_target == 2) orElse
      //(temp_rot == 5 andAlso attacker_rotation_to_target == 0) then begin
//
      //start_tile = attacker_tile;
      //temp_dist = tile_distance(start_tile, target_tile);
      //temp_rot = rotation_to_tile(start_tile, target_tile);
   //end
   //else if temp_dist == 1 then begin
      //if ((temp_rot == 2 orElse temp_rot == 0) andAlso attacker_rotation_to_target == 1) orElse
         //((temp_rot == 3 orElse temp_rot == 5) andAlso attacker_rotation_to_target == 4) then begin
//
         //target_tile = tile_num_in_direction(target_tile, temp_rot, 1);
         //target_tile = tile_num_in_direction(target_tile, attacker_rotation_to_target, 1);
         //temp_dist = tile_distance(start_tile, target_tile);
         //temp_rot = rotation_to_tile(start_tile, target_tile);
      //end
   //end

   if temp_rot == 4 then begin
      if tile_distance(tile_num_in_direction(start_tile, temp_rot, temp_dist), target_tile) > tile_distance(tile_num_in_direction(start_tile, 5, temp_dist), target_tile) then
         temp_rot = 5;
      else if tile_distance(tile_num_in_direction(start_tile, temp_rot, temp_dist), target_tile) > tile_distance(tile_num_in_direction(start_tile, 3, temp_dist), target_tile) then
         temp_rot = 3;
   end
   else if temp_rot == 1 then begin
      if tile_distance(tile_num_in_direction(start_tile, temp_rot, temp_dist), target_tile) > tile_distance(tile_num_in_direction(start_tile, 0, temp_dist), target_tile) then
         temp_rot = 0;
      else if tile_distance(tile_num_in_direction(start_tile, temp_rot, temp_dist), target_tile) > tile_distance(tile_num_in_direction(start_tile, 2, temp_dist), target_tile) then
         temp_rot = 2;
   end

   temp_tile_in_dir = tile_num_in_direction(start_tile, temp_rot, temp_dist);
   temp_dist_in_dir = tile_distance(temp_tile_in_dir, target_tile);
   temp_rot_in_dir = rotation_to_tile(temp_tile_in_dir, target_tile);

   remainder = 0;
   tile_count = 0;
   temp_dist *= 1.0;

   if temp_dist_in_dir == 0 then begin
      side = 0;
   end
   else begin
      if temp_rot_in_dir == (temp_rot + 2) % 6 then begin
         side = 1;
      end
      else begin
         if temp_rot_in_dir == (temp_rot + 4) % 6 then begin
            side = 5;
         end
      end
   end
   if side != 0 then begin
      counter = temp_dist / temp_dist_in_dir / 1.5;
   end
   else begin
      counter = 50.0;
   end

   while tile_count < range andAlso exit_all == 0 do begin
      if counter >= 1.0 then begin
         if check_tile == 0 then
            check_tile = start_tile;
         else
            check_tile = tile_num_in_direction(check_tile, temp_rot, 1);
         object_ignored = 0;
         counter -= 1.0;
         end_tile = check_tile;
         //create_object(33555753, check_tile, line_elevation);
      end
      else begin
         check_tile = tile_num_in_direction(check_tile, ((temp_rot+side) % 6), 1);
         counter = temp_dist / temp_dist_in_dir + re_count(counter) - 1.0;
         if is_wide > 0 then begin
            object_ignored = 0;
            end_tile = check_tile;
         end
         else
            object_ignored = 1;
         //create_object(205, check_tile, line_elevation);
      end
      tile_count += 1;

      // check for new targets
      if object_ignored <= 0 then begin
         new_target_arr = tile_get_objs(check_tile, line_elevation);
      end
      else if check_tile != orig_target_tile then
         continue;

      if check_tile == orig_target_tile then begin
         arr_len = len_array(new_target_arr);
         if arr_len > 0 then begin
            first_obj = get_array(new_target_arr, 0);
            if first_obj != target then begin
               target_index = scan_array(new_target_arr, target);
               set_array(new_target_arr, 0, target);
               if target_index > 0 then begin
                  set_array(new_target_arr, target_index, first_obj);
               end
               else if target_index == -1 then begin
                  resize_array(new_target_arr, arr_len + 1);
                  set_array(new_target_arr, arr_len, first_obj);
               end
            end
         end
         else begin
            new_target_arr = temp_array_list(1);
            set_array(new_target_arr, 0, target);
         end
      end

      foreach new_target in new_target_arr begin
         if new_target > 0 andAlso new_target != attacker andAlso (new_target == target orElse (get_flags(new_target) bwand FLAG_SHOOTTHRU == 0) orElse obj_type(new_target) == OBJ_TYPE_CRITTER) then begin
            //no lOS check for main target
            if new_target == target then begin
               force_dodge_targets_before_main = 0;
               is_behind_target = 1;
            end

            //check lOS
            else begin
               if not(obj_is_visible_flag(new_target)) orElse is_in_array(new_target, Line_targets_array) then
                  continue;

               last_blocker = get_first_non_critter_block_shoot(attacker, check_tile);
               if last_blocker > 0 then begin
                  last_target_on_a_line = last_blocker;
                  if is_behind_target > 0 then begin
                     exit_all = 1;
                     break;
                  end
                  else
                     continue;
               end
            end

            if obj_type(new_target) == OBJ_TYPE_CRITTER then begin
               new_target_cur_hp = get_critter_stat(new_target, STAT_current_hp);
               if new_target_cur_hp <= 0 orElse is_dead(new_target) orElse get_array(death_array,new_target) > 0 then
                  continue;

               if target == real_orig_target then begin
                  new_target_team = has_trait(TRAIT_OBJECT, new_target, OBJECT_TEAM_NUM);
                  if new_target_team == enemy_team then begin
                     enemy_targets_count += 1;
                  end
                  else if attacker_team == new_target_team then begin
                     friendly_targets_count += 1;
                  end
               end
               if force_dodge_targets_before_main <= 0 then
                  dmg_with_flags = calc_dmg_laser(attacker, new_target, lof_targets_count, lof_targets_count_multihex);
               else
                  dmg_with_flags = DMG_DODGE;

               lof_targets_count += 1;
               set_array(Line_targets_array, new_target, dmg_with_flags);

            end
            else begin
               //terminate procedure if reached non critter non FLAG_SHOOTTHRU target
               if new_target == target orElse is_behind_target > 0 then begin
                  last_target_on_a_line = new_target;
                  if new_target == target orElse get_flags(new_target) bwand FLAG_SHOOTTHRU == 0 then begin
                     lof_targets_count += 1;
                     exit_all = 1;
                  end
               end
            end

            if dmg_with_flags < 0 then
               lof_targets_count_missed += 1;

            if is_multihex(new_target) then
               lof_targets_count_multihex += 1;

            if new_target == real_orig_target then begin
               if laser_max_targets > lof_targets_count then
                  laser_max_targets = lof_targets_count;

               last_target_on_a_line = real_orig_target;
            end
            //set new main_target if the damage is not enough to penetrate all targets
            if dmg_with_flags <= DMG_ZERO then begin
               if get_new_targets > 0 andAlso is_behind_target <= 0 then begin
                  dmg_with_flags = DMG_DODGE;
                  lof_targets_count_missed += 1;
                  set_array(Line_targets_array, new_target, dmg_with_flags);
                  force_dodge_targets_before_main = 1;
                  continue;
               end
               laser_new_main_target = new_target;
               exit_all = 1;
               break;
            end
            //terminate procedure if reached maximum additional targets (ammo/target cap)
            if dmg_with_flags > 0 andAlso (lof_targets_count - lof_targets_count_missed) >= laser_max_targets then begin
               if get_new_targets > 0 andAlso is_behind_target <= 0 then begin
                  dmg_with_flags = DMG_DODGE;
                  lof_targets_count_missed += 1;
                  set_array(Line_targets_array, new_target, dmg_with_flags);
                  force_dodge_targets_before_main = 1;
                  continue;
               end
               laser_new_main_target = new_target;
               exit_all = 1;
               break;
            end
         end
      end
      if exit_all then
         break;
   end

   if is_behind_target <= 0 andAlso laser_new_main_target <= 0 then begin
      laser_new_main_target = last_target_on_a_line;
      if laser_new_main_target == attacker then
         laser_new_main_target = 0;
   end

   if laser_max_targets > lof_targets_count then
      laser_max_targets = lof_targets_count;

   Line_end_tile = end_tile;
   return end_tile;
end

procedure get_last_tile_on_line(variable start_tile,variable tile_2,variable max_distance) begin
   variable temp_rot = rotation_to_tile(start_tile, tile_2);
   variable temp_dist = tile_distance(start_tile, tile_2);
   variable temp_tile_in_dir = tile_num_in_direction(start_tile, temp_rot, temp_dist);
   variable temp_dist_in_dir = tile_distance(temp_tile_in_dir, tile_2);
   variable temp_rot_in_dir = rotation_to_tile(temp_tile_in_dir, tile_2);
   variable check_tile = start_tile;
   variable side;
   variable tile_count;
   variable last_tile;
   variable counter;
   remainder = 0;
   if temp_dist_in_dir == 0 then begin
      side = temp_dist_in_dir;
   end
   else begin
      if temp_rot_in_dir == (temp_rot + 2) % 6 then begin
         side = 1;
      end
      else begin
         if temp_rot_in_dir == (temp_rot + 4) % 6 then begin
            side = 5;
         end
      end
   end
   if (side != 0) then begin
      counter = (temp_dist * 1.0) / temp_dist_in_dir / 2.0;
   end
   else begin
      counter = 100.0;
   end
   while (tile_count < max_distance) do begin
      tile_count += 1;
      if (counter >= 1.0) then begin
         check_tile = tile_num_in_direction(check_tile, temp_rot, 1);
         counter = counter - 1.0;
      end
      else begin
         check_tile = tile_num_in_direction(check_tile, (temp_rot + side) % 6, 1);
         counter = ((temp_dist * 1.0) / temp_dist_in_dir) + re_count(counter) - 1.0;
      end
   end
   last_tile = check_tile;
   return last_tile;
end

procedure set_shootthru_flag_for_obj(variable obj) begin
   variable obj_flags;
   variable obj_mask;
   if not(array_exists(shootthru_obj_array)) then
      shootthru_obj_array = create_array_map;


   obj_flags = get_flags(obj);
   if (obj_flags bwand FLAG_SHOOTTHRU) == 0 then begin
      obj_mask = get_array(shootthru_obj_array, obj);
      if obj_mask != 0 then
         obj_mask = obj_mask bwor MASK_NO_SHOOTTHRU;
      else
         obj_mask = MASK_NO_SHOOTTHRU;
      set_array(shootthru_obj_array, obj, obj_mask);
      set_flags(obj, obj_flags bwor FLAG_SHOOTTHRU);
   end
   shootthru_was_set = 1;
end

procedure remove_added_flag_for_objs begin
   variable obj;
   variable mask;

   if shootthru_was_set > 0 then begin
      foreach (obj:mask in shootthru_obj_array) begin
         if mask == 0 then
            continue;

         if mask != 0 then begin
            set_flags(obj, get_flags(obj) bwand mask);
         end
      end
      shootthru_was_set = 0;
      clear_array(shootthru_obj_array);
   end
end


//get targets on "WIDE" line using obj_blocking_line
procedure get_targets_on_wide_line_gauss(variable attacker, variable target, variable range) begin
   variable atk_tile = tile_num(attacker);
   variable target_tile = tile_num(target);
   variable orig_target_tile = target_tile;
   variable line_elevation = elevation(attacker);
   variable rot_atk_to_tar = rotation_to_tile(atk_tile, target_tile);
   variable bullet_start_tile = tile_num_in_direction(atk_tile, rot_atk_to_tar, 1);
   variable distant_target_tile;
   variable new_target_cur_hp;
   variable blocking_obj;
   variable count;
   variable dmg;
   variable new_target_team;
   variable attacker_team = has_trait(TRAIT_OBJECT, attacker, OBJECT_TEAM_NUM);
   variable lof_targets_count;
   variable lof_targets_count_multihex;
   variable lof_targets_count_missed;
   variable is_behind_target;
   variable end_tile;
   variable force_dodge_targets_before_main;
   variable new_target_arr;
   variable arr_len;
   variable first_obj;
   variable check_tile;
   variable target_index;
   variable new_target;
   variable skip_tile;
   variable exit_all;
   variable cur_distance;
   variable last_distance = -1;
   variable tile_is_blocked;
   variable target_distance = tile_distance(atk_tile, target_tile);
   variable real_orig_target_tile = tile_num(real_orig_target);
   variable real_orig_target_distance = tile_distance(atk_tile, real_orig_target_tile);
   variable hit_chance;
   variable second_tile;
   variable weapon_dmg;
   if gGaussInitialDmg < 0 then begin
      weapon_dmg = random(gWeaponMinDmg, gWeaponMaxDmg);
      if Sonora > 0 andAlso weapon_dmg < 30 then
         weapon_dmg += random(5, 10);
   end
   else
      weapon_dmg = gGaussInitialDmg;

   gGaussWeaponDmg = weapon_dmg;
   gGaussInitialDmg = weapon_dmg;

   gauss_new_main_target = 0;

   second_tile = target_tile;
   if array_exists(Line_targets_array) then begin
      if target != real_orig_target andAlso target_distance < 4 andAlso target_distance < real_orig_target_distance then begin
         second_tile = real_orig_target_tile;
      end
      clear_array(Line_targets_array);
   end else begin
      Line_targets_array = create_array_map;
   end

   if (range bwand 1) > 0 then
      range += 1;

   distant_target_tile = tile_num_beyond(atk_tile, second_tile, range);
   end_tile = distant_target_tile;

   blocking_obj = obj_blocking_tile(bullet_start_tile, line_elevation, BLOCKING_TYPE_SHOOT);
   if blocking_obj == 0 then begin
      blocking_obj = obj_blocking_line(attacker, target_tile, BLOCKING_TYPE_SHOOT);
   end
   if blocking_obj == 0 then begin
      blocking_obj = target;
   end

   while blocking_obj andAlso not exit_all do begin
      check_tile = tile_num(blocking_obj);
      skip_tile = 0;
      cur_distance = tile_distance(atk_tile, check_tile);

      if cur_distance > target_distance andAlso is_behind_target <= 0 then begin
         check_tile = orig_target_tile;
      end else if (cur_distance <= 1 orElse cur_distance > range) andAlso check_tile != bullet_start_tile andAlso check_tile != orig_target_tile then begin
         skip_tile = 1;
      end

      new_target_arr = tile_get_objs(check_tile, line_elevation);

      if check_tile == orig_target_tile then begin
         arr_len = len_array(new_target_arr);
         if arr_len > 0 then begin
            first_obj = get_array(new_target_arr, 0);
            if first_obj != target then begin
               target_index = scan_array(new_target_arr, target);
               set_array(new_target_arr, 0, target);
               if target_index > 0 then begin
                  set_array(new_target_arr, target_index, first_obj);
               end else if target_index == -1 then begin
                  resize_array(new_target_arr, arr_len + 1);
                  set_array(new_target_arr, arr_len, first_obj);
               end
            end
         end else begin
            new_target_arr = temp_array_list(1);
            set_array(new_target_arr, 0, target);
         end
      end else begin
         if last_distance > cur_distance then begin
            skip_tile = 1;
         end
      end

      last_distance = cur_distance;

      foreach new_target in new_target_arr begin
         if new_target > 0 andAlso new_target != attacker andAlso (new_target == target orElse (get_flags(new_target) bwand FLAG_SHOOTTHRU == 0) orElse obj_type(new_target) == OBJ_TYPE_CRITTER) then begin
            if new_target == target then begin
               force_dodge_targets_before_main = 0;
               is_behind_target = 1;
               gGaussWeaponDmgCombatTarget = round(gGaussWeaponDmg);
            end else begin
               if not(obj_is_visible_flag(new_target)) orElse is_in_array(new_target, Line_targets_array) then
                  continue;

               if skip_tile > 0 then begin
                  call set_shootthru_flag_for_obj(new_target);
                  continue;
               end

               //tile_is_blocked = get_first_non_critter_block_shoot(attacker, check_tile);
               if tile_is_blocked > 0 then begin
                  last_target_on_a_line = new_target;
                  skip_tile = 1;
                  if is_behind_target > 0 then begin
                     tile_is_blocked = get_first_non_critter_block_shoot(attacker, distant_target_tile);
                     if tile_is_blocked > 0 then begin
                        last_target_on_a_line = tile_is_blocked;
                        end_tile = tile_num(tile_is_blocked);
                     end
                     else
                        end_tile = check_tile;
                     exit_all = 1;
                     break;
                  end else begin
                     call set_shootthru_flag_for_obj(new_target);
                     continue;
                  end
               end
            end

            if obj_type(new_target) == OBJ_TYPE_CRITTER then begin
               new_target_cur_hp = get_critter_stat(new_target, STAT_current_hp);
               if new_target_cur_hp <= 0 orElse is_dead(new_target) orElse get_array(death_array, new_target) > 0 then
                  continue;

               if target == real_orig_target then begin
                  new_target_team = has_trait(TRAIT_OBJECT, new_target, OBJECT_TEAM_NUM);
                  if new_target_team == enemy_team then begin
                     enemy_targets_count += 1;
                  end else if attacker_team == new_target_team then begin
                     friendly_targets_count += 1;
                  end
               end

               //if array_ended <= 0 then begin
                  if force_dodge_targets_before_main <= 0 then begin
                     dmg = calc_dmg_gauss(attacker, new_target, lof_targets_count, lof_targets_count_multihex, lof_targets_count_missed);
                  end else begin
                     dmg = DMG_DODGE;
                  end

                  if dmg > 0 orElse dmg == DMG_ZERO then begin
                     last_target_on_a_line = new_target;
                  end

                  set_array(Line_targets_array, new_target, dmg);
               //end else begin
                  //dmg = DMG_IGNORE;
               //end

               lof_targets_count += 1;
            end else begin
               //terminate procedure if reached non critter non FLAG_SHOOTTHRU target
               if new_target == target orElse is_behind_target > 0 then begin
                  lof_targets_count += 1;
                  //if array_ended <= 0 then begin
                     last_target_on_a_line = new_target;
                     if get_flags(new_target) bwand FLAG_SHOOTTHRU == 0 then begin
                        exit_all = 1;
                     end else if new_target == target then begin
                        hit_chance = get_ranged_chance_to_hit(attacker, target, (lof_targets_count - 1), lof_targets_count_multihex);
                        if hit_chance > 0 andAlso hit_chance >= random(0, 100) then begin
                           exit_all = 1;
                        end
                     end
                     if exit_all then
                        end_tile = check_tile;
                  //end
               end
            end

            if dmg < 0 andAlso dmg != DMG_ZERO then begin
               lof_targets_count_missed += 1;
            end

            if is_multihex(new_target) then begin
               lof_targets_count_multihex += 1;
            end

            //set new main_target if the damage is not enough to penetrate all targets
            if dmg == DMG_ZERO then begin
               if get_new_targets > 0 andAlso is_behind_target <= 0 andAlso new_target != target then begin
                  dmg = DMG_DODGE;
                  lof_targets_count_missed += 1;
                  set_array(Line_targets_array, new_target, dmg);
                  continue;
               end

               if is_behind_target <= 0 then
                 gauss_new_main_target = new_target;
               //if is_behind_target <= 0 andAlso target == real_orig_target then begin
                  //array_ended = check_tile;
               //end else begin
                  end_tile = check_tile;
                  exit_all = 1;
                  break;
               //end
            end

         end
         call set_shootthru_flag_for_obj(new_target);
      end

      if exit_all then begin
         break;
      end

      count += 1;
      if count > 50 then begin
         break;
      end
      blocking_obj = obj_blocking_line(attacker, distant_target_tile, BLOCKING_TYPE_SHOOT);
   end

   if is_behind_target <= 0 andAlso gauss_new_main_target <= 0 then begin
      gauss_new_main_target = last_target_on_a_line;
      if gauss_new_main_target == attacker then begin
         gauss_new_main_target = 0;
      end
   end
   if gauss_new_main_target > 0 then
      gSoundHitTarget = gauss_new_main_target;
   else
      gSoundHitTarget = last_target_on_a_line;

   if is_behind_target <= 0 then
      gGaussWeaponDmgCombatTarget = 0;

   Line_end_tile = end_tile;
   call remove_added_flag_for_objs;
   return end_tile;
end

///get targets on "WIDE" line using obj_blocking_line
procedure get_targets_on_wide_line_laser(variable attacker, variable target, variable range) begin
   variable atk_tile = tile_num(attacker);
   variable target_tile = tile_num(target);
   variable orig_target_tile = target_tile;
   variable line_elevation = elevation(attacker);
   variable rot_atk_to_tar = rotation_to_tile(atk_tile, target_tile);
   variable bullet_start_tile = tile_num_in_direction(atk_tile, rot_atk_to_tar, 1);
   variable distant_target_tile;
   variable new_target_cur_hp;
   variable blocking_obj;
   variable count;
   variable dmg_with_flags;
   variable new_target_team;
   variable attacker_team = has_trait(TRAIT_OBJECT, attacker, OBJECT_TEAM_NUM);
   variable lof_targets_count;
   variable lof_targets_count_multihex;
   variable lof_targets_count_missed;
   variable laser_new_target_array_len;
   variable is_behind_target;
   variable end_tile;
   variable force_dodge_targets_before_main;
   variable new_target_arr;
   variable arr_len;
   variable first_obj;
   variable check_tile;
   variable target_index;
   variable new_target;
   variable skip_tile;
   variable exit_all;
   //variable set_critters_flag = restore_shootthru_flag_for_critters;
   variable cur_distance;
   variable last_distance = -1;
   variable tile_is_blocked;
   variable target_distance = tile_distance(atk_tile, target_tile);
   variable real_orig_target_tile = tile_num(real_orig_target);
   variable real_orig_target_distance  = tile_distance(atk_tile, real_orig_target_tile);
   variable hit_chance;
   variable array_ended;
   variable second_tile;

   laser_new_main_target = 0;

   if laser_max_targets > laser_cur_ammo then
      laser_max_targets = laser_cur_ammo;

   second_tile = target_tile;
   if array_exists(Line_targets_array) then begin
      if target != real_orig_target andAlso target_distance < 4 andAlso target_distance < real_orig_target_distance then begin
         second_tile = real_orig_target_tile;
      end

      clear_array(Line_targets_array);
   end
   else
      Line_targets_array = create_array_map;

   if (range bwand 1) > 0 then
      range += 1;

   distant_target_tile = tile_num_beyond(atk_tile, second_tile, range);
   end_tile = distant_target_tile;

   blocking_obj = obj_blocking_tile(bullet_start_tile, line_elevation, BLOCKING_TYPE_SHOOT);

   if blocking_obj == 0 then
      blocking_obj = obj_blocking_line(attacker, target_tile, BLOCKING_TYPE_SHOOT);

   if blocking_obj == 0 then
      blocking_obj = target;

   while blocking_obj andAlso not exit_all do begin
      check_tile = tile_num(blocking_obj);
      skip_tile = 0;
      cur_distance = tile_distance(atk_tile, check_tile);
      if cur_distance > target_distance andAlso is_behind_target <= 0 then
         check_tile = orig_target_tile;
      else if (cur_distance <= 1 orElse cur_distance > range) andAlso check_tile != bullet_start_tile andAlso check_tile != orig_target_tile then
         skip_tile = 1;

      new_target_arr = tile_get_objs(check_tile, line_elevation);

      if check_tile == orig_target_tile then begin
         arr_len = len_array(new_target_arr);
         if arr_len > 0 then begin
            first_obj = get_array(new_target_arr, 0);
            if first_obj != target then begin
               target_index = scan_array(new_target_arr, target);
               set_array(new_target_arr, 0, target);
               if target_index > 0 then begin
                  set_array(new_target_arr, target_index, first_obj);
               end
               else if target_index == -1 then begin
                  resize_array(new_target_arr, arr_len + 1);
                  set_array(new_target_arr, arr_len, first_obj);
               end
            end
         end
         else begin
            new_target_arr = temp_array_list(1);
            set_array(new_target_arr, 0, target);
         end
      end
      else begin
         if last_distance > cur_distance then
            skip_tile = 1;
      end

      last_distance = cur_distance;

      foreach new_target in new_target_arr begin
         if new_target > 0 andAlso new_target != attacker andAlso (new_target == target orElse (get_flags(new_target) bwand FLAG_SHOOTTHRU == 0) orElse obj_type(new_target) == OBJ_TYPE_CRITTER) then begin
            if new_target == target then begin
               force_dodge_targets_before_main = 0;
               is_behind_target = 1;
            end

            else begin
               if not(obj_is_visible_flag(new_target)) orElse is_in_array(new_target, Line_targets_array) then
                  continue;

               if skip_tile > 0 then begin
                  //dmg_with_flags = DMG_IGNORE;
                  //set_array(Line_targets_array, new_target, dmg_with_flags);
                  call set_shootthru_flag_for_obj(new_target);
                  continue;
               end

               //tile_is_blocked = get_first_non_critter_block_shoot(attacker, check_tile);
               if tile_is_blocked > 0 then begin
                  last_target_on_a_line = new_target;
                  skip_tile = 1;
                  if is_behind_target > 0 then begin
                     tile_is_blocked = get_first_non_critter_block_shoot(attacker, distant_target_tile);
                     if tile_is_blocked > 0 then begin
                        last_target_on_a_line = tile_is_blocked;
                        end_tile = tile_num(tile_is_blocked);
                     end
                     else
                        end_tile = check_tile;
                     exit_all = 1;
                     break;
                  end else begin
                     call set_shootthru_flag_for_obj(new_target);
                     continue;
                  end
               end
            end

            if obj_type(new_target) == OBJ_TYPE_CRITTER then begin
               new_target_cur_hp = get_critter_stat(new_target, STAT_current_hp);
               if new_target_cur_hp <= 0 orElse is_dead(new_target) orElse get_array(death_array,new_target) > 0 then
                  continue;

               if target == real_orig_target then begin
                  new_target_team = has_trait(TRAIT_OBJECT, new_target, OBJECT_TEAM_NUM);
                  if new_target_team == enemy_team then begin
                     enemy_targets_count += 1;
                  end
                  else if attacker_team == new_target_team then begin
                     friendly_targets_count += 1;
                  end
               end
               if array_ended <= 0 then begin
                  if force_dodge_targets_before_main <= 0 then
                     dmg_with_flags = calc_dmg_laser(attacker, new_target, lof_targets_count, lof_targets_count_multihex);
                  else
                     dmg_with_flags = DMG_DODGE;

               if dmg_with_flags > 0 orElse dmg_with_flags == DMG_ZERO then
                  last_target_on_a_line = new_target;

                  set_array(Line_targets_array, new_target, dmg_with_flags);
               end else
                  dmg_with_flags = DMG_IGNORE;

               lof_targets_count += 1;
            end
            else begin
               //terminate procedure if reached non critter non FLAG_SHOOTTHRU target
               if new_target == target orElse is_behind_target > 0 then begin
                  lof_targets_count += 1;
                  if array_ended <= 0 then begin
                     last_target_on_a_line = new_target;
                     if get_flags(new_target) bwand FLAG_SHOOTTHRU == 0 then
                        exit_all = 1;
                     else if new_target == target then begin
                        hit_chance = get_ranged_chance_to_hit(attacker, target, (lof_targets_count - 1), lof_targets_count_multihex);
                        if hit_chance > 0 andAlso hit_chance >= random(0,100) then begin
                           exit_all = 1;
                        end
                     end
                  end
               end
            end

            if dmg_with_flags < 0 andAlso dmg_with_flags != DMG_ZERO then
               lof_targets_count_missed += 1;

            if is_multihex(new_target) then
               lof_targets_count_multihex += 1;

            if target == real_orig_target andAlso new_target == real_orig_target andAlso get_new_targets <= 0 then begin
               if laser_max_targets > lof_targets_count then
                  laser_max_targets = lof_targets_count;
               if array_ended > 0 then begin
                  check_tile = array_ended;
                  exit_all = 1;
                  break;
               end
            end
               //set new main_target if the damage is not enough to penetrate all targets
               if dmg_with_flags <= DMG_ZERO then begin
                  if get_new_targets > 0 andAlso is_behind_target <= 0 andAlso new_target != target then begin
                     dmg_with_flags = DMG_DODGE;
                     lof_targets_count_missed += 1;
                     set_array(Line_targets_array, new_target, dmg_with_flags);
                     //force_dodge_targets_before_main = 1;
                     continue;
                  end
                  laser_new_main_target = new_target;
                  if is_behind_target <= 0 andAlso target == real_orig_target then
                     array_ended = check_tile;
                  else begin
                     exit_all = 1;
                     break;
                  end
               end
            //terminate procedure if reached maximum additional targets (ammo/target cap)
            if (dmg_with_flags > 0 orElse dmg_with_flags == DMG_ZERO) andAlso (lof_targets_count - lof_targets_count_missed) >= laser_max_targets then begin
               if get_new_targets > 0 andAlso is_behind_target <= 0 then begin
                  dmg_with_flags = DMG_DODGE;
                  lof_targets_count_missed += 1;
                  set_array(Line_targets_array, new_target, dmg_with_flags);
                  force_dodge_targets_before_main = 1;
                  continue;
               end
               if is_behind_target <= 0 then
                  laser_new_main_target = new_target;
               exit_all = 1;
               break;
            end
         end
         call set_shootthru_flag_for_obj(new_target);
      end
      if exit_all then begin
         if tile_is_blocked <= 0 then
            end_tile = check_tile;
         break;
      end
      count += 1;
      if count > 50 then begin
         break;
      end

      blocking_obj = obj_blocking_line(attacker, distant_target_tile, BLOCKING_TYPE_SHOOT);
   end

   if is_behind_target <= 0 andAlso laser_new_main_target <= 0 then begin
      laser_new_main_target = last_target_on_a_line;
      if laser_new_main_target == attacker then
         laser_new_main_target = 0;
   end

   Line_end_tile = end_tile;
   gSoundHitTarget = laser_new_main_target;
   //if set_critters_flag then
      //call set_shootthru_flag_for_all_critters;

   call remove_added_flag_for_objs;

   return end_tile;
end

procedure combatAddDamageFlagsDescription(variable critter, variable flags) begin
   variable msg_id;
   variable msg_text;
   variable base_flags_id;
   variable flags_list;
   variable flags_count;
   variable i;
   variable flag_bit;
   variable damage_description;

   if (flags <= 0) then
      return ".";

   // Determine base ID for flag messages
   if (critter == real_dude_obj) then begin
      if (get_critter_stat(critter, STAT_gender) == GENDER_MALE) then
         base_flags_id = 200;
      else
         base_flags_id = 250;
   end else begin
      if (get_critter_stat(critter, STAT_gender) == GENDER_MALE) then
         base_flags_id = 300;
      else
         base_flags_id = 400;
   end

   damage_description = "";

   // Check for death
   if (flags bwand DAM_DEAD != 0) then begin
      // " and "
      //msg_text = message_str_game(GAME_MSG_COMBAT, 108);
      msg_text = modmsg(msg_and);

      damage_description += msg_text;

      // were killed / was killed
      msg_id = base_flags_id + 7;
      msg_text = message_str_game(GAME_MSG_COMBAT, msg_id);
      damage_description += msg_text;
      set_outline(critter, OUTLINE_NONE);
      return damage_description + ".";
   end

   // Collect flag list
   flags_list = create_array_map;
   flags_count = 0;

   // Check each flag except DAM_CRITICAL and DAM_HIT
   flag_bit = 1;
   for (i = 0; i < 32; i++) begin
      if (flag_bit != DAM_CRITICAL and flag_bit != DAM_HIT and (flag_bit bwand flags) != 0) then begin
         set_array(flags_list, flags_count, i);
         flags_count++;
      end
      flag_bit = flag_bit * 2;
   end

   // Add flag descriptions
   if (flags_count > 0) then begin
      for (i = 0; i < flags_count - 1; i++) begin
         damage_description += ", ";
         msg_id = base_flags_id + get_array(flags_list, i);
         msg_text = message_str_game(GAME_MSG_COMBAT, msg_id);
         damage_description += msg_text;
      end

      // " and " before last flag
      msg_text = message_str_game(GAME_MSG_COMBAT, 108);
      damage_description += msg_text;

      msg_id = base_flags_id + get_array(flags_list, flags_count - 1);
      msg_text = message_str_game(GAME_MSG_COMBAT, msg_id);
      damage_description += msg_text;

   end
   return damage_description + ".";
end

// You are not strong enough to use this weapon properly.
procedure show_combat_msg_st_req(variable attacker, variable weapon_pid) begin
   variable attacker_st;
   variable weapon_st_req;
   variable WeaponHandlingPerk;
   variable WeaponHandlingBonus = 3;
   variable msg;
   if weapon_pid <= 0 andAlso gWeapon > 0 then
      weapon_pid = obj_pid(gWeapon);

   if attacker == dude_obj andAlso weapon_pid > 0 then begin
      weapon_st_req = get_proto_data(weapon_pid, PROTO_WP_MIN_ST);
      attacker_st = get_critter_stat(attacker, STAT_st);
      WeaponHandlingPerk = has_trait(TRAIT_PERK, attacker, PERK_weapon_handling_perk);
      if WeaponHandlingPerk > 0 then begin
         attacker_st += WeaponHandlingPerk * WeaponHandlingBonus;
      end

      // You are not strong enough to use this weapon properly.
      if weapon_st_req > attacker_st then
         display_msg(message_str_game(GAME_MSG_COMBAT, 107));

   end
end

procedure show_float_msg_dmg(variable target, variable dmg) begin
   if dmg > 0 then begin
      float_msg(target, "        ", FLOAT_MSG_RED);
      float_msg(target, "-"+dmg, FLOAT_MSG_RED);
   end
   else if dmg < 0 andAlso show_float_dmg == 2 andAlso (alt_fire_selected == alt_fire_gauss orElse alt_fire_selected == alt_fire_laser) then begin
      float_msg(target, "        ", FLOAT_MSG_RED);
      float_msg(target, "~", FLOAT_MSG_RED);
   end
   else if dmg == 0 then begin
      float_msg(target, "        ", FLOAT_MSG_RED);
      float_msg(target, "0", FLOAT_MSG_RED);
   end
end

procedure show_dmg_combat_msg(variable target, variable attacker, variable dmg_value, variable float_display = 1) begin
   variable target_name;
   variable base_msg_id;
   variable msg_id;
   variable msg_text;
   variable you_str;
   variable flags;
   variable str_end;
   variable flags_list;
   variable flags_count;
   variable i;
   variable flag_bit;
   variable base_flags_id;
   variable hit_location = -1;
   variable hit_location_name;
   variable main_target;
   variable main_target_name;

   // return if no target
   if target <= 0 orElse obj_type(target) != OBJ_TYPE_CRITTER then
      return;

   flags = dmg_value / DMG_FLAG_MULT;
   dmg_value = dmg_value % DMG_FLAG_MULT;

   if show_float_dmg > 0 andAlso show_float_dmg != 2 andAlso float_display > 0 then
      call show_float_msg_dmg(target, dmg_value);



   if target == get_object_data(combat_data, C_ATTACK_TARGET) then
      hit_location = get_object_data(combat_data, C_ATTACK_BODY_PART);
   if hit_location == BODY_UNCALLED orElse hit_location == BODY_HIT_TORSO orElse hit_location < 0 then
      hit_location = -1;
   else
      hit_location_name = read_string(hitLocationGetName_str_ptr(target, hit_location));

   // Determine target name and base message ID
   if (target == real_dude_obj) then begin
      // Get "You" string based on player gender
      if (get_critter_stat(dude_obj, STAT_gender) == GENDER_MALE) then
         you_str = message_str_game(GAME_MSG_COMBAT, 506);  // You (male)
      else
         you_str = message_str_game(GAME_MSG_COMBAT, 556);  // You (female)

      target_name = you_str;
      if (get_critter_stat(dude_obj, STAT_gender) == GENDER_MALE) then
         base_msg_id = 500;
      else
         base_msg_id = 550;
   end else begin
      target_name = obj_name(target);
      if (get_critter_stat(target, STAT_gender) == GENDER_MALE) then
         base_msg_id = 600;
      else
         base_msg_id = 700;
   end


   if dmg_value < 0 then begin
      if target == real_dude_obj then
         display_msg(target_name+modmsg(msg_hit_no_dmg_dude));
      else
         display_msg(target_name+modmsg(msg_hit_no_dmg));
      return;
   end

      // Oops!
   if alt_fire_selected == alt_fire_double_tap then begin
      main_target = get_object_data(combat_data, C_ATTACK_MAIN_TARGET);
      if target != main_target then begin
         if main_target == real_dude_obj then begin
            msg_id = base_msg_id + 8;
            msg_text = message_str_game(GAME_MSG_COMBAT, msg_id);
            msg_text = (sprintf(msg_text, target_name));
         end
         else begin
            main_target_name = obj_name(main_target);
            msg_id = base_msg_id + 9;
            msg_text = message_str_game(GAME_MSG_COMBAT, msg_id);
            msg_text = (sprintf2(msg_text, target_name, main_target_name));
         end
         display_msg(msg_text);
      end
   end


      // Process hit on target
   if (flags bwand DAM_HIT != 0 and target != 0) then begin
         // Normal hit
         if (flags bwand DAM_CRITICAL == 0) orElse dmg_value == 0 then begin
            if (dmg_value == 0) then begin
               // 526/626/726 - %s were hit for no damage
               msg_id = base_msg_id + 27;
               if hit_location >= 0 then begin
                  msg_id -= 1;
                  // 527/627/727 - %s were hit in %s for no damage
                  msg_text = message_str_game(GAME_MSG_COMBAT, msg_id);
                  msg_text = (sprintf2(msg_text, target_name, hit_location_name));
               end
               // 526/626/726 - %s were hit for no damage
               else begin
                  msg_text = message_str_game(GAME_MSG_COMBAT, msg_id);
                  msg_text = (sprintf(msg_text, target_name));
               end
               flags = 0;
            end else if (dmg_value == 1) then begin
               // 522/622/722 - %s were hit for 1 damage
               msg_id = base_msg_id + 23;
               if hit_location >= 0 then begin
                  msg_id -= 1;
                  // 521/621/721 - %s were hit in %s for 1 damage
                  msg_text = message_str_game(GAME_MSG_COMBAT, msg_id);
                  msg_text = (sprintf2(msg_text, target_name, hit_location_name));
               end
               // 522/622/722 - %s were hit for 1 damage
               else begin
                  msg_text = message_str_game(GAME_MSG_COMBAT, msg_id);
                  msg_text = (sprintf(msg_text, target_name));
               end
            end else begin
               // 512/612/712 - %s were hit for %d hit points
               msg_id = base_msg_id + 13;
               if hit_location >= 0 then begin
                  msg_id -= 1;
                  // 511/611/711 - %s were hit in %s for %d hit points
                  msg_text = message_str_game(GAME_MSG_COMBAT, msg_id);
                  msg_text = (sprintf3(msg_text, target_name, hit_location_name, dmg_value));
               end
               // 512/612/712 - %s were hit for %d hit points
               else begin
                  msg_text = message_str_game(GAME_MSG_COMBAT, msg_id);
                  msg_text = (sprintf2(msg_text, target_name, dmg_value));
               end
            end
         end else begin
            // Critical hit
            if (dmg_value == 0) then begin
               // 528/628/728 - %s were critically hit for no damage
               msg_id = base_msg_id + 28;
               if hit_location >= 0 then begin
                  msg_id -= 3;
                  // 525/625/725 - %s were critically hit in %s for no damage
                  msg_text = message_str_game(GAME_MSG_COMBAT, msg_id);
                  msg_text = (sprintf2(msg_text, target_name, hit_location_name));
               end
               // 528/628/728 - %s were critically hit for no damage
               else begin
                  msg_text = message_str_game(GAME_MSG_COMBAT, msg_id);
                  msg_text = (sprintf(msg_text, target_name));
               end
               flags = 0;
            end else if (dmg_value == 1) then begin
               // 524/624/724 - %s were critically hit for 1 damage
               msg_id = base_msg_id + 24;
               if hit_location >= 0 then begin
                  msg_id -= 3;
                  // 521/621/721 - %s were critically hit in %s for 1 damage
                  msg_text = message_str_game(GAME_MSG_COMBAT, msg_id);
                  msg_text = (sprintf2(msg_text, target_name, hit_location_name));
               end
               // 524/624/724 - %s were critically hit for 1 damage
               else begin
                  msg_text = message_str_game(GAME_MSG_COMBAT, msg_id);
                  msg_text = (sprintf(msg_text, target_name));
               end
            end else begin
               // 520/620/720 - %s were critically hit for %d hit points
               msg_id = base_msg_id + 20;
               if hit_location >= 0 then begin
                  msg_id -= 9;
                  // 511/611/711 - %s were critically hit in %s for %d hit points
                  msg_text = message_str_game(GAME_MSG_COMBAT, msg_id);
                  msg_text = (sprintf3(msg_text, target_name, hit_location_name, dmg_value));
               end
               // 520/620/720 - %s were critically hit for %d hit points
               else begin
                  msg_text = message_str_game(GAME_MSG_COMBAT, msg_id);
                  msg_text = (sprintf2(msg_text, target_name, dmg_value));
               end
            end
         end


      flags = flags bwand bwnot(DAM_CRITICAL bwor DAM_HIT);
      if (flags > 0) then // Add damage flag descriptions
          msg_text += combatAddDamageFlagsDescription(target, flags);
      else
         msg_text += ".";
      display_msg(msg_text);
   end
end

procedure callback_render_hp begin
   call_offset_v1(0x45EBD8, true);
end

procedure exec_dmg_script(variable target, variable target_sid, variable attacker, variable dmg_value, variable real_orig_target_team, variable atk_weapon) begin
   variable target_team;
   if target_sid > 0 then begin
      target_team = has_trait(TRAIT_OBJECT, target, OBJECT_TEAM_NUM);
      set_obj_script_fixed_value(target_sid, dmg_value);
      if attacker > 0 andAlso ((target_team == real_orig_target_team) orElse dmg_value > 30 orElse not(random(0,4))) then begin
         set_obj_script_objects(target_sid, attacker, atk_weapon);
      end
      exec_obj_script_proc(target_sid, damage_proc);
   end
end

   //increase combat_xp and increase kill_count
procedure combat_xp_kill_count_inc(variable target, variable attacker) begin
   variable combat_xp_bonus;
   variable attacker_team = has_trait(TRAIT_OBJECT, attacker, OBJECT_TEAM_NUM);
   variable target_team;

   if attacker_team == TEAM_PLAYER andAlso combat_is_initialized then begin
      target_team = has_trait(TRAIT_OBJECT, target, OBJECT_TEAM_NUM);
      if target_team != TEAM_PLAYER then begin
         //inc combat exp
         if Sonora <= 0 then begin
            combat_xp_bonus = get_combat_exp + get_critter_xp(target);
            set_combat_exp(combat_xp_bonus);
         end
         inc_kill_count(critter_kill_type(target));
      end
      else begin
         inc_kill_count(critter_kill_type(target));
      end
   end
end

procedure exec_destroy_script(variable target, variable target_sid, variable attacker, variable dmg_value, variable real_orig_target_team, variable atk_weapon) begin
   variable target_team;
   if target_sid > 0 then begin
      if dmg_value > 0 then begin
         call exec_dmg_script(target, target_sid, attacker, dmg_value, real_orig_target_team, atk_weapon);
      end
      set_obj_script_objects(target_sid, attacker, 0);
      exec_obj_script_proc(target_sid, destroy_proc);
   end
   call combat_xp_kill_count_inc(target, attacker);
end

procedure display_dmg_exec_all_script_procs2 begin
   variable target;
   variable target_cur_hp;
   variable real_orig_target_team = -2;
   variable attacker = get_object_data(combat_data, C_ATTACK_SOURCE);
   variable attacker_team = -1;
   variable atk_weapon = gWeapon;
   variable dmg_value;
   variable target_sid;
   variable target_team;
   variable deal_dmg;
   variable combat_main_target = get_object_data(combat_data, C_ATTACK_MAIN_TARGET);
   variable combat_main_target_msg;
   if alt_atk_wait_for_report <= 0 then
      return;
   alt_atk_wait_for_report = 0;
   //call enable_anim_priority;
   //foreach (target : dmg_value in altAttackResults) begin
      //call show_dmg_combat_msg(target, -1, dmg_value);
   //end
   tile_refresh_display_disable;
   if attacker > 0 then
      attacker_team = has_trait(TRAIT_OBJECT, attacker, OBJECT_TEAM_NUM);
   if real_orig_target > 0 then
      real_orig_target_team = has_trait(TRAIT_OBJECT, real_orig_target, OBJECT_TEAM_NUM);

   call show_combat_msg_st_req(attacker, gWeaponPid);

   foreach (target : dmg_value in altAttackResults) begin
      if get_object_data(target, OBJ_DATA_DAMAGE_FLAGS) bwand DAM_DEAD != 0 then
         continue;

      call show_dmg_combat_msg(target, -1, dmg_value, true);
      if combat_main_target > 0 andAlso target == combat_main_target then
         combat_main_target_msg = 1;

      if target > 0 andAlso dmg_value > 0 andAlso get_array(combat_targets_array, target) <= 0 then begin
         dmg_value = dmg_value % DMG_FLAG_MULT;
         target_sid = get_object_data(target, OBJ_DATA_SID);
         target_cur_hp = get_object_data(target, OBJ_DATA_CUR_HP);
         if target_cur_hp > 0 then begin
            target_team = has_trait(TRAIT_OBJECT, target, OBJECT_TEAM_NUM);
            //chance to set who hit the target if they are from different teams
            if attacker_team != target_team andAlso (get_object_data(target, OBJ_DATA_WHO_HIT_ME) <= 0 orElse dmg_value >= target_cur_hp orElse not(random(0,2))) then begin
               set_object_data(target, OBJ_DATA_WHO_HIT_ME, attacker);
            end
            if target_sid > 0 then begin
               call exec_dmg_script(target, target_sid, attacker, dmg_value, real_orig_target_team, atk_weapon);
            end
         end
         else begin
            if deal_dmg >= 0 andAlso target != real_dude_obj then begin
               //call_offset_v1(0x426DDC, target);//remove from combat
               if target_sid > 0 then begin
                  call exec_destroy_script(target, target_sid, attacker, dmg_value, real_orig_target_team, atk_weapon);
               end
               //set_object_data(target, OBJ_DATA_DAMAGE_FLAGS, (get_object_data(target, OBJ_DATA_DAMAGE_FLAGS) bwand NOT_DAM_DEAD));
               critter_heal(target, -target_cur_hp);
            end
            if deal_dmg > 0 then begin
               set_outline(target, OUTLINE_NONE);
            end
         end
      end
   end
   if alt_fire_selected != alt_fire_double_tap andAlso combat_main_target > 0 andAlso combat_main_target_msg <= 0 andAlso (get_object_data(combat_main_target, OBJ_DATA_DAMAGE_FLAGS) bwand DAM_DEAD == 0) then
      call show_dmg_combat_msg(combat_main_target, -1, DMG_DODGE, false);
   //Attacker KO from ELEC or PLASMA alt attack
   //if is_in_prone_anim(critter_art_anim(orig_attacker)) then begin
      //if get_critter_current_ap(orig_attacker) >= 1 then begin
         //call_offset_v1(0x425FBC, orig_attacker);
      //end
   //end

   call lvar_full_reset;
   tile_refresh_display_enable;
   if array_exists(altAttackResults) then clear_array(altAttackResults);
   if array_exists(death_array) then clear_array(death_array);
   tile_refresh_display;
end

procedure add_show_dmg_timer begin
   variable timer;
   if _combat_turn_running > 1 then begin
      timer = create_object_sid(PID_PROJ_LASER, 0, 0, -1);
      reg_anim_combat_check(0);
      reg_anim_begin();
      reg_anim_animate(timer, ANIM_stand, -1);
      reg_anim_animate_reverse(timer, ANIM_stand, 1);
      reg_anim_destroy(timer);
      reg_anim_callback(add_show_dmg_timer);
      reg_anim_end();
   end else begin
      combat_disable_display;
      call display_dmg_exec_all_script_procs2;
   end

end

procedure get_full_alt_flags(variable target) begin
   variable full_flags;
   full_flags = get_array(altAttackResults, target) / DMG_FLAG_MULT;

   return full_flags;
end

procedure get_full_alt_dmg(variable target) begin
   variable full_damage;
   full_damage = get_array(altAttackResults, target) % DMG_FLAG_MULT;

   return full_damage;
end

//by Phobos2077 https://github.com/phobos2077/fo2_ecco/blob/f5df1e4edfe03c2df30fcf26f38ce8e2bdae4a4c/scripts_src/_pbs_main/gl_pbs_damage_mod.ssl#L515
procedure validate_critter_anim(variable critter, variable animType) begin
   variable objFid := obj_art_fid(critter);
   variable rot := objFid bwand 0x70000000;
   // This is based on vanilla logic from art_id_()
   if (animType != ANIM_fire_dance and animType >= ANIM_fall_back and animType <= ANIM_fall_front_blood) then begin
      if (art_exists(critter_anim_fid(objFid, animType, 1))) then
         return true;
   end
   return art_exists(critter_anim_fid(objFid, animType, 0));
end

procedure get_death_anim(variable target, variable target_cur_anim, variable attacker, variable dmg_value, variable dmg_flags, variable dmg_type, variable dmg_source_tile) begin
   variable death_anim = ANIM_fall_back;
   variable target_max_hp = get_critter_stat(target, STAT_max_hp);
   //variable death_anim_sf;
   variable is_front_hit = is_hit_from_front(dmg_source_tile, target);
   variable is_burst = dmg_type bwand DMG_TYPE_FLAG_BURST;
   //add target to array of creatures that will die. critter_PTR as key, dmg as value
   if not(array_exists(death_array)) then begin
      death_array = create_array_map;
      set_array(death_array, target, (dmg_value + get_full_alt_dmg(target) + (dmg_flags * DMG_FLAG_MULT)));
   end
   else begin
      set_array(death_array, target, (dmg_value + get_full_alt_dmg(target) + (dmg_flags * DMG_FLAG_MULT)));
   end
   //remove flags from dmg
   dmg_value = dmg_value % DMG_FLAG_MULT;
   //Death animation for bosses
   if (get_proto_data(obj_pid(target), PROTO_CR_FLAGS) bwand CFLG_SPECIAL) == CFLG_SPECIAL then begin
      death_anim = ANIM_exploded_to_nothing;
   end
   //Death animation for a knocked out target
   if target_cur_anim == ANIM_fall_back orElse target_cur_anim == ANIM_fall_back_sf then begin
      death_anim = ANIM_fall_back_blood;
      return death_anim;
   end
   else if target_cur_anim == ANIM_fall_front orElse target_cur_anim == ANIM_fall_front_sf then begin
      death_anim = ANIM_fall_front_blood;
      return death_anim;
   end
   //Death animation for a standing target
   else begin
      dmg_type -= is_burst;
      //standard death_anim
      if dmg_type == DMG_normal_dam andAlso is_burst < 0 andAlso (dmg_value < 35 or dmg_value < target_max_hp) andAlso random(0,2) then begin
         death_anim = ANIM_fall_front - is_front_hit;
      end
      //brutal death_anim
      else begin
         if dmg_type == DMG_plasma then begin
            if dmg_value <= 15 then begin
               death_anim = ANIM_fall_front - is_front_hit;
            end
            else if random(0,1) orElse (dmg_value < 30 andAlso dmg_value < (target_max_hp * 3 / 2)) then begin
               death_anim = ANIM_charred_body;
            end
            else begin
               death_anim = ANIM_melted_to_nothing;
            end
         end
         else if dmg_type == DMG_electrical then begin
            if dmg_value <= 15 then begin
               death_anim = ANIM_fall_front - is_front_hit;
            end
            else if random(0,1) orElse (dmg_value < 30 andAlso dmg_value < (target_max_hp * 3 / 2)) then begin
               death_anim = ANIM_electrify;
            end
            else begin
               death_anim = ANIM_electrified_to_nothing;
            end
         end
         else if dmg_type == DMG_laser then begin
            if dmg_value <= 15 then begin
               death_anim = ANIM_fall_front - is_front_hit;
            end
            else begin
               death_anim = ANIM_sliced_in_half;
            end
         end
         else if dmg_type == DMG_explosion then begin
            death_anim = ANIM_exploded_to_nothing;
         end
         else if dmg_type == DMG_normal_dam then begin
            //brust death_anim
            if is_burst > 0 then begin
               //heavy burst
               if is_burst > DMG_TYPE_FLAG_BURST then begin
                  death_anim = ANIM_chunks_of_flesh;
               end
               //light burst
               else begin
                  death_anim = ANIM_dancing_autofire;
               end
            end
            //single death_anim
            else begin
               if dmg_value < 101 andAlso dmg_value < (target_max_hp * 2) then begin
                  death_anim = ANIM_big_hole;
               end
               else begin
                  death_anim = ANIM_exploded_to_nothing;
               end
            end
         end
         else if dmg_type == DMG_fire then begin
            //death_anim = ANIM_fire_dance;
            //if not(validate_critter_anim(target, death_anim)) then begin
               death_anim = ANIM_burned_to_nothing;
            //end
         end
         else begin
            death_anim = ANIM_fall_front - is_front_hit;
         end
      end
      //death_anim_sf = death_anim + 28;
      if not(validate_critter_anim(target, death_anim)) then begin
          death_anim = ANIM_fall_front - is_front_hit;

          if not(validate_critter_anim(target, death_anim)) then
              death_anim = ANIM_fall_back + is_front_hit;
      end
      return death_anim;
   end
end


procedure set_combat_targets_to_array begin
   variable combat_attacker = get_object_data(combat_data, C_ATTACK_SOURCE);
   variable combat_target = get_object_data(combat_data, C_ATTACK_TARGET);
   variable extra_target;
   variable next_num;
   variable extra_target_num_max = EXPLOSION_TARGET_COUNT * 4;
   variable target_index = 3;
   if array_exists(combat_targets_array) then
      clear_array(combat_targets_array);
   else
      combat_targets_array = create_array_map;

   if combat_target > 0 then begin
      set_array(combat_targets_array, combat_target, 1);
   end

   if combat_attacker > 0 then begin
      if combat_attacker != combat_target then begin
         set_array(combat_targets_array, combat_attacker, 2);
      end
   end

   for (next_num = 0; next_num < extra_target_num_max; next_num += 4) begin
   extra_target = get_object_data(combat_data, (C_ATTACK_TARGET1 + next_num));

      if extra_target <= 0 then
         break;

      if extra_target == combat_target orElse extra_target == combat_attacker then
         continue;

      set_array(combat_targets_array, extra_target, target_index);
      target_index += 1;
   end
end

procedure add_to_dmg_report_array(variable target, variable dmg_value, variable dmg_flags, variable is_combat_target = 0) begin
   variable full_damage;
   variable full_flags;
   variable dmg_combined_flags;
   if not(array_exists(altAttackResults)) then begin
      altAttackResults = create_array_map;

      if dmg_value == 0 then
         dmg_combined_flags = 25600000; //(DAM_HIT * DMG_FLAG_MULT);
      else if dmg_value < 0 then
         dmg_combined_flags = 0;
      else
         dmg_combined_flags = dmg_value + (dmg_flags * DMG_FLAG_MULT);
      set_array(altAttackResults, target, dmg_combined_flags);
   end
   else begin
      if is_combat_target <= 0 then begin
         full_damage = get_full_alt_dmg(target);
         full_flags = get_full_alt_flags(target);
      end

      full_damage += dmg_value;
      full_flags = full_flags bwor dmg_flags;

      if full_damage == 0 then
         dmg_combined_flags = 25600000; //(DAM_HIT * DMG_FLAG_MULT);
      else if dmg_value < 0 then
         dmg_combined_flags = 0;
      else
         dmg_combined_flags = full_damage + (full_flags * DMG_FLAG_MULT);

      set_array(altAttackResults, target, dmg_combined_flags);
   end
end

procedure get_combat_dmg_and_flags(variable target) begin
   variable combat_attacker = get_object_data(combat_data, C_ATTACK_SOURCE);
   variable combat_target = get_object_data(combat_data, C_ATTACK_TARGET);
   variable extra_target;
   variable next_num;
   variable extra_target_num_max = EXPLOSION_TARGET_COUNT * 4;
   variable dmg_value;
   variable flags;
   variable cur_attack_results_flags;
   if combat_target <= 0 then
      return -1;

   if target == combat_target then begin
      dmg_value = get_object_data(combat_data, C_ATTACK_DAMAGE_TARGET);
      flags = get_object_data(combat_data, C_ATTACK_FLAGS_TARGET);
      flags = flags bwand 0xFFF;
      flags = flags bwor (get_object_data(combat_data, C_ATTACK_FLAGS_SOURCE) bwand (DAM_HIT bwor DAM_CRITICAL));
      return dmg_value + (flags * DMG_FLAG_MULT);
   end
   else if target == combat_attacker then begin
      dmg_value = get_object_data(combat_data, C_ATTACK_DAMAGE_SOURCE);
      flags = get_object_data(combat_data, C_ATTACK_FLAGS_SOURCE);
      flags = flags bwand 0xFFF;
      cur_attack_results_flags = get_array(cur_attack_results_arr, target);
      if cur_attack_results_flags > DMG_FLAG_MULT then begin
         cur_attack_results_flags = cur_attack_results_flags / DMG_FLAG_MULT;
         flags = flags bwor (cur_attack_results_flags bwand (DAM_HIT bwor DAM_CRITICAL bwor DAM_KNOCKED_DOWN));
      end
      return dmg_value + (flags * DMG_FLAG_MULT);
   end
   else begin
      for (next_num = 0; next_num < extra_target_num_max; next_num += 4) begin
         extra_target = get_object_data(combat_data, (C_ATTACK_TARGET1 + next_num));
         if extra_target <= 0 then
            return -1;

         if extra_target == combat_target orElse extra_target == combat_attacker then
            continue;

         if target == extra_target then begin
            dmg_value = get_object_data(combat_data, (C_ATTACK_DAMAGE_TARGET1 + next_num));
            flags = get_object_data(combat_data, (C_ATTACK_FLAGS_TARGET1 + next_num));
            flags = flags bwand 0xFFF;
            return dmg_value + (flags * DMG_FLAG_MULT);
         end
      end
   end
end

procedure critter_inflict_dmg(variable target,variable attacker,variable dmg_value, variable dmg_type, variable flags, variable dmg_source_tile) begin
   variable target_cur_hp;
   variable target_cur_anim;
   variable death_anim;
   variable death_anim_part2;
   variable outline_timer;
   variable combat_dmg;
   variable cur_dmg;
   variable target_cr_flags;
   variable combat_target;
   variable is_front_hit;
   variable dmg_anim;
   variable fall_anim;
   //check if the target and attack exists and is a creature
   if target <= 0 orElse obj_type(target) != OBJ_TYPE_CRITTER orElse get_array(death_array,target) > 0 then begin
      return;
   end

   target_cur_hp = get_critter_stat(target, STAT_current_hp);
   if target_cur_hp <= 0 orElse is_dead(target) orElse (dude_will_die > 0 andAlso target == dude_obj) then begin
      return;
   end

   target_cur_anim = art_anim(obj_art_fid(target));
   if target_cur_anim < 0 then
      return;

   if dmg_value == DMG_ZERO then
      dmg_value = 0;

   dmg_value = ceil(dmg_value);

   if get_array(combat_targets_array, target) > 0 then begin
      combat_target = 1;
      combat_dmg = get_combat_dmg_and_flags(target);
      flags = combat_dmg / DMG_FLAG_MULT;
      dmg_value = combat_dmg % DMG_FLAG_MULT;
      if dmg_value <= 0 then begin
         if (flags bwand DAM_HIT) != 0 andAlso (target_cr_flags bwand CFLG_INVULN) == 0 then begin
            dmg_value = 0;
            flags = DAM_HIT;
         end
         else begin
            dmg_value = DMG_DODGE;
            flags = 0;
         end

      end
      cur_dmg = dmg_value;
   end
   else begin
      cur_dmg = dmg_value;
      //for multiple critter_inflict_dmg in one attack anim
      dmg_value = get_full_alt_dmg(target) + cur_dmg;
   end

   if target_cur_hp > cur_dmg then begin
      call add_to_dmg_report_array(target, cur_dmg, flags, combat_target);
   end
   else begin
      flags = flags bwor DAM_DEAD;
      call add_to_dmg_report_array(target, cur_dmg, (flags bwor DAM_DEAD), combat_target);
   end
   if (flags bwand DAM_DEAD) != 0 then begin
      //if dmg_value < target_cur_hp then
         //dmg_value = target_cur_hp;
      if cur_dmg < target_cur_hp then
         cur_dmg = target_cur_hp;
   end

   if show_float_dmg == 2 then
      call show_float_msg_dmg(target, dmg_value);

   if combat_target <= 0 andAlso target != dude_obj andAlso cur_dmg > 0 then
      set_object_data(target, OBJ_DATA_CUR_HP, (target_cur_hp - cur_dmg));


   if attacker > 0 then begin
      //check dmg source tile
      if dmg_source_tile <= 0 orElse dmg_source_tile == tile_num(target) then begin
         dmg_source_tile = tile_num(attacker);
      end
   end
   target_cr_flags = get_proto_data(obj_pid(target), PROTO_CR_FLAGS);


   reg_anim_combat_check(0);
   if not(is_in_prone_anim(target_cur_anim)) orElse (flags bwand DAM_DEAD) != 0 then
      reg_anim_clear_forced(target);
   reg_anim_func(REG_ANIM_BEGIN, RB_RESERVED);

   if target != real_dude_obj andAlso obj_team(target) != obj_team(attacker) andAlso (get_object_data(target, OBJ_DATA_WHO_HIT_ME) <= 0 orElse random(0,3) == 0) then
      set_object_data(target, OBJ_DATA_WHO_HIT_ME, attacker);
   // dodge anim
   if cur_dmg < 0 orElse (target_cr_flags bwand CFLG_INVULN) then begin
      if not(is_in_prone_anim(target_cur_anim)) then begin
         reg_anim_play_sfx(target,sfx_build_char_name(target,ANIM_dodge_anim,snd_contact),0);
         reg_anim_animate(target, ANIM_dodge_anim, 0);
      end
   end
   //cause non-lethal damage
   else if target_cur_hp > cur_dmg then begin
      //hit sound for laser and gauss
      if gAllowProjHitSound then begin
         reg_anim_play_sfx(target, sfx_build_weapon_name(snd_weapon_hitting, gWeapon, hit_right_weapon_primary, target), 0);
         if gProjToHideOnTargetHit <= 0 andAlso alt_fire_selected == alt_fire_gauss then
            gAllowProjHitSound = 0;
      end

      if not(is_in_prone_anim(target_cur_anim)) then begin
         if cur_dmg > 0 andAlso (flags bwand (DAM_KNOCKED_DOWN bwor DAM_KNOCKED_OUT)) != 0 then begin

            if flags bwand DAM_KNOCKED_DOWN != 0 then
               set_object_data(target, OBJ_DATA_DAMAGE_FLAGS, (get_object_data(target, OBJ_DATA_DAMAGE_FLAGS) bwor DAM_KNOCKED_DOWN));
            else if flags bwand DAM_KNOCKED_OUT != 0 then
               set_object_data(target, OBJ_DATA_DAMAGE_FLAGS, (get_object_data(target, OBJ_DATA_DAMAGE_FLAGS) bwor DAM_KNOCKED_OUT));

            is_front_hit = is_hit_from_front(dmg_source_tile, target);
            fall_anim = ANIM_fall_front - is_front_hit;

            if not(validate_critter_anim(target, fall_anim)) then
                fall_anim = ANIM_fall_back + is_front_hit;

            reg_anim_play_sfx(target, sfx_build_char_name(target, fall_anim, snd_knock_down), 0);
            reg_anim_animate(target, fall_anim, 0);
         end
         else begin
            is_front_hit = is_hit_from_front(dmg_source_tile, target);
            dmg_anim := ANIM_hit_from_back - is_front_hit;

            if not(validate_critter_anim(target, dmg_anim)) then
                dmg_anim = ANIM_hit_from_front + is_front_hit;

            reg_anim_play_sfx(target,sfx_build_char_name(target,dmg_anim,snd_contact),0);
            reg_anim_animate(target, dmg_anim, 0);
         end
      end
   end
   //cause lethal damage
   else begin
      //hit sound for laser and gauss
      if gAllowProjHitSound then begin
         reg_anim_play_sfx(target, sfx_build_weapon_name(snd_weapon_hitting, gWeapon, hit_right_weapon_primary, target), 0);
         if gProjToHideOnTargetHit <= 0 andAlso alt_fire_selected == alt_fire_gauss then
            gAllowProjHitSound = 0;
      end
      //if get_array(combat_targets_array, target) <= 0 then
         //set_object_data(target, OBJ_DATA_DAMAGE_FLAGS, (get_object_data(target, OBJ_DATA_DAMAGE_FLAGS) bwor DAM_DEAD));
      death_anim = get_death_anim(target, target_cur_anim, attacker, cur_dmg, flags, dmg_type, dmg_source_tile);
      reg_anim_toggle_outline(target, true, -1);
      reg_anim_unset_flag(target, FLAG_FLAT, 0);
      reg_anim_unset_flag(target, FLAG_NOBLOCK, -1);
      //standardt death anim
      if death_anim == ANIM_fall_back orElse death_anim == ANIM_fall_front then begin
         death_anim_part2 = death_anim + 14;
         reg_anim_play_sfx(target,sfx_build_char_name(target,death_anim,snd_knock_down),0);
         reg_anim_animate(target, death_anim, 0);
         reg_anim_play_sfx(target,sfx_build_char_name(target,death_anim_part2,snd_knock_down),-1);
         reg_anim_animate(target, death_anim_part2, 0);
      end
      //KO target death
      else if death_anim == ANIM_fall_back_blood orElse death_anim == ANIM_fall_front_blood then begin
         reg_anim_animate(target, death_anim, 0);
      end
      //brutal fire_dance death
      else if death_anim == ANIM_fire_dance then begin
         death_anim_part2 = death_anim - 4;
         reg_anim_play_sfx(target,sfx_build_char_name(target,death_anim,snd_knock_down),0);
         reg_anim_animate(target, death_anim, 0);
         reg_anim_play_sfx(target,sfx_build_char_name(target,death_anim_part2,snd_knock_down),-1);
         reg_anim_animate(target, death_anim_part2, 0);
      end
      //brutal death
      else begin
         reg_anim_animate(target, death_anim, -1);
         reg_anim_play_sfx(target,sfx_build_char_name(target,death_anim,snd_knock_down), 0);
      end
      if target == dude_obj then begin
         reg_anim_heal_critter(target, -cur_dmg, -1);
         reg_anim_callback(callback_render_hp);
      end
      reg_anim_toggle_outline(target, false, -1);
      reg_anim_set_flag(target, FLAG_FLAT, 0);
      reg_anim_set_flag(target, FLAG_NOBLOCK, 0);
      reg_anim_set_flag(target, FLAG_SHOOTTHRU, 0);
   end
   reg_anim_end();
end




procedure enable_PlayerSpeedup begin
   PlayerSpeedup1 = read_int(player_speedup_mem_adr);
   if PlayerSpeedup1 < 1 then begin
      write_int(player_speedup_mem_adr, 1);
      player_speedup_was_enabled = 1;
   end
end

procedure check_sfall510_and_speedup begin
   variable cur_combat_speed;
   if (sfall_510 > 0) then begin
      PlayerSpeedup1 = read_int(player_speedup_mem_adr);
      if (PlayerSpeedup1 < 1) then begin
         cur_combat_speed = read_int(combat_speed_mem_adr);
         if cur_combat_speed > 0 then begin
            if (last_combat_speed == -1) then
               last_combat_speed = cur_combat_speed;

            write_int(combat_speed_mem_adr, 0);
            call_offset_v1(SavePrefs_adr, 0);
         end
      end
   end
end

procedure set_combat_speed(variable speed) begin
   variable cur_combat_speed;

   if speed > COMBAT_SPEED_MAX then
      speed = COMBAT_SPEED_MAX;
   else if speed < 0 then
      speed = 0;

   cur_combat_speed = read_int(combat_speed_mem_adr);

   if cur_combat_speed == speed then
      return;

   if last_combat_speed == -1 then
      last_combat_speed = cur_combat_speed;

   write_int(combat_speed_mem_adr, speed);
   call_offset_v1(SavePrefs_adr, 0);
end

procedure set_combat_speed_elec begin
   variable speed;
   variable cur_combat_speed;

   if sfall_510 > 0 then
      speed = COMBAT_SPEED_ELEC_Sfall_510;
   else
      speed = 127;

   if speed > COMBAT_SPEED_MAX then
      speed = COMBAT_SPEED_MAX;

   cur_combat_speed = read_int(combat_speed_mem_adr);

   if cur_combat_speed == speed then
      return;

   if last_combat_speed == -1 then
      last_combat_speed = cur_combat_speed;

   write_int(combat_speed_mem_adr, speed);
   call_offset_v1(SavePrefs_adr, 0);
end


procedure set_combat_speed_laser begin
   variable speed = COMBAT_SPEED_LASER;
   variable cur_combat_speed;
   call enable_PlayerSpeedup;
   if sfall_510 then
      return;

   cur_combat_speed = read_int(combat_speed_mem_adr);

   if cur_combat_speed <= speed then
      return;

   if last_combat_speed == -1 then
      last_combat_speed = cur_combat_speed;

   write_int(combat_speed_mem_adr, speed);
   call_offset_v1(SavePrefs_adr, 0);
end

procedure set_combat_speed_gauss begin
   variable speed = COMBAT_SPEED_GAUSS;
   variable cur_combat_speed;
   call enable_PlayerSpeedup;
   if sfall_510 then
      return;

   cur_combat_speed = read_int(combat_speed_mem_adr);

   if cur_combat_speed >= speed then
      return;

   if last_combat_speed == -1 then
      last_combat_speed = cur_combat_speed;

   write_int(combat_speed_mem_adr, speed);
   call_offset_v1(SavePrefs_adr, 0);
end

procedure set_lvar_proj_hidden begin
   if gProjToHideOnTargetHit > 0 then begin
      set_obj_visibility(gProjToHideOnTargetHit, 1);
   end
end

procedure plasma_alt_explosion begin
   variable attacker = get_object_data(combat_data, C_ATTACK_SOURCE);
   variable cur_combat_target = get_object_data(combat_data, C_ATTACK_TARGET);
   variable target_elevation = elevation(cur_combat_target);
   variable tar_tile = tile_num(cur_combat_target);
   variable critter_team = -5;
   variable blast_radius = PlasmaBlastRadius;
   variable new_tar;
   variable new_tar_cur_hp;
   variable exlposion;
   variable pid = PID_EXPLOSION_PLASMA_1;
   variable sfx = "WHS1FXX1";
   variable dmg;
   variable party = party_member_list(0);
   variable flags;
   variable exlposion_2;
   variable rot;
   variable expl_tile;

   if blast_radius <= 2 then begin
      pid = PID_EXPLOSION_EMP_2;
      exlposion_2 = create_object_sid(pid, tar_tile, target_elevation, -1);
      if sfall_510 > 0 then begin
         set_flags(exlposion_2, FLAGS_OBJECT_PROJECTILE);
         set_object_data(exlposion_2, OBJ_DATA_LIGHT_DISTANCE, 8);
         set_object_data(exlposion_2, OBJ_DATA_LIGHT_INTENSITY, 0x10000);
      end
      else begin
         set_flags(exlposion_2, FLAGS_OBJECT_PROJECTILE_visible);
      end
   end
   else begin
      if gWeaponDamageType == DMG_emp orElse gWeaponDamageType == DMG_electrical then
         pid = PID_EXPLOSION_EMP_1;
      sfx = "WHP1XXX1";
   end
   exlposion = create_object_sid(pid, tar_tile, target_elevation, -1);

   if sfall_510 > 0 then begin
      set_flags(exlposion, FLAGS_OBJECT_PROJECTILE);
      set_object_data(exlposion, OBJ_DATA_LIGHT_DISTANCE, 8);
      set_object_data(exlposion, OBJ_DATA_LIGHT_INTENSITY, 0x10000);
   end
   else begin
      set_flags(exlposion, FLAGS_OBJECT_PROJECTILE_visible);
   end


   reg_anim_combat_check(0);
   if blast_radius <= 2 then begin
      set_object_data(exlposion, OBJ_DATA_CUR_Y, get_object_data(exlposion, OBJ_DATA_CUR_Y) - 2);
      set_object_data(exlposion_2, OBJ_DATA_CUR_Y, get_object_data(exlposion_2, OBJ_DATA_CUR_Y) - 2);
      set_object_data(exlposion, OBJ_DATA_CUR_FRM, 9);
      set_object_data(exlposion_2, OBJ_DATA_CUR_FRM, 7);

      reg_anim_begin();
      reg_anim_unset_flag(exlposion, OBJECT_HIDDEN, 0);
      reg_anim_play_sfx(exlposion, sfx, -1);
      reg_anim_animate_reverse(exlposion, ANIM_stand, 0);
      reg_anim_set_flag(exlposion, FLAG_OBJECT_HIDDEN, 2);
      reg_anim_destroy(exlposion);
      reg_anim_end();

      reg_anim_combat_check(0);
      reg_anim_begin();
      reg_anim_unset_flag(exlposion_2, OBJECT_HIDDEN, 0);
      reg_anim_animate_reverse(exlposion_2, ANIM_stand, 0);
      reg_anim_set_flag(exlposion_2, FLAG_OBJECT_HIDDEN, 2);
      reg_anim_destroy(exlposion_2);
      reg_anim_end();
   end
   else begin
      set_object_data(exlposion, OBJ_DATA_CUR_X, get_object_data(exlposion, OBJ_DATA_CUR_X) - 4);
      set_object_data(exlposion, OBJ_DATA_CUR_Y, get_object_data(exlposion, OBJ_DATA_CUR_Y) - 20);
      reg_anim_begin();
      reg_anim_unset_flag(exlposion, OBJECT_HIDDEN, 0);
      reg_anim_play_sfx(exlposion, sfx, -1);
      reg_anim_animate(exlposion,ANIM_stand, 0);
      if blast_radius <= 2 then
         reg_anim_animate_reverse(exlposion,ANIM_stand, 2);
      reg_anim_set_flag(exlposion, FLAG_OBJECT_HIDDEN, -1);
      reg_anim_destroy(exlposion);
      reg_anim_end();

      for (rot = 0; rot < 6; rot++) begin
         expl_tile = tile_num_in_direction(tar_tile, rot, 1);
         exlposion = create_object_sid(pid, expl_tile, target_elevation, -1);
         if sfall_510 > 0 then begin
            set_flags(exlposion, FLAGS_OBJECT_PROJECTILE);
            set_object_data(exlposion, OBJ_DATA_LIGHT_DISTANCE, 8);
            set_object_data(exlposion, OBJ_DATA_LIGHT_INTENSITY, 0x10000);
         end
         else begin
            set_flags(exlposion, FLAGS_OBJECT_PROJECTILE_visible);
         end
         set_object_data(exlposion, OBJ_DATA_CUR_X, get_object_data(exlposion, OBJ_DATA_CUR_X) - 4);
         set_object_data(exlposion, OBJ_DATA_CUR_Y, get_object_data(exlposion, OBJ_DATA_CUR_Y) - 20);
         reg_anim_begin();
         reg_anim_unset_flag(exlposion, OBJECT_HIDDEN, 0);
         reg_anim_animate(exlposion,ANIM_stand, 0);
         if blast_radius <= 2 then
            reg_anim_animate_reverse(exlposion,ANIM_stand, 2);
         reg_anim_set_flag(exlposion, FLAG_OBJECT_HIDDEN, -1);
         reg_anim_destroy(exlposion);
         reg_anim_end();
      end

   end


   foreach new_tar:dmg in plasma_dmg_array begin
      if new_tar <= 0 then
         continue;

      if dmg > 0 then begin
         flags = dmg / DMG_FLAG_MULT;
         dmg = dmg % DMG_FLAG_MULT;
      end
      else if new_tar == attacker andAlso dmg < 0 then begin
         continue;
      end
      new_tar_cur_hp = get_critter_stat(new_tar, STAT_current_hp);
      critter_team = has_trait(TRAIT_OBJECT, new_tar, OBJECT_TEAM_NUM);
      //on a successful hit, the target becomes hostile
      if critter_team == TEAM_PLAYER then begin
         //on a successful damaging hit, a friendly(non-campanion) target with low health has a 25% chance to become hostile
         if dmg > 5 andAlso new_tar_cur_hp > dmg andAlso new_tar_cur_hp / 2 < dmg andAlso not(random(0,3)) andAlso not(is_in_array(new_tar, party)) then attack_setup(new_tar, attacker);
      end
      else begin
         //on a successful hit, a non-friendly target has a 66% chance to become hostile
         if random(0,2) then attack_setup(new_tar, attacker);
      end

      call critter_inflict_dmg(new_tar, attacker, dmg, DMG_plasma, flags, tar_tile);
   end
end

procedure callback_laser_line_dmg_anim begin
   variable attacker = get_object_data(combat_data, C_ATTACK_SOURCE);
   variable target = get_object_data(combat_data, C_ATTACK_TARGET);
   variable new_tar;
   variable dmg;
   variable atkr_tile = tile_num(attacker);
   variable len = len_array(Line_targets_array);
   variable flags;
   variable i;
   for (i = laser_target_num_key; i < len; i++) begin
      new_tar = array_key(Line_targets_array, laser_target_num_key);
      if new_tar > 0 then begin
         laser_target_num_key = i+1;
         break;
      end
   end
   if new_tar > 0 then begin
      if new_tar != attacker then begin
         dmg = get_array(Line_targets_array, new_tar);
         if dmg >= 0 then begin
            flags = dmg / DMG_FLAG_MULT;
            dmg = dmg % DMG_FLAG_MULT;
            if new_tar != target then
               call add_to_export_arr(new_tar, dmg);
         end
         if dmg == DMG_ZERO then
            dmg = 0;

         call critter_inflict_dmg(new_tar, attacker, dmg, DMG_laser, flags, atkr_tile);
      end
   end
end

procedure create_hidden_projectile(variable cur_proj_pid, variable cur_rot, variable cur_frame = 0, variable is_laser = 0, variable cur_ldist = -1, variable cur_lint = -1) begin
   variable projectile = create_object_sid(cur_proj_pid, 0, 0, -1);
   if gWeaponDamageType == DMG_electrical orElse gWeaponDamageType == DMG_emp then begin
      if is_laser > 0 then begin
         set_object_data(projectile, OBJ_DATA_FID, LaserFID);
         set_flags(projectile, FLAGS_OBJECT_PROJECTILE bwor FLAG_TRANSGLASS);
      end else
         set_flags(projectile, FLAGS_OBJECT_PROJECTILE);

      set_outline(projectile, OUTLINE_BLINKING_CYAN);
   end
   if gWeaponDamageType == DMG_plasma then begin
      if is_laser > 0 then begin
         set_flags(projectile, FLAGS_OBJECT_PROJECTILE bwor FLAG_TRANSENERGY);
         set_outline(projectile, OUTLINE_GREEN_GLOW);
      end else
         set_flags(projectile, FLAGS_OBJECT_PROJECTILE);
   end
   else begin
      set_flags(projectile, FLAGS_OBJECT_PROJECTILE);
      if is_laser > 0 then begin
         set_object_data(projectile, OBJ_DATA_FID, LaserFID);
         set_outline(projectile, OUTLINE_BLINKING_ORANGE);
      end
   end
   set_object_data(projectile, OBJ_DATA_ROTATION, cur_rot);
   if cur_frame > 0 then
      set_object_data(projectile, OBJ_DATA_CUR_FRM, (cur_frame));

   if cur_ldist >= 0 then
      set_object_data(projectile, OBJ_DATA_LIGHT_DISTANCE, cur_ldist);
   if cur_lint >= 0 then
      set_object_data(projectile, OBJ_DATA_LIGHT_INTENSITY, cur_lint);
   return projectile;
end


procedure laser_line_dmg_anim(variable attacker, variable target, variable new_tar_tile, variable max_frames_projectile) begin
   variable atkr_tile = tile_num(attacker);
   variable target_tile = tile_num(target);
   variable attacker_elev = elevation(attacker);
   variable rot_atk_to_tar = rotation_to_tile(atkr_tile, target_tile);
   variable projectile;
   variable projectile_pid;
   variable placeholder;
   variable start_tile = tile_num_in_direction(atkr_tile, rot_atk_to_tar, 1);

   placeholder = create_object_sid(PID_PROJ_LASER, 0, attacker_elev, -1);
   set_object_data(placeholder, OBJ_DATA_FID, gAttackerFid);
   set_flags(placeholder, FLAGS_GHOST_OBJECT);


   if gProjToHideOnTargetHit > 0 then
      projectile_pid = obj_pid(gProjToHideOnTargetHit);
   else
      projectile_pid = PID_PROJ_LASER;

   projectile = create_hidden_projectile(projectile_pid, rot_atk_to_tar, (max_frames_projectile - 1), true);


   reg_anim_combat_check(0);
   reg_anim_clear_forced(placeholder);
   reg_anim_clear_forced(projectile);
   reg_anim_func(REG_ANIM_BEGIN, RB_RESERVED);
   reg_anim_turn_towards(placeholder, target_tile, -1);
   reg_anim_animate(placeholder, ANIM_point, -1);
   //reg_anim_animate_and_move(projectile, new_tar_tile, ANIM_walk, (weapon_point_max_frames));
   reg_anim_animate_and_move(projectile, new_tar_tile, ANIM_walk, -1);
   reg_anim_callback(callback_laser_line_dmg_anim);
   reg_anim_destroy(projectile);
   reg_anim_destroy(placeholder);
   reg_anim_end();
   move_to(projectile, start_tile, attacker_elev);
end

procedure callback_electrical_chain_dmg_clear_outline begin
   variable obj;
   variable obj_orig_outline;
   variable cur_key;
   variable cur_outline_array;
   if not(array_exists(gPulseTileRefreshOutlineArray)) then
      return;

   foreach (cur_key : cur_outline_array in gPulseTileRefreshOutlineArray) begin
      if array_exists(cur_outline_array) andAlso len_array(cur_outline_array) > 0 then begin
         foreach obj : obj_orig_outline in cur_outline_array begin
            if obj <= 0 then continue;
            if obj_orig_outline == DMG_ZERO then
               obj_orig_outline = 0;

            set_outline(obj, obj_orig_outline);
         end

         set_array(gPulseTileRefreshOutlineArray, cur_key, 0);
         free_array(cur_outline_array);
         if ElecSameTargets < 0 then
            tile_refresh_display;
         return;
      end
   end
end

procedure callback_tile_refresh_display begin
   tile_refresh_display;
end

//procedure get_back_and_forth_tile(variable current_index) begin
   //variable arr_len = len_array(gPulseTileAttackedArray);
   //variable next_index;
   //variable next_tile;
   //if arr_len <= 1 then
      //return 0;
//
   //next_index = current_index + gPulseBackward;
//
   //if next_index < 0 then begin
      //gPulseBackward = 1;
      //next_index = 1;
   //end else if next_index >= arr_len then begin
      //gPulseBackward = -1;
      //next_index = arr_len - 2;
   //end
//
   //if next_index < 0 orElse next_index >= arr_len then
      //return 0;
//
   //next_tile = array_key(gPulseTileAttackedArray, next_index);
//
   //if next_tile > 0 then begin
      //gPulseBackwardKey = next_index;
      //gPulseTileAttackedCount += 1;
      //return next_tile;
   //end
//
   //return 0;
//end

procedure get_next_chain_tile(variable cur_tile, variable cur_elevation, variable lof_check_obj) begin
   variable critter;
   variable critter_tile;
   variable distance;
   variable blocker;
   variable is_alive;
   variable radius;
   variable critters_in_radius;
   variable result_tile;
   variable critter_cur_anim;
   variable living_map;
   variable dead_map;
   variable min_living_dist;
   variable min_dead_dist;
   variable max_allowed_dist;
   variable possible_map;
   variable possible_array;
   variable possible_count;
   variable selected_index;
   variable temp_critter;
   variable temp_distance;
   variable arr_len;
   variable was_attacked;
   variable living_map_attacked;
   variable min_living_attacked_dist;
   variable distance_diff;
   variable chance_for_attacked;
   variable target_map;
   variable target_min_dist;

   if gPulseTileAttackedCount >= ElecMaxTargets then
      return 0;

   //if gPulseBackward != 0 then return
      //get_back_and_forth_tile(gPulseBackwardKey);

   min_living_dist = 999;
   min_dead_dist = 999;
   min_living_attacked_dist = 999;
   radius = ElecRadius;
   critters_in_radius = objects_in_radius(cur_tile, radius, cur_elevation, OBJ_TYPE_CRITTER);

   foreach critter in critters_in_radius begin
      if critter <= 0 then
         continue;

      critter_tile = tile_num(critter);
      was_attacked = 0;

      if ElecSameTargets <= 1 then begin
         if get_array(gPulseTileAttackedArray, critter_tile) > 0 then begin
            if ElecSameTargets>= 1 then
               was_attacked = 1;
            else
               continue;
         end
      end

      if not(obj_is_visible_flag(critter)) then
         continue;

      if critter_tile == cur_tile then
         continue;

      blocker = get_electricity_path_block(lof_check_obj, critter);
      if blocker > 0 then
         continue;

      is_alive = (get_critter_stat(critter, STAT_current_hp) > 0 andAlso
                  not(is_dead(critter)) andAlso
                  get_array(death_array, critter) <= 0);

      if is_alive <= 0 and was_attacked then
         continue;

      distance = tile_distance(cur_tile, critter_tile);

      if is_alive then begin
         if was_attacked then begin
            if living_map_attacked == 0 then
               living_map_attacked = create_array_map;

            set_array(living_map_attacked, critter, distance);
            if distance < min_living_attacked_dist then
               min_living_attacked_dist = distance;
         end
         else begin
            if living_map == 0 then
               living_map = create_array_map;

            set_array(living_map, critter, distance);
            if distance < min_living_dist then
               min_living_dist = distance;
         end
      end
      else begin
         critter_cur_anim = art_anim(obj_art_fid(critter));
         if critter_cur_anim == ANIM_electrified_to_nothing_sf orElse
            critter_cur_anim == ANIM_exploded_to_nothing_sf then
               continue;

         if dead_map == 0 then
            dead_map = create_array_map;

         set_array(dead_map, critter, distance);
         if distance < min_dead_dist then
            min_dead_dist = distance;
      end
   end

   free_array(critters_in_radius);

   possible_map = create_array_map;
   possible_count = 0;

   if living_map != 0 then begin
      if min_dead_dist * 2 < min_living_dist then begin
         target_map = dead_map;
         target_min_dist = min_dead_dist;
      end
      else begin
         target_map = living_map;
         target_min_dist = min_living_dist;
      end
   end

   else if len_array(living_map_attacked) > 0 orElse len_array(dead_map) > 0 then begin
      if len_array(living_map_attacked) > 0 andAlso len_array(dead_map) > 0 then begin
         distance_diff = min_dead_dist - min_living_attacked_dist;


         if min_dead_dist * 2 < min_living_attacked_dist then begin
            chance_for_attacked = 20; //     
         end
         else if min_living_attacked_dist * 2 < min_dead_dist then begin
            chance_for_attacked = 80; //     
         end
         else begin
            chance_for_attacked = 50 + (distance_diff * 10);
            if chance_for_attacked < 20 then chance_for_attacked = 20;
         end

         if random(1, 100) <= chance_for_attacked then begin
            target_map = living_map_attacked;
            target_min_dist = min_living_attacked_dist;
         end
         else begin
            target_map = dead_map;
            target_min_dist = min_dead_dist;
         end
      end
      else if len_array(living_map_attacked) > 0 then begin
         target_map = living_map_attacked;
         target_min_dist = min_living_attacked_dist;
      end
      else begin
         target_map = dead_map;
         target_min_dist = min_dead_dist;
      end
   end

   if target_map != 0 then begin
      max_allowed_dist = target_min_dist / 2 + 1;

      foreach temp_critter:temp_distance in target_map begin
         if temp_distance <= target_min_dist + max_allowed_dist then begin
            set_array(possible_map, temp_critter, tile_num(temp_critter));
            possible_count += 1;
         end
      end
   end

   if possible_count > 0 then begin
      possible_array = create_array(possible_count * 2, 0);
      possible_count = 0;

      foreach temp_critter:critter_tile in possible_map begin
         set_array(possible_array, possible_count * 2, critter_tile);
         set_array(possible_array, possible_count * 2 + 1, temp_critter);
         possible_count += 1;
      end

      selected_index = random(0, possible_count - 1);
      result_tile = get_array(possible_array, selected_index * 2);
      critter = get_array(possible_array, selected_index * 2 + 1);

      if get_array(living_map, critter) > 0 then
         gPulseTileNextDistance = get_array(living_map, critter);
      else if get_array(living_map_attacked, critter) > 0 then
         gPulseTileNextDistance = get_array(living_map_attacked, critter);
      else if get_array(dead_map, critter) > 0 then
         gPulseTileNextDistance = get_array(dead_map, critter);

      free_array(possible_array);
   end

   if living_map != 0 then free_array(living_map);
   if dead_map != 0 then free_array(dead_map);
   if living_map_attacked != 0 then free_array(living_map_attacked);
   if possible_map != 0 then free_array(possible_map);

   if result_tile > 0 then begin
      if ElecSameTargets <= 1 then begin
         set_array(gPulseTileAttackedArray, result_tile, 1);
         if ElecSameTargets < 0 then
            gPulseNextTileCritter = critter;
      end
      gPulseTileAttackedCount += 1;
      return result_tile;
   end
   else if ElecSameTargets == 1 then begin
      arr_len = len_array(gPulseTileAttackedArray);
      if arr_len > 1 then begin
         clear_array(gPulseTileAttackedArray);
         set_array(gPulseTileAttackedArray, cur_tile, 1);
         return get_next_chain_tile(cur_tile, cur_elevation, lof_check_obj);
      end
   end

   return 0;
end

procedure get_next_chain_tile_ikd(variable cur_tile, variable cur_elevation, variable lof_check_obj) begin
   variable critter;
   variable critter_tile;
   variable distance;
   variable blocker;
   variable is_alive;
   variable radius;
   variable critters_in_radius;
   variable result_tile;
   variable critter_cur_anim;
   variable living_map;
   variable dead_map;
   variable min_living_dist;
   variable min_dead_dist;
   variable max_allowed_dist;
   variable possible_map;
   variable possible_array;
   variable possible_count;
   variable selected_index;
   variable temp_critter;
   variable temp_distance;
   variable arr_len;
   variable was_attacked;
   variable living_map_attacked;
   variable min_living_attacked_dist;
   variable distance_diff;
   variable chance_for_attacked;
   variable target_map; //     
   variable target_min_dist; //     

   if gPulseTileAttackedCount >= ElecMaxTargets then
      return 0;

   //if gPulseBackward != 0 then return
      //get_back_and_forth_tile(gPulseBackwardKey);

   min_living_dist = 999;
   min_dead_dist = 999;
   min_living_attacked_dist = 999;
   radius = ElecRadius;
   critters_in_radius = objects_in_radius(cur_tile, radius, cur_elevation, OBJ_TYPE_CRITTER);

   foreach critter in critters_in_radius begin
      if critter <= 0 then
         continue;

      critter_tile = tile_num(critter);
      was_attacked = 0;

      if ElecSameTargets <= 1 then begin
         if get_array(gPulseTileAttackedArray, critter_tile) > 0 then begin
            if ElecSameTargets>= 1 then
               was_attacked = 1;
            else
               continue;
         end
      end

      if not(obj_is_visible_flag(critter)) then
         continue;

      if critter_tile == cur_tile then
         continue;

      blocker = get_electricity_path_block(lof_check_obj, critter);
      if blocker > 0 then
         continue;

      is_alive = (get_critter_stat(critter, STAT_current_hp) > 0 andAlso
                  not(is_dead(critter)) andAlso
                  get_array(death_array, critter) <= 0);

      if is_alive <= 0 and was_attacked then
         continue;

      distance = tile_distance(cur_tile, critter_tile);

      if is_alive then begin
         if was_attacked then begin
            if living_map_attacked == 0 then
               living_map_attacked = create_array_map;

            set_array(living_map_attacked, critter, distance);
            if distance < min_living_attacked_dist then
               min_living_attacked_dist = distance;
         end
         else begin
            if living_map == 0 then
               living_map = create_array_map;

            set_array(living_map, critter, distance);
            if distance < min_living_dist then
               min_living_dist = distance;
         end
      end
      else begin
         critter_cur_anim = art_anim(obj_art_fid(critter));
         if critter_cur_anim == ANIM_electrified_to_nothing_sf orElse
            critter_cur_anim == ANIM_exploded_to_nothing_sf then
               continue;

         if dead_map == 0 then
            dead_map = create_array_map;

         set_array(dead_map, critter, distance);
         if distance < min_dead_dist then
            min_dead_dist = distance;
      end
   end

   free_array(critters_in_radius);

   possible_map = create_array_map;
   possible_count = 0;

   //  1:    
   if living_map != 0 then begin
      target_map = living_map;
      target_min_dist = min_living_dist;
   end
   //  2:    
   else if len_array(living_map_attacked) > 0 orElse len_array(dead_map) > 0 then begin
      //    
      if len_array(living_map_attacked) > 0 andAlso len_array(dead_map) > 0 then begin
         //   -  
         distance_diff = min_dead_dist - min_living_attacked_dist;
         chance_for_attacked = 50 + (distance_diff * 10);
         if chance_for_attacked < 20 then chance_for_attacked = 20;

         if random(1, 100) <= chance_for_attacked then begin
            target_map = living_map_attacked;
            target_min_dist = min_living_attacked_dist;
         end
         else begin
            target_map = dead_map;
            target_min_dist = min_dead_dist;
         end
      end
      else if len_array(living_map_attacked) > 0 then begin
         //   
         target_map = living_map_attacked;
         target_min_dist = min_living_attacked_dist;
      end
      else begin
         //  
         target_map = dead_map;
         target_min_dist = min_dead_dist;
      end
   end

   //     
   if target_map != 0 then begin
      max_allowed_dist = target_min_dist / 2 + 1;

      foreach temp_critter:temp_distance in target_map begin
         if temp_distance <= target_min_dist + max_allowed_dist then begin
            set_array(possible_map, temp_critter, tile_num(temp_critter));
            possible_count += 1;
         end
      end
   end

   if possible_count > 0 then begin
      possible_array = create_array(possible_count * 2, 0);
      possible_count = 0;

      foreach temp_critter:critter_tile in possible_map begin
         set_array(possible_array, possible_count * 2, critter_tile);
         set_array(possible_array, possible_count * 2 + 1, temp_critter);
         possible_count += 1;
      end

      selected_index = random(0, possible_count - 1);
      result_tile = get_array(possible_array, selected_index * 2);
      critter = get_array(possible_array, selected_index * 2 + 1);

      if get_array(living_map, critter) > 0 then
         gPulseTileNextDistance = get_array(living_map, critter);
      else if get_array(living_map_attacked, critter) > 0 then
         gPulseTileNextDistance = get_array(living_map_attacked, critter);
      else if get_array(dead_map, critter) > 0 then
         gPulseTileNextDistance = get_array(dead_map, critter);

      free_array(possible_array);
   end

   if living_map != 0 then free_array(living_map);
   if dead_map != 0 then free_array(dead_map);
   if living_map_attacked != 0 then free_array(living_map_attacked);
   if possible_map != 0 then free_array(possible_map);

   if result_tile > 0 then begin
      if ElecSameTargets <= 1 then begin
         set_array(gPulseTileAttackedArray, result_tile, 1);
         if ElecSameTargets < 0 then
            gPulseNextTileCritter = critter;
      end
      gPulseTileAttackedCount += 1;
      return result_tile;
   end
   else if ElecSameTargets == 1 then begin
      arr_len = len_array(gPulseTileAttackedArray);
      if arr_len > 1 then begin
         clear_array(gPulseTileAttackedArray);
         set_array(gPulseTileAttackedArray, cur_tile, 1);
         return get_next_chain_tile(cur_tile, cur_elevation, lof_check_obj);
      end
   end

   return 0;
end

procedure get_next_chain_tile_old2(variable cur_tile, variable cur_elevation, variable lof_check_obj) begin
   variable critter;
   variable critter_tile;
   variable distance;
   variable blocker;
   variable is_alive;
   variable radius;
   variable critters_in_radius;
   variable result_tile;
   variable critter_cur_anim;
   variable living_map;
   variable dead_map;
   variable min_living_dist;
   variable min_dead_dist;
   variable max_allowed_dist;
   variable possible_map;
   variable possible_array;
   variable possible_count;
   variable selected_index;
   variable temp_critter;
   variable temp_distance;
   variable arr_len;
   variable was_attacked;
   variable living_map_attacked;
   variable min_living_attacked_dist;
   variable distance_diff;
   variable chance_for_attacked;

   if gPulseTileAttackedCount >= ElecMaxTargets then
      return 0;

   //if gPulseBackward != 0 then return
   //get_back_and_forth_tile(gPulseBackwardKey);

   min_living_dist = 999;
   min_dead_dist = 999;
   min_living_attacked_dist = 999;
   radius = ElecRadius;
   critters_in_radius = objects_in_radius(cur_tile, radius, cur_elevation, OBJ_TYPE_CRITTER);

   foreach critter in critters_in_radius begin
      if critter <= 0 then
         continue;

      critter_tile = tile_num(critter);
      was_attacked = 0;

      if ElecSameTargets <= 1 then begin
         if get_array(gPulseTileAttackedArray, critter_tile) > 0 then
            was_attacked = 1;
      end

      if not(obj_is_visible_flag(critter)) then
         continue;

      if critter_tile == cur_tile then
         continue;

      blocker = get_electricity_path_block(lof_check_obj, critter);
      if blocker > 0 then
         continue;

      is_alive = (get_critter_stat(critter, STAT_current_hp) > 0 andAlso
                  not(is_dead(critter)) andAlso
                  get_array(death_array, critter) <= 0);

      if is_alive <= 0 and was_attacked then
         continue;

      distance = tile_distance(cur_tile, critter_tile);

      if is_alive then begin
         if was_attacked then begin
            if living_map_attacked == 0 then
               living_map_attacked = create_array_map;

            set_array(living_map_attacked, critter, distance);
            if distance < min_living_attacked_dist then
               min_living_attacked_dist = distance;
         end
         else begin
            if living_map == 0 then
               living_map = create_array_map;

            set_array(living_map, critter, distance);
            if distance < min_living_dist then
               min_living_dist = distance;
         end
      end
      else begin
         critter_cur_anim = art_anim(obj_art_fid(critter));
         if critter_cur_anim == ANIM_electrified_to_nothing_sf orElse
            critter_cur_anim == ANIM_exploded_to_nothing_sf then
               continue;

         if dead_map == 0 then
            dead_map = create_array_map;

         set_array(dead_map, critter, distance);
         if distance < min_dead_dist then
            min_dead_dist = distance;
      end
   end

   free_array(critters_in_radius);

   possible_map = create_array_map;
   possible_count = 0;

   if living_map != 0 then begin
      max_allowed_dist = min_living_dist / 2 + 1;

      foreach temp_critter:temp_distance in living_map begin
         if temp_distance <= min_living_dist + max_allowed_dist then begin
            set_array(possible_map, temp_critter, tile_num(temp_critter));
            possible_count += 1;
         end
      end
   end

   if possible_count == 0 then begin
      if len_array(living_map_attacked) > 0 andAlso len_array(dead_map) > 0 then begin
         distance_diff = min_dead_dist- min_living_attacked_dist;
         chance_for_attacked = 50 + (distance_diff * 10);
         if chance_for_attacked < 20 then chance_for_attacked = 20;

         if random(1, 100) <= chance_for_attacked then begin
            max_allowed_dist = min_living_attacked_dist / 2 + 1;

            foreach temp_critter:temp_distance in living_map_attacked begin
               if temp_distance <= min_living_attacked_dist + max_allowed_dist then begin
                  set_array(possible_map, temp_critter, tile_num(temp_critter));
                  possible_count += 1;
               end
            end
         end
         else begin
            max_allowed_dist = min_dead_dist / 2 + 1;

            foreach temp_critter:temp_distance in dead_map begin
               if temp_distance <= min_dead_dist + max_allowed_dist then begin
                  set_array(possible_map, temp_critter, tile_num(temp_critter));
                  possible_count += 1;
               end
            end
         end
      end
      else if len_array(living_map_attacked) > 0 then begin
         max_allowed_dist = min_living_attacked_dist / 2 + 1;

         foreach temp_critter:temp_distance in living_map_attacked begin
            if temp_distance <= min_living_attacked_dist + max_allowed_dist then begin
               set_array(possible_map, temp_critter, tile_num(temp_critter));
               possible_count += 1;
            end
         end
      end
      else if len_array(dead_map) > 0 then begin
         max_allowed_dist = min_dead_dist / 2 + 1;

         foreach temp_critter:temp_distance in dead_map begin
            if temp_distance <= min_dead_dist + max_allowed_dist then begin
               set_array(possible_map, temp_critter, tile_num(temp_critter));
               possible_count += 1;
            end
         end
      end
   end

   if possible_count > 0 then begin
      possible_array = create_array(possible_count * 2, 0);
      possible_count = 0;

      foreach temp_critter:critter_tile in possible_map begin
         set_array(possible_array, possible_count * 2, critter_tile);
         set_array(possible_array, possible_count * 2 + 1, temp_critter);
         possible_count += 1;
      end

      selected_index = random(0, possible_count - 1);
      result_tile = get_array(possible_array, selected_index * 2);
      critter = get_array(possible_array, selected_index * 2 + 1);

      if get_array(living_map, critter) > 0 then
         gPulseTileNextDistance = get_array(living_map, critter);
      else if get_array(living_map_attacked, critter) > 0 then
         gPulseTileNextDistance = get_array(living_map_attacked, critter);
      else if get_array(dead_map, critter) > 0 then
         gPulseTileNextDistance = get_array(dead_map, critter);

      free_array(possible_array);
   end

   if living_map != 0 then free_array(living_map);
   if dead_map != 0 then free_array(dead_map);
   if living_map_attacked != 0 then free_array(living_map_attacked);
   if possible_map != 0 then free_array(possible_map);

   if result_tile > 0 then begin
      if ElecSameTargets <= 1 then begin
         set_array(gPulseTileAttackedArray, result_tile, 1);
         if ElecSameTargets < 0 then
            gPulseNextTileCritter = critter;
      end
      gPulseTileAttackedCount += 1;
      return result_tile;
   end
   else if ElecSameTargets == 1 then begin
      arr_len = len_array(gPulseTileAttackedArray);
      if arr_len > 1 then begin
         clear_array(gPulseTileAttackedArray);
         set_array(gPulseTileAttackedArray, cur_tile, 1);
         return get_next_chain_tile(cur_tile, cur_elevation, lof_check_obj);
      end
   end

   return 0;
end

procedure set_noblock_flag_for_obj(variable obj) begin
   variable obj_flags;
   variable obj_mask;

   if not(array_exists(noblock_obj_array)) then
      noblock_obj_array = create_array_map;

   obj_flags = get_flags(obj);
   if (obj_flags bwand FLAG_NOBLOCK) == 0 then begin
      obj_mask = MASK_NO_NOBLOCK;

      set_array(noblock_obj_array, obj, obj_mask);

      set_flags(obj, obj_flags bwor FLAG_NOBLOCK);
   end

   noblock_was_set = 1;
end

procedure remove_added_flag_noblock_for_objs begin
   variable obj;
   variable mask;

   if noblock_was_set > 0 then begin
      foreach (obj:mask in noblock_obj_array) begin
         if mask == 0 then
            continue;

         if mask != 0 then begin
            set_flags(obj, get_flags(obj) bwand mask);
         end
      end
      noblock_was_set = 0;
      clear_array(noblock_obj_array);
   end
end

procedure destroy_all_EMP_expl begin
   variable expl;
   variable value;
   if len_array(gPulseExplToDestroyArray) > 0 then begin
      foreach expl : value in gPulseExplToDestroyArray begin
         if expl > 0 then begin
            destroy_object(expl);
         end
      end
      clear_array(gPulseExplToDestroyArray);
   end
end

procedure callback_electrical_chain_dmg_next_tile begin
   variable attacker = get_object_data(combat_data, C_ATTACK_SOURCE);
   variable target = get_object_data(combat_data, C_ATTACK_TARGET);
   variable target_elevation;
   variable dmg;
   variable dead_attacker;
   variable emp_expl;
   variable flags;
   variable critters_on_tile;
   variable target_type;
   variable check_tile;
   variable obj;
   variable objs_on_tile;
   variable object_type;
   variable proj;
   variable lof_check_obj;
   variable full_path;
   variable first_obj;
   variable expl_on_path;
   variable cur_tile;
   variable cur_rot;
   variable obj_orig_outline;
   variable obj_orig_outline_array = create_array_map;
   variable anim_count;
   variable count;
   variable max_count;
   variable CombatHighlight = read_int(0x56D38C);
   variable obj_orig_outline_low;
   if attacker <= 0 orElse target <= 0 then
      return;

   if obj_type(target) != OBJ_TYPE_CRITTER then begin
      play_sfx("MAFEYEZQ");
      return;
   end

   if gPulseTileNext > 0 then
      check_tile = gPulseTileNext;

   if check_tile <= 0 then
      return;
   if ElecSameTargets < 0 then begin
      play_sfx("MAFEYEZQ");
   end

   tile_refresh_display_disable;
   target_elevation = elevation(target);
   objs_on_tile = tile_get_objs(check_tile, target_elevation);

   foreach obj in objs_on_tile begin
      if obj <= 0 orElse not(obj_is_visible_flag(obj)) then
         continue;

      object_type = obj_type(obj);
      if object_type == OBJ_TYPE_CRITTER then begin
         if get_array(obj_orig_outline_array, obj) == 0 then begin
            obj_orig_outline = get_outline(obj);
            obj_orig_outline_low = (obj_orig_outline bwand OUTLINE_TYPE_MASK);
            if obj_orig_outline == 0 orElse (CombatHighlight != 1 andAlso obj != attacker andAlso obj_orig_outline_low != OUTLINE_GREY andAlso obj_orig_outline_low != OUTLINE_YELLOW andAlso obj_orig_outline_low <= OUTLINE_DARK_YELLOW) then
               obj_orig_outline = DMG_ZERO;
         end
         else
            obj_orig_outline = 0;

         if obj_orig_outline != 0 andAlso obj_orig_outline != OUTLINE_BLINKING_CYAN then
            set_array(obj_orig_outline_array, obj, obj_orig_outline);

         dmg = calc_dmg_electric(attacker, obj, false);

         if dmg > DMG_FLAG_MULT then begin
            flags = dmg / DMG_FLAG_MULT;
            dmg = dmg % DMG_FLAG_MULT;
            if obj == target andAlso gPulseTileAttackedCount > 0 then begin
               write_int(combat_data + C_ATTACK_DAMAGE_TARGET, read_int(combat_data + C_ATTACK_DAMAGE_TARGET) + dmg);
               write_int(combat_data + C_ATTACK_FLAGS_TARGET, read_int(combat_data + C_ATTACK_FLAGS_TARGET) bwor flags);
            end
            else if obj == attacker then begin
               write_int(combat_data + C_ATTACK_DAMAGE_SOURCE, read_int(combat_data + C_ATTACK_DAMAGE_SOURCE) + dmg);
               write_int(combat_data + C_ATTACK_FLAGS_SOURCE, read_int(combat_data + C_ATTACK_FLAGS_SOURCE) bwor flags);
            end
         end else
            flags = 0;

         call critter_inflict_dmg(obj, attacker, dmg, DMG_electrical, flags, check_tile);
         //if obj_orig_outline != OUTLINE_BLINKING_CYAN then
            set_outline(obj, OUTLINE_BLINKING_CYAN);
         lof_check_obj = obj;
      end
      else if (object_type == OBJ_TYPE_ITEM orElse object_type == OBJ_TYPE_SCENERY) then begin
         obj_orig_outline = get_outline(obj);
         if obj_orig_outline == 0 then
            obj_orig_outline = DMG_ZERO;
         if get_array(obj_orig_outline_array, obj) == 0 andAlso obj_orig_outline != OUTLINE_BLINKING_CYAN then
            set_array(obj_orig_outline_array, obj, obj_orig_outline);
         if obj_orig_outline != OUTLINE_BLINKING_CYAN then
            set_outline(obj, OUTLINE_BLINKING_CYAN);
      end
      call set_noblock_flag_for_obj(obj);
   end

   free_array(objs_on_tile);

   set_array(gPulseTileRefreshOutlineArray, gPulseTileAttackedCount, obj_orig_outline_array);

   emp_expl = create_object_sid(PID_EXPLOSION_EMP_1, check_tile, target_elevation, -1);
   set_object_data(emp_expl, OBJ_DATA_FID, TRNBLK_FID);
   if sfall_510 > 0 then begin
      set_flags(emp_expl, FLAGS_OBJECT_PROJECTILE);
      set_object_data(emp_expl, OBJ_DATA_LIGHT_DISTANCE, 5);
      set_object_data(emp_expl, OBJ_DATA_LIGHT_INTENSITY, 0x4000);
   end
   else
      set_flags(emp_expl, FLAGS_OBJECT_PROJECTILE_visible);

   set_outline(emp_expl, OUTLINE_BLINKING_CYAN);
   reg_anim_combat_check(0);
   reg_anim_begin();
   if ElecSameTargets >= 0 then
      reg_anim_play_sfx(emp_expl, "MAFEYEZQ", 0);
   reg_anim_unset_flag(emp_expl, OBJECT_HIDDEN, 0);
   reg_anim_animate_and_hide(emp_expl, ANIM_stand, 0);
   if ElecSameTargets < 0 andAlso gPulseTileAttackedCount <= 0 then
      reg_anim_callback(destroy_all_EMP_expl);
   //reg_anim_animate_reverse(emp_expl, ANIM_stand, -1);
   reg_anim_callback(callback_electrical_chain_dmg_clear_outline);
   //reg_anim_animate(emp_expl, ANIM_stand, 3);
   reg_anim_destroy(emp_expl);
   if gPulseTileAttackedCount <= 0 then
      reg_anim_callback(callback_tile_refresh_display);
   reg_anim_end();


   gPulseNextTileCritter = 0;
   gPulseTileNext = get_next_chain_tile(check_tile, target_elevation, lof_check_obj);
   if gPulseNextTileCritter > 0 andAlso gPulseTileNext > 0 then begin
      full_path = path_find_to(gPulseNextTileCritter, check_tile, BLOCKING_TYPE_BLOCK);
      cur_tile = gPulseTileNext;
   end
   call remove_added_flag_noblock_for_objs;


   if cur_tile > 0 then
      max_count = len_array(full_path);

   if max_count > 0 then begin
      reg_anim_combat_check(0);
      reg_anim_begin();
      foreach cur_rot in full_path begin
         cur_tile = tile_num_in_direction(cur_tile, cur_rot, 1);
         expl_on_path = create_object_sid(PID_EXPLOSION_EMP_1, cur_tile, target_elevation, -1);
         set_object_data(expl_on_path, OBJ_DATA_FID, TRNBLK_FID);
         if sfall_510 > 0 then begin
            set_flags(expl_on_path, FLAGS_OBJECT_PROJECTILE);
            set_object_data(expl_on_path, OBJ_DATA_LIGHT_DISTANCE, 5);
            set_object_data(expl_on_path, OBJ_DATA_LIGHT_INTENSITY, 0x4000);
         end
         else
            set_flags(expl_on_path, FLAGS_OBJECT_PROJECTILE_visible);

         set_outline(expl_on_path, OUTLINE_BLINKING_CYAN);
         set_array(gPulseExplToDestroyArray, expl_on_path, 1);
         reg_anim_unset_flag(expl_on_path, OBJECT_HIDDEN, 0);
         reg_anim_animate_and_hide(expl_on_path, ANIM_stand, 0);
         count++;
         anim_count++;
         if anim_count > 25 andAlso count < max_count then begin
            reg_anim_end();

            anim_count = 0;
            reg_anim_combat_check(0);
            reg_anim_begin();
         end
      end
      reg_anim_end();
   end

   if gPulseTileNext > 0 then begin
      if gPulseNextTileCritter <= 0 then begin
         if ElecSameTargets >= 0 andAlso gPulseTileAttackedCount <= 1 then begin
            call set_combat_speed_elec;
            set_animate_to_move
         end

         proj = create_object_sid(PID_EXPLOSION_EMP_1, check_tile, target_elevation, -1);
         set_object_data(proj, OBJ_DATA_FID, TRNBLK_FID);
         if sfall_510 > 0 then begin
            set_flags(proj, FLAGS_OBJECT_PROJECTILE);
            set_object_data(proj, OBJ_DATA_LIGHT_DISTANCE, 5);
            set_object_data(proj, OBJ_DATA_LIGHT_INTENSITY, 0x4000);
         end
         else
            set_flags(proj, FLAGS_OBJECT_PROJECTILE_visible);

         set_outline(proj, OUTLINE_BLINKING_CYAN);
         reg_anim_combat_check(0);
         reg_anim_begin();
         reg_anim_unset_flag(proj, OBJECT_HIDDEN, -1);
         //if gPulseTileNextDistance <= 6 then begin
            reg_anim_animate(proj, ANIM_stand, -1);
            reg_anim_animate_reverse(proj, ANIM_stand, 0);
         //end
         reg_anim_animate_and_move(proj, gPulseTileNext, ANIM_walk, -1);
         reg_anim_destroy(proj);
         reg_anim_callback(callback_electrical_chain_dmg_next_tile);
         reg_anim_end();
      end
      else
         call callback_electrical_chain_dmg_next_tile;
   end
   else if ElecSameTargets >= 0 then begin
      set_animate_to_move_and_wait
   end
   //else begin
      tile_refresh_display_enable;
      tile_refresh_display;
   //end
end


procedure hide_proj_on_target_hit_and_play_sound(variable attacker, variable target, variable end_tile, variable max_frames_projectile, variable alt_fire_proc) begin
   variable target_tile = tile_num(target);
   variable atkr_tile = tile_num(attacker);
   variable attacker_elev = elevation(attacker);
   variable rot_atk_to_tar = rotation_to_tile(atkr_tile, target_tile);
   variable projectile;
   variable projectile_pid;
   variable placeholder;
   variable start_tile = tile_num_in_direction(atkr_tile, rot_atk_to_tar, 1);
   variable weapon_hit_sfx;
   variable sound_target;
   variable combat_target = get_object_data(combat_data, C_ATTACK_TARGET);
   variable attack_hit_mode = get_object_data(combat_data, C_ATTACK_HIT_MODE);
   if end_tile <= 0 then
      end_tile = target_tile;


   if alt_fire_proc != alt_fire_plasma then begin
      if gSoundHitTarget != 0 then begin
         if obj_type(gSoundHitTarget) != OBJ_TYPE_CRITTER then
            sound_target = gSoundHitTarget;
      end
   end

   if gSoundHitTarget > 0 then
      weapon_hit_sfx = sfx_build_weapon_name(snd_weapon_hitting, gWeapon, attack_hit_mode, sound_target);
   else if alt_fire_proc != alt_fire_gauss andAlso alt_fire_proc != alt_fire_plasma then begin
      sound_target = target;
      weapon_hit_sfx = sfx_build_weapon_name(snd_weapon_hitting, gWeapon, attack_hit_mode, sound_target);
   end

   placeholder = create_object_sid(PID_PROJ_LASER, 0, 0, -1);
   set_object_data(placeholder, OBJ_DATA_FID, gAttackerFid);
   set_flags(placeholder, FLAGS_GHOST_OBJECT);



   if gProjToHideOnTargetHit != 0 then begin
      projectile_pid = obj_pid(gProjToHideOnTargetHit);
      projectile = create_hidden_projectile(projectile_pid, rot_atk_to_tar, (max_frames_projectile - 1), alt_fire_proc == alt_fire_laser);
   end
   reg_anim_combat_check(0);
   reg_anim_func(REG_ANIM_BEGIN, RB_RESERVED);
   reg_anim_turn_towards(placeholder, target_tile, -1);
   reg_anim_animate(placeholder, ANIM_point, -1);
   if projectile != 0 then begin
      //if alt_fire_proc == alt_fire_laser orElse alt_fire_proc == alt_fire_plasma orElse (alt_fire_proc == alt_fire_gauss andAlso sfall_510 <= 0) then
         reg_anim_animate_and_move(projectile, target_tile, ANIM_walk, -1);
      //else
         //reg_anim_animate_and_move(projectile, target_tile, ANIMATE_RUN, (weapon_point_max_frames));
      if end_tile != target_tile then
         reg_anim_animate_and_move(projectile, end_tile, ANIM_walk, -1);
      else
         weapon_hit_sfx = 0;
   end
   reg_anim_animate_reverse(placeholder, ANIM_point, -1);
   reg_anim_animate(placeholder, ANIM_point, 1);
   reg_anim_callback(set_lvar_proj_hidden);
   if alt_fire_proc == alt_fire_plasma then begin
      reg_anim_callback(plasma_alt_explosion);
   end
   else if weapon_hit_sfx != 0 then begin
      if projectile > 0 then
         reg_anim_play_sfx(projectile, weapon_hit_sfx, -1);
      else if sound_target > 0 then
         reg_anim_play_sfx(sound_target, weapon_hit_sfx, -1);
   end
   if alt_fire_proc == alt_fire_pulse then begin
      reg_anim_callback(callback_electrical_chain_dmg_next_tile);
   end
   alt_atk_wait_for_report = 1;
   reg_anim_callback(add_show_dmg_timer);
   reg_anim_destroy(placeholder);
   if projectile != 0 then begin
      reg_anim_destroy(projectile);
      move_to(projectile, start_tile, attacker_elev);
   end
   reg_anim_end();

end

procedure laser_line_dmg(variable attacker,variable target, variable new_end_tile = 0) begin
   variable atkr_tile;
   variable attacker_elev;
   variable real_orig_target_tile;
   variable tar_tile;
   variable atkr_rot;
   variable start_tile;
   variable new_tar;
   variable new_tar_tile;
   variable dmg;
   variable projectile;
   variable projectile_pid = gWeaponProjPid;
   variable wpn_sfx_attack;
   variable dmg_to_tar;
   variable close_range;
   variable max_frames_projectile;
   variable target_cur_fid;
   variable target_cur_frm;
   variable target_cur_rot;
   variable target_cur_X;
   variable target_cur_Y;
   variable target_will_die;
   variable target_outline;
   variable target_elevation;
   variable target_pid;
   variable target_pid_flags = -5;
   if obj_type(target) == OBJ_TYPE_CRITTER then begin
      if (get_object_data(combat_data, C_ATTACK_FLAGS_TARGET) bwand DAM_DEAD) != 0 orElse get_critter_stat(target, STAT_current_hp) < get_object_data(combat_data, C_ATTACK_DAMAGE_TARGET) then begin
         target_pid = obj_pid(target);
         target_pid_flags = get_proto_data(target_pid, PROTO_CR_FLAGS);
         if target_pid_flags bwand CFLG_NODROP == 0 then
            set_proto_data(target_pid, PROTO_CR_FLAGS, target_pid_flags bwor CFLG_NODROP);
         else
            target_pid_flags = -5;

         tile_refresh_display_disable;
         target_will_die = 1;
         target_cur_fid = get_object_data(target, OBJ_DATA_FID);
         target_cur_frm = get_object_data(target, OBJ_DATA_CUR_FRM);
         target_cur_rot = get_object_data(target, OBJ_DATA_ROTATION);
         target_cur_X =  get_object_data(target, OBJ_DATA_CUR_X);
         target_cur_Y =  get_object_data(target, OBJ_DATA_CUR_Y);
         target_outline = get_outline(target);
         target_elevation = elevation(target);
      end
   end
   atkr_tile = tile_num(attacker);
   attacker_elev = elevation(attacker);
   real_orig_target_tile = tile_num(real_orig_target);
   tar_tile = tile_num(target);
   atkr_rot = rotation_to_tile(atkr_tile, tar_tile);
   start_tile = tile_num_in_direction(atkr_tile, atkr_rot, 1);
   wpn_sfx_attack = sfx_build_weapon_name(snd_weapon_attack, gWeapon, hit_right_weapon_primary, target);


   if new_end_tile <= 0 then
      new_end_tile = tar_tile;


   laser_target_num_key = 0;
   gAllowProjHitSound = 1;
   call set_combat_speed_laser;


   gAttackerFid = obj_art_fid(attacker);
   gAttackerFlags = get_flags(attacker);

   if projectile_pid <= 0 then
      projectile_pid = PID_PROJ_LASER;


   projectile = create_hidden_projectile(projectile_pid, atkr_rot, 0, true, 6, 0x10000);
   max_frames_projectile = get_art_max_frames(obj_art_fid(projectile));
   gProjToHideOnTargetHit = projectile;



   if tile_distance(atkr_tile, tar_tile) <= 3 then
      close_range = 1;


   call hide_proj_on_target_hit_and_play_sound(attacker, target, new_end_tile, max_frames_projectile, alt_fire_laser);

   reg_anim_combat_check(0);
   reg_anim_clear_forced(target);
   if target_will_die > 0 then begin
      if target_pid_flags != -5 then
         set_proto_data(target_pid, PROTO_CR_FLAGS, target_pid_flags);

      set_object_data(target, OBJ_DATA_FID, target_cur_fid);
      set_object_data(target, OBJ_DATA_CUR_FRM, target_cur_frm);
      set_object_data(target, OBJ_DATA_ROTATION, target_cur_rot);
      set_object_data(target, OBJ_DATA_CUR_X, target_cur_X);
      set_object_data(target, OBJ_DATA_CUR_Y, target_cur_Y);
      set_flags(target, get_flags(target) bwand MASK_OBJ_REMOVE_DEAD_FLAGS);
      set_outline(target, target_outline);
      tile_refresh_display_enable;
      tile_refresh_display;
   end
   reg_anim_clear_forced(attacker);

   Enable_SoundEffects

   reg_anim_func(REG_ANIM_BEGIN, RB_RESERVED);
   reg_anim_set_priority;
   reg_anim_turn_towards(attacker, tar_tile, -1);
   reg_anim_animate(attacker, ANIM_point, -1);
   reg_anim_animate(attacker, ANIM_fire_single, -1);
   if wpn_sfx_attack != 0 then begin
      reg_anim_play_sfx(attacker, wpn_sfx_attack, 0);
   end
   reg_anim_animate_and_move(projectile, new_end_tile, ANIM_walk, 0);
   reg_anim_unset_flag(projectile, FLAG_OBJECT_HIDDEN, 3 * (1 - close_range));
   reg_anim_set_flag(projectile, FLAG_OBJECT_HIDDEN, -1);
   reg_anim_animate(attacker, ANIM_unpoint, -1);
   //alt_atk_wait_for_report = 1;
//
   //reg_anim_callback(add_show_dmg_timer);
   //reg_anim_callback(restore_combat_speed);
   reg_anim_destroy(projectile);
   reg_anim_end();

   if close_range then
      move_to(projectile, start_tile, attacker_elev);
   else
      move_to(projectile, atkr_tile, attacker_elev);

   foreach (new_tar:dmg in Line_targets_array) begin
      if new_tar > 0 andAlso dmg != DMG_IGNORE then begin
         new_tar_tile = tile_num(new_tar);
         call laser_line_dmg_anim(attacker, target, new_tar_tile, max_frames_projectile);
      end
   end
end

procedure get_combat_attack_result(variable attacker_flags = -1) begin
   variable attack_result;
   if attacker_flags < 0 then begin
      if get_object_data(combat_data, C_ATTACK_TARGET) <= 0 then
         return -1;

      attacker_flags = get_object_data(combat_data, C_ATTACK_FLAGS_SOURCE);
   end

   if attacker_flags bwand DAM_HIT != 0 then begin
      if attacker_flags bwand DAM_CRITICAL != 0 then
         attack_result = CRITICAL_HIT;
      else
         attack_result = HIT;

   end
   else begin
      if attacker_flags bwand DAM_CRITICAL != 0 then begin
         attack_result = CRITICAL_MISS;
      end
      else
         attack_result = MISS;
   end

   return attack_result;
end

procedure laser_line_dmg_setup begin
   variable attacker;
   variable target;
   variable attack_result;
   variable timer;
   variable end_tile;
   attack_result = get_combat_attack_result;
   if attack_result <= CRITICAL_MISS then begin
      call lvar_full_reset;
      return;
   end
   if combat_data > 0 then
      target = get_object_data(combat_data, C_ATTACK_TARGET);

   if target <= 0 then begin
      call lvar_full_reset;
      return;
   end

   Disable_SoundEffects

   attacker = get_object_data(combat_data, C_ATTACK_SOURCE);
   combat_target_atk_result = attack_result;

   if target != laser_new_main_target orElse dmg_was_set_to_zero then begin
      if obj_type(target) == OBJ_TYPE_CRITTER orElse tile_num(target) != line_end_tile orElse dmg_was_set_to_zero then begin
         get_new_targets = 1;
         call get_targets_on_wide_line_laser(attacker, target, gWeaponRange);
      end
   end

   // A workaround to keep the combat turn running reg_anim_clear(attacker/target)
   timer = create_object_sid(PID_PROJ_LASER, 0, 0, -1);
   set_flags(timer, FLAGS_GHOST_OBJECT);
   reg_anim_combat_check(0);
   reg_anim_func(REG_ANIM_BEGIN, RB_RESERVED);
   reg_anim_animate(timer, ANIM_stand, 0);
   reg_anim_destroy(timer);
   reg_anim_end();

   attacker = get_object_data(combat_data, C_ATTACK_SOURCE);
   target = get_object_data(combat_data, C_ATTACK_TARGET);
   end_tile = Line_end_tile;
   call laser_line_dmg(attacker, target, end_tile);
   get_new_targets = 0;
end

procedure callback_gauss_line_dmg_anim begin
   variable attacker = get_object_data(combat_data, C_ATTACK_SOURCE);
   variable target = get_object_data(combat_data, C_ATTACK_TARGET);
   variable new_tar;
   variable dmg;
   variable atkr_tile = tile_num(attacker);
   variable len = len_array(Line_targets_array);
   variable flags;
   variable i;
   for (i = gauss_target_num_key; i < len; i++) begin
      new_tar = array_key(Line_targets_array, i);
      if new_tar > 0 then begin
         gauss_target_num_key = i+1;
         break;
      end
   end
   if new_tar > 0 then begin
      if new_tar != attacker then begin
         dmg = get_array(Line_targets_array, new_tar);
         if dmg >= 0 then begin
            flags = dmg / DMG_FLAG_MULT;
            dmg = dmg % DMG_FLAG_MULT;
            if new_tar != target then
               call add_to_export_arr(new_tar, dmg);
         end
         if dmg == DMG_ZERO then
            dmg = 0;

         call critter_inflict_dmg(new_tar, attacker, dmg, DMG_normal_dam, flags, atkr_tile);
      end
   end
end


procedure gauss_line_dmg_anim(variable attacker, variable target, variable new_tar_tile, variable max_frames_projectile) begin
   variable atkr_tile = tile_num(attacker);
   variable target_tile = tile_num(target);
   variable attacker_elev = elevation(attacker);
   variable rot_atk_to_tar = rotation_to_tile(atkr_tile, target_tile);
   variable projectile;
   variable projectile_pid;
   variable placeholder;
   variable start_tile = tile_num_in_direction(atkr_tile, rot_atk_to_tar, 1);

   placeholder = create_object_sid(PID_PROJ_LASER, 0, 0, -1);
   set_object_data(placeholder, OBJ_DATA_FID, gAttackerFid);
   set_flags(placeholder, FLAGS_GHOST_OBJECT);

   if gProjToHideOnTargetHit > 0 then begin
      projectile_pid = obj_pid(gProjToHideOnTargetHit);
      projectile = create_hidden_projectile(projectile_pid, rot_atk_to_tar, (max_frames_projectile - 1));
   end
   else begin
      projectile = 0;
   end

   reg_anim_combat_check(0);
   reg_anim_func(REG_ANIM_BEGIN, RB_RESERVED);
   reg_anim_turn_towards(placeholder, target_tile, -1);
   reg_anim_animate(placeholder, ANIM_point, -1);
   if projectile then begin
      //if sfall_510 > 0 then begin
         reg_anim_animate_and_move(projectile, new_tar_tile, ANIM_walk, -1);
      //end
      //else begin
         //reg_anim_animate_and_move(projectile, new_tar_tile, ANIMATE_RUN, weapon_point_max_frames);
      //end
   end
   reg_anim_callback(callback_gauss_line_dmg_anim);

   if projectile then
      reg_anim_destroy(projectile);
   reg_anim_destroy(placeholder);
   reg_anim_end();

   if projectile then
      move_to(projectile, start_tile, attacker_elev);
end

// You are not strong enough to use this weapon properly.
procedure calc_weapon_st_shortage(variable attacker, variable weapon_pid) begin
   variable attacker_st;
   variable weapon_st_req;
   variable WeaponHandlingPerk;
   variable WeaponHandlingBonus = 3;
   variable msg;
   if weapon_pid <= 0 andAlso gWeapon > 0 then
      weapon_pid = obj_pid(gWeapon);

   if attacker > 0 andAlso weapon_pid > 0 then begin
      weapon_st_req = get_proto_data(weapon_pid, PROTO_WP_MIN_ST);
      attacker_st = get_critter_stat(attacker, STAT_st);

      if attacker == dude_obj then
         WeaponHandlingPerk = has_trait(TRAIT_PERK, attacker, PERK_weapon_handling_perk);
      if WeaponHandlingPerk > 0 then begin
         attacker_st += WeaponHandlingPerk * WeaponHandlingBonus;
      end

      // You are not strong enough to use this weapon properly.
      if weapon_st_req > attacker_st then
         return weapon_st_req - attacker_st;

   end

   return 0;
end

procedure gauss_line_dmg(variable attacker, variable target, variable new_end_tile = 0) begin
   variable atkr_tile;
   variable attacker_elev;
   variable real_orig_target_tile;
   variable tar_tile;
   variable atkr_rot;
   variable start_tile;
   variable new_tar;
   variable new_tar_tile;
   variable dmg;
   variable projectile;
   variable projectile_pid = gWeaponProjPid;
   variable wpn_sfx_attack;
   variable dmg_to_tar;
   variable close_range;
   variable max_frames_projectile;
   variable target_cur_fid;
   variable target_cur_frm;
   variable target_cur_rot;
   variable target_cur_X;
   variable target_cur_Y;
   variable target_will_die;
   variable target_outline;
   variable target_elevation;
   variable attacker_kickback;
   variable weapon_pid;
   variable timer;
   //variable wpn_sfx_charge_up = "WRX1XXX1";
   variable weapon_st_shortage;
   variable attacker_kill_type;
   variable target_pid;
   variable target_pid_flags;

   if obj_type(target) == OBJ_TYPE_CRITTER then begin
      if (get_object_data(combat_data, C_ATTACK_FLAGS_TARGET) bwand DAM_DEAD) != 0 orElse get_critter_stat(target, STAT_current_hp) < get_object_data(combat_data, C_ATTACK_DAMAGE_TARGET) then begin
         target_pid = obj_pid(target);
         target_pid_flags = get_proto_data(target_pid, PROTO_CR_FLAGS);
         if target_pid_flags bwand CFLG_NODROP == 0 then
            set_proto_data(target_pid, PROTO_CR_FLAGS, target_pid_flags bwor CFLG_NODROP);
         else
            target_pid_flags = -5;

         tile_refresh_display_disable;
         target_will_die = 1;
         target_cur_fid = get_object_data(target, OBJ_DATA_FID);
         target_cur_frm = get_object_data(target, OBJ_DATA_CUR_FRM);
         target_cur_rot = get_object_data(target, OBJ_DATA_ROTATION);
         target_cur_X =  get_object_data(target, OBJ_DATA_CUR_X);
         target_cur_Y =  get_object_data(target, OBJ_DATA_CUR_Y);
         target_outline = get_outline(target);
         target_elevation = elevation(target);
      end
   end

   atkr_tile = tile_num(attacker);
   attacker_elev = elevation(attacker);
   real_orig_target_tile = tile_num(real_orig_target);
   tar_tile = tile_num(target);
   atkr_rot = rotation_to_tile(atkr_tile, tar_tile);
   start_tile = tile_num_in_direction(atkr_tile, atkr_rot, 1);

   wpn_sfx_attack = sfx_build_weapon_name(snd_weapon_attack, gWeapon, hit_right_weapon_primary, target);

   if new_end_tile <= 0 then
      new_end_tile = tar_tile;

   gauss_target_num_key = 0;
   gAllowProjHitSound = 1;

   gAttackerFid = obj_art_fid(attacker);
   gAttackerFlags = get_flags(attacker);

   if projectile_pid <= 0 then
      projectile_pid = PID_PROJ_PLANT_SPIKE;

   if tile_distance(atkr_tile, tar_tile) <= 3 then
      close_range = 1;

   attacker_kill_type = critter_kill_type(attacker);
   if attacker_kill_type != KILL_TYPE_big_boss andAlso attacker_kill_type != KILL_TYPE_robot_kills andAlso attacker_kill_type != KILL_TYPE_super_mutant_kills andAlso not(power_armor_fid(critter_art_fid(attacker))) then begin
      weapon_st_shortage = calc_weapon_st_shortage(attacker, gWeaponPid);
      if weapon_st_shortage > 0 andAlso (random(0, (weapon_st_shortage + 2)) > 2 orElse weapon_st_shortage > 3) then
         attacker_kickback = 1;
   end

   call set_combat_speed_gauss;
   if gWeaponProjPid > 0 then begin
      projectile = create_hidden_projectile(projectile_pid, atkr_rot);
      max_frames_projectile = get_art_max_frames(obj_art_fid(projectile));
      gProjToHideOnTargetHit = projectile;
   end
   else begin
      if attacker_kickback <= 0 then
         timer = create_hidden_projectile(PID_PROJ_LASER, 0, 0);
      projectile = 0;
      gProjToHideOnTargetHit = 0;
   end

   call hide_proj_on_target_hit_and_play_sound(attacker, target, new_end_tile, max_frames_projectile, alt_fire_gauss);

   reg_anim_combat_check(0);
   reg_anim_clear_forced(target);
   if target_will_die > 0 then begin
      if target_pid_flags != -5 then
         set_proto_data(target_pid, PROTO_CR_FLAGS, target_pid_flags);

      set_object_data(target, OBJ_DATA_FID, target_cur_fid);
      set_object_data(target, OBJ_DATA_CUR_FRM, target_cur_frm);
      set_object_data(target, OBJ_DATA_ROTATION, target_cur_rot);
      set_object_data(target, OBJ_DATA_CUR_X, target_cur_X);
      set_object_data(target, OBJ_DATA_CUR_Y, target_cur_Y);
      set_flags(target, get_flags(target) bwand MASK_OBJ_REMOVE_DEAD_FLAGS);
      set_outline(target, target_outline);
      tile_refresh_display_enable;
      tile_refresh_display;
   end
   reg_anim_clear_forced(attacker);

   Enable_SoundEffects

   reg_anim_func(REG_ANIM_BEGIN, RB_RESERVED);
   reg_anim_set_priority;
   //if GaussForced <= 0 then begin
      //reg_anim_play_sfx(attacker, wpn_sfx_charge_up, 0);
   //end
   reg_anim_turn_towards(attacker, tar_tile, -1);
   reg_anim_animate(attacker, ANIM_point, -1);
   if wpn_sfx_attack != 0 then begin
      reg_anim_play_sfx(attacker, wpn_sfx_attack, -1);
   end
   reg_anim_animate(attacker, ANIM_fire_single, 0);


   if projectile then begin
      reg_anim_animate_and_move(projectile, new_end_tile, ANIM_walk, 0);
      if attacker_kickback then begin
         reg_anim_animate(attacker, ANIM_fall_back, 3);
         reg_anim_play_sfx(attacker,sfx_build_char_name(attacker,ANIM_fall_front,snd_knock_down),0);
      end
      if gWeaponProjPid > 0 then begin
         if attacker_kickback then
            reg_anim_unset_flag(projectile, FLAG_OBJECT_HIDDEN, 0);
         else
            reg_anim_unset_flag(projectile, FLAG_OBJECT_HIDDEN, 3 * (1 - close_range));
         reg_anim_set_flag(projectile, FLAG_OBJECT_HIDDEN, -1);
      end
   end
   else if attacker_kickback then begin
      reg_anim_animate(attacker, ANIM_fall_back, 2);
      reg_anim_play_sfx(attacker,sfx_build_char_name(attacker,ANIM_fall_front,snd_knock_down),0);
   end

   if attacker_kickback then
      reg_anim_animate(attacker, ANIM_back_to_standing, -1);
   else begin
      if timer then begin
         reg_anim_animate(timer, ANIM_stand, -1);
         reg_anim_animate_reverse(timer, ANIM_stand, 1);
      end
      reg_anim_animate(attacker, ANIM_unpoint, -1);
   end
   //alt_atk_wait_for_report = 1;
   //reg_anim_callback(add_show_dmg_timer);
   //reg_anim_callback(restore_combat_speed);
   if timer then
      reg_anim_destroy(timer);
   if projectile then
      reg_anim_destroy(projectile);

   reg_anim_end();



   if projectile then begin
      if close_range then
         move_to(projectile, start_tile, attacker_elev);
      else
         move_to(projectile, atkr_tile, attacker_elev);
   end

   foreach (new_tar:dmg in Line_targets_array) begin
      if new_tar > 0 andAlso dmg != DMG_IGNORE then begin
         new_tar_tile = tile_num(new_tar);
         call gauss_line_dmg_anim(attacker, target, new_tar_tile, max_frames_projectile);
      end
   end
end

procedure gauss_line_dmg_setup begin
   variable attacker;
   variable target;
   variable attack_result;
   variable timer;
   variable end_tile;
   attack_result = get_combat_attack_result;
   if attack_result <= CRITICAL_MISS then begin
      call lvar_full_reset;
      return;
   end

   if combat_data > 0 then
      target = get_object_data(combat_data, C_ATTACK_TARGET);

   if target <= 0 then begin
      call lvar_full_reset;
      return;
   end

   Disable_SoundEffects

   attacker = get_object_data(combat_data, C_ATTACK_SOURCE);
   combat_target_atk_result = attack_result;

   if target != gauss_new_main_target orElse dmg_was_set_to_zero then begin
      if obj_type(target) == OBJ_TYPE_CRITTER orElse tile_num(target) != line_end_tile orElse dmg_was_set_to_zero then begin
         get_new_targets = 1;
         call get_targets_on_wide_line_gauss(attacker, target, gWeaponRange);
      end
   end

   // A workaround to keep the combat turn running reg_anim_clear(attacker/target)
   timer = create_object_sid(PID_PROJ_LASER, 0, 0, -1);
   set_flags(timer, FLAGS_GHOST_OBJECT);
   reg_anim_combat_check(0);
   reg_anim_func(REG_ANIM_BEGIN, RB_RESERVED);
   reg_anim_animate(timer, ANIM_stand, 0);
   reg_anim_destroy(timer);
   reg_anim_end();

   attacker = get_object_data(combat_data, C_ATTACK_SOURCE);
   target = get_object_data(combat_data, C_ATTACK_TARGET);
   end_tile = Line_end_tile;
   call gauss_line_dmg(attacker, target, end_tile);

   get_new_targets = 0;
end

procedure plasma_alt_explosion_get_array_with_all_critters(variable tar_tile, variable  blast_radius, variable tar_elevation) begin
   variable new_tar;
   variable critters_on_tile = tile_get_objs(tar_tile, tar_elevation);
   variable critters_in_radius = objects_in_radius(tar_tile, blast_radius, tar_elevation, OBJ_TYPE_CRITTER);
   variable array_critters_in_radius = create_array_map;
   foreach new_tar in critters_on_tile begin
      if new_tar <= 0 orElse obj_type(new_tar) != OBJ_TYPE_CRITTER then
         continue;
      if obj_is_visible_flag(new_tar) then
         set_array(array_critters_in_radius, len_array(array_critters_in_radius), new_tar);
   end
   foreach new_tar in critters_in_radius begin
      if new_tar <= 0 then
         continue;
      if obj_is_visible_flag(new_tar) then
         set_array(array_critters_in_radius, len_array(array_critters_in_radius), new_tar);
   end
   free_array(critters_in_radius);
   free_array(critters_on_tile);
   return array_critters_in_radius;
end


procedure plasma_alt_explosion_get_dmg_and_flags(variable attacker, variable target, variable target_atk_result) begin
   variable target_rot_to_attacker;
   variable tar_tile = tile_num(target);
   variable lof_test_tile;
   variable array_critters_in_radius;
   variable blast_radius = PlasmaBlastRadius;
   variable tar_is_critter = is_critter(target);
   variable new_tar;
   variable new_tar_cur_hp;
   variable obstacle;
   variable distance;
   variable dmg_with_flags;

   if tar_is_critter <= 0 then begin
      target_rot_to_attacker = rotation_to_tile(tar_tile, tile_num(attacker));
      lof_test_tile = tile_num_in_direction(tar_tile,target_rot_to_attacker,1);
   end
   else
      lof_test_tile = tar_tile;

   array_critters_in_radius = plasma_alt_explosion_get_array_with_all_critters(tar_tile, blast_radius, elevation(target));
   if array_exists(plasma_dmg_array) then
      clear_array(plasma_dmg_array);
   else
      plasma_dmg_array = create_array_map;

   foreach new_tar in array_critters_in_radius begin
      if new_tar <= 0 orElse obj_type(new_tar) != OBJ_TYPE_CRITTER then
         continue;
      new_tar_cur_hp = get_critter_stat(new_tar, STAT_current_hp);
      if new_tar_cur_hp <= 0 orElse is_dead(new_tar) orElse get_array(death_array,new_tar) > 0 orElse not(obj_is_visible_flag(new_tar)) then
         continue;

      obstacle = get_first_non_critter_block_shoot(new_tar, lof_test_tile);
      if obstacle then
         continue;

      distance_objs(distance, target, new_tar);

      dmg_with_flags = calc_dmg_plasma(attacker, new_tar, distance, true);

      set_array(plasma_dmg_array, new_tar, dmg_with_flags);
   end
   free_array(array_critters_in_radius);
end

procedure plasma_aoe_dmg(variable attacker,variable target, variable new_end_tile = 0) begin
   variable atkr_tile;
   variable attacker_elev;
   variable real_orig_target_tile;
   variable tar_tile;
   variable atkr_rot;
   variable start_tile;
   variable new_tar;
   variable new_tar_tile;
   variable dmg;
   variable projectile;
   variable projectile_pid;
   variable wpn_sfx_attack;
   variable dmg_to_tar;
   variable close_range;
   variable max_frames_projectile;
   variable target_cur_fid;
   variable target_cur_frm;
   variable target_cur_rot;
   variable target_cur_X;
   variable target_cur_Y;
   variable target_will_die;
   variable target_outline;
   variable target_elevation;
   variable target_pid;
   variable target_pid_flags;
   if obj_type(target) == OBJ_TYPE_CRITTER then begin
      if (get_object_data(combat_data, C_ATTACK_FLAGS_TARGET) bwand DAM_DEAD) != 0 orElse get_critter_stat(target, STAT_current_hp) < get_object_data(combat_data, C_ATTACK_DAMAGE_TARGET) then begin
         target_pid = obj_pid(target);
         target_pid_flags = get_proto_data(target_pid, PROTO_CR_FLAGS);
         if target_pid_flags bwand CFLG_NODROP == 0 then
            set_proto_data(target_pid, PROTO_CR_FLAGS, target_pid_flags bwor CFLG_NODROP);
         else
            target_pid_flags = -5;

         tile_refresh_display_disable;
         target_will_die = 1;
         target_cur_fid = get_object_data(target, OBJ_DATA_FID);
         target_cur_frm = get_object_data(target, OBJ_DATA_CUR_FRM);
         target_cur_rot = get_object_data(target, OBJ_DATA_ROTATION);
         target_cur_X =  get_object_data(target, OBJ_DATA_CUR_X);
         target_cur_Y =  get_object_data(target, OBJ_DATA_CUR_Y);
         target_outline = get_outline(target);
         target_elevation = elevation(target);
      end
   end
   atkr_tile = tile_num(attacker);
   attacker_elev = elevation(attacker);
   real_orig_target_tile = tile_num(real_orig_target);
   tar_tile = tile_num(target);
   atkr_rot = rotation_to_tile(atkr_tile, tar_tile);
   start_tile = tile_num_in_direction(atkr_tile, atkr_rot, 1);
   wpn_sfx_attack = sfx_build_weapon_name(snd_weapon_attack, gWeapon, hit_right_weapon_primary, target);


   if new_end_tile <= 0 then
      new_end_tile = tar_tile;

   //required for sfall 5.1
   if sfall_510 > 0 then
      call enable_PlayerSpeedup;


   gAttackerFid = obj_art_fid(attacker);
   gAttackerFlags = get_flags(attacker);

   projectile_pid = get_proto_data(gWeaponPid, PROTO_WP_PROJ_PID);

   if projectile_pid <= 0 then
      projectile_pid = PID_PROJ_PLASMA_2;


   projectile = create_hidden_projectile(projectile_pid, atkr_rot, 0, false, 6, 0x10000);
   max_frames_projectile = get_art_max_frames(obj_art_fid(projectile));
   gProjToHideOnTargetHit = projectile;

   if tile_distance(atkr_tile, tar_tile) <= 3 then
      close_range = 1;

   call hide_proj_on_target_hit_and_play_sound(attacker, target, new_end_tile, max_frames_projectile, alt_fire_plasma);



   reg_anim_combat_check(0);
   reg_anim_clear_forced(target);
   if target_will_die > 0 then begin
      if target_pid_flags != -5 then
         set_proto_data(target_pid, PROTO_CR_FLAGS, target_pid_flags);

      set_object_data(target, OBJ_DATA_FID, target_cur_fid);
      set_object_data(target, OBJ_DATA_CUR_FRM, target_cur_frm);
      set_object_data(target, OBJ_DATA_ROTATION, target_cur_rot);
      set_object_data(target, OBJ_DATA_CUR_X, target_cur_X);
      set_object_data(target, OBJ_DATA_CUR_Y, target_cur_Y);
      set_flags(target, get_flags(target) bwand MASK_OBJ_REMOVE_DEAD_FLAGS);
      set_outline(target, target_outline);
      tile_refresh_display_enable;
      tile_refresh_display;
   end
   reg_anim_clear_forced(attacker);

   Enable_SoundEffects

   reg_anim_func(REG_ANIM_BEGIN, RB_RESERVED);
   reg_anim_set_priority;
   reg_anim_turn_towards(attacker, tar_tile, -1);
   reg_anim_animate(attacker, ANIM_point, -1);
   if wpn_sfx_attack != 0 then begin
      reg_anim_play_sfx(projectile, wpn_sfx_attack, -1);
   end
   reg_anim_animate(attacker, ANIM_fire_single, -1);
   reg_anim_animate_and_move(projectile, new_end_tile, ANIM_walk, 0);
   reg_anim_unset_flag(projectile, FLAG_OBJECT_HIDDEN, 3 * (1 - close_range));
   reg_anim_set_flag(projectile, FLAG_OBJECT_HIDDEN, -1);
   reg_anim_animate(attacker, ANIM_unpoint, -1);
   reg_anim_destroy(projectile);
   reg_anim_end();

   if close_range then
      move_to(projectile, start_tile, attacker_elev);
   else
      move_to(projectile, atkr_tile, attacker_elev);

end

procedure set_original_projectile(variable attacker, variable flags = FLAGS_OBJECT_PROJECTILE, variable outline = -1, variable cur_ldist = 8, variable cur_lint = 0x10000) begin
   variable tile_objs_arr = tile_get_objs(tile_num_in_direction(tile_num(attacker), (has_trait(TRAIT_OBJECT, attacker, OBJECT_CUR_ROT)), 1), elevation(attacker));
   variable original_projectile;
   if len_array(tile_objs_arr) <= 0 then
      return 0;

   foreach original_projectile in tile_objs_arr begin
      if original_projectile > 0 andAlso obj_pid(original_projectile) <= -1 andAlso obj_type(original_projectile) == OBJ_TYPE_MISC then begin
         set_flags(original_projectile, flags);
         if outline >= 0 then
            set_outline(original_projectile, outline);

         if cur_ldist >= 0 then
            set_object_data(original_projectile, OBJ_DATA_LIGHT_DISTANCE, cur_ldist);
         if cur_lint >= 0 then
            set_object_data(original_projectile, OBJ_DATA_LIGHT_INTENSITY, cur_lint);

         return 1;
      end
   end
   return 0;
end

procedure plasma_aoe_dmg_setup begin
   variable attacker;
   variable target;
   variable attack_result;
   variable timer;
   variable end_tile;
   variable obstacle;
   variable main_target;
   attack_result = get_combat_attack_result;
   if attack_result <= CRITICAL_MISS then begin
      call lvar_full_reset;
      return;
   end

   if combat_data > 0 then
      target = get_object_data(combat_data, C_ATTACK_TARGET);

   if target <= 0 then begin
      call lvar_full_reset;
      return;
   end

   attacker = get_object_data(combat_data, C_ATTACK_SOURCE);
   main_target = get_object_data(combat_data, C_ATTACK_MAIN_TARGET);
   if (attack_result == MISS andAlso (target == pid_scroll_block orElse target == main_target)) then begin
      call set_original_projectile(attacker, FLAGS_OBJECT_PROJECTILE);
      call lvar_full_reset;
      return;
   end

   Disable_SoundEffects


   combat_target_atk_result = attack_result;

   // A workaround to keep the combat turn running after reg_anim_clear(attacker/target)
   timer = create_object_sid(PID_PROJ_LASER, 0, 0, -1);
   set_flags(timer, FLAGS_GHOST_OBJECT);
   reg_anim_combat_check(0);
   reg_anim_func(REG_ANIM_BEGIN, RB_RESERVED);
   reg_anim_animate(timer, ANIM_stand, 0);
   reg_anim_destroy(timer);
   reg_anim_end();

   end_tile = tile_num(target);
   if get_array(cur_attack_results_arr, main_target) == DMG_DODGE then
      set_array(cur_attack_results_arr, main_target, 0);

   if target != main_target andAlso get_array(cur_attack_results_arr, target) == DMG_DODGE then
      set_array(cur_attack_results_arr, target, 0);

   call plasma_alt_explosion_get_dmg_and_flags(attacker, target, combat_target_atk_result);

   call plasma_aoe_dmg(attacker, target, end_tile);
end

procedure electrical_chain_dmg(variable attacker,variable target, variable new_end_tile = 0) begin
   variable atkr_tile;
   variable attacker_elev;
   variable real_orig_target_tile;
   variable tar_tile;
   variable atkr_rot;
   variable start_tile;
   variable new_tar;
   variable new_tar_tile;
   variable dmg;
   variable projectile;
   variable projectile_pid;
   variable wpn_sfx_attack;
   variable dmg_to_tar;
   variable close_range;
   variable max_frames_projectile;
   variable target_cur_fid;
   variable target_cur_frm;
   variable target_cur_rot;
   variable target_cur_X;
   variable target_cur_Y;
   variable target_will_die;
   variable target_outline;
   variable target_elevation;
   variable target_pid;
   variable target_pid_flags = -5;
   if obj_type(target) == OBJ_TYPE_CRITTER then begin
      if (get_object_data(combat_data, C_ATTACK_FLAGS_TARGET) bwand DAM_DEAD) != 0 orElse get_critter_stat(target, STAT_current_hp) < get_object_data(combat_data, C_ATTACK_DAMAGE_TARGET) then begin
         target_pid = obj_pid(target);
         target_pid_flags = get_proto_data(target_pid, PROTO_CR_FLAGS);
         if target_pid_flags bwand CFLG_NODROP == 0 then
            set_proto_data(target_pid, PROTO_CR_FLAGS, target_pid_flags bwor CFLG_NODROP);
         else
            target_pid_flags = -5;

         tile_refresh_display_disable;
         target_will_die = 1;
         target_cur_fid = get_object_data(target, OBJ_DATA_FID);
         target_cur_frm = get_object_data(target, OBJ_DATA_CUR_FRM);
         target_cur_rot = get_object_data(target, OBJ_DATA_ROTATION);
         target_cur_X =  get_object_data(target, OBJ_DATA_CUR_X);
         target_cur_Y =  get_object_data(target, OBJ_DATA_CUR_Y);
         target_outline = get_outline(target);
         target_elevation = elevation(target);
      end
   end
   atkr_tile = tile_num(attacker);
   attacker_elev = elevation(attacker);
   real_orig_target_tile = tile_num(real_orig_target);
   tar_tile = tile_num(target);
   atkr_rot = rotation_to_tile(atkr_tile, tar_tile);
   start_tile = tile_num_in_direction(atkr_tile, atkr_rot, 1);
   wpn_sfx_attack = sfx_build_weapon_name(snd_weapon_attack, gWeapon, hit_right_weapon_primary, target);


   if new_end_tile <= 0 then
      new_end_tile = tar_tile;

   //required for sfall 5.1
   if sfall_510 > 0 then
      call enable_PlayerSpeedup;


   gAttackerFid = obj_art_fid(attacker);
   gAttackerFlags = get_flags(attacker);

   projectile_pid = get_proto_data(gWeaponPid, PROTO_WP_PROJ_PID);

   if projectile_pid <= 0 then
      projectile_pid = PID_PROJ_ELECTRICITY;


   projectile = create_hidden_projectile(projectile_pid, atkr_rot, 0, false, 6, 0x10000);
   max_frames_projectile = get_art_max_frames(obj_art_fid(projectile));
   gProjToHideOnTargetHit = projectile;

   if tile_distance(atkr_tile, tar_tile) <= 3 then
      close_range = 1;

   call hide_proj_on_target_hit_and_play_sound(attacker, target, new_end_tile, max_frames_projectile, alt_fire_pulse);

   reg_anim_combat_check(0);
   reg_anim_clear_forced(target);
   if target_will_die > 0 then begin
      if target_pid_flags != -5 then
         set_proto_data(target_pid, PROTO_CR_FLAGS, target_pid_flags);

      set_object_data(target, OBJ_DATA_FID, target_cur_fid);
      set_object_data(target, OBJ_DATA_CUR_FRM, target_cur_frm);
      set_object_data(target, OBJ_DATA_ROTATION, target_cur_rot);
      set_object_data(target, OBJ_DATA_CUR_X, target_cur_X);
      set_object_data(target, OBJ_DATA_CUR_Y, target_cur_Y);
      set_flags(target, get_flags(target) bwand MASK_OBJ_REMOVE_DEAD_FLAGS);
      set_outline(target, target_outline);
      tile_refresh_display_enable;
      tile_refresh_display;
   end
   reg_anim_clear_forced(attacker);

   Enable_SoundEffects

   reg_anim_func(REG_ANIM_BEGIN, RB_RESERVED);
   reg_anim_set_priority;
   reg_anim_turn_towards(attacker, tar_tile, -1);
   reg_anim_animate(attacker, ANIM_point, -1);
   if wpn_sfx_attack != 0 then begin
      reg_anim_play_sfx(projectile, wpn_sfx_attack, -1);
   end
   reg_anim_animate(attacker, ANIM_fire_single, -1);
   reg_anim_animate_and_move(projectile, new_end_tile, ANIM_walk, 0);
   reg_anim_unset_flag(projectile, FLAG_OBJECT_HIDDEN, 3 * (1 - close_range));
   reg_anim_set_flag(projectile, FLAG_OBJECT_HIDDEN, -1);
   reg_anim_animate(attacker, ANIM_unpoint, -1);
   reg_anim_destroy(projectile);
   reg_anim_end();

   if close_range then
      move_to(projectile, start_tile, attacker_elev);
   else
      move_to(projectile, atkr_tile, attacker_elev);


end

procedure init_electrical_chain(variable start_tile) begin
   if ElecSameTargets <= 1 then begin
      if array_exists(gPulseTileAttackedArray) then
         clear_array(gPulseTileAttackedArray);
      else
         gPulseTileAttackedArray = create_array_map;
      set_array(gPulseTileAttackedArray, start_tile, 1);

      if ElecSameTargets < 0 then begin
         if array_exists(gPulseExplToDestroyArray) then
            clear_array(gPulseExplToDestroyArray);
         else
            gPulseExplToDestroyArray = create_array_map;

      end
   end

   if array_exists(gPulseTileRefreshOutlineArray) then
      clear_array(gPulseTileRefreshOutlineArray);
   else
      gPulseTileRefreshOutlineArray = create_array_map;

   //gPulseBackward = 0;
   gPulseBackwardKey = 0;
   gPulseTileAttackedCount = 0;
   gPulseTileNext = start_tile;
   noblock_was_set = 0;
end


procedure electrical_chain_dmg_fail(variable attacker) begin
   variable atkr_tile;
   variable atkr_rot;
   variable atkr_elev;
   variable attacker_dummy;
   variable emp_expl;
   atkr_tile = tile_num(attacker);
   atkr_rot = (has_trait(TRAIT_OBJECT,attacker,OBJECT_CUR_ROT));
   atkr_elev = elevation(attacker);
   //required for sfall 5.1
   if sfall_510 > 0 then
      call enable_PlayerSpeedup;


   gAttackerFid = obj_art_fid(attacker);
   attacker_dummy = create_object_sid(PID_PROJ_LASER, 0, 0, -1);
   set_object_data(attacker_dummy, OBJ_DATA_FID, gAttackerFid);
   set_object_data(attacker_dummy, OBJ_DATA_ROTATION, atkr_rot);
   emp_expl = create_object_sid(PID_EXPLOSION_EMP_1, atkr_tile, atkr_elev, -1);
   set_object_data(emp_expl, OBJ_DATA_FID, TRNBLK_FID);
   set_outline(emp_expl, OUTLINE_BLINKING_CYAN);
   set_flags(emp_expl, FLAGS_OBJECT_PROJECTILE);
   set_object_data(emp_expl, OBJ_DATA_LIGHT_DISTANCE, 6);
   set_object_data(emp_expl, OBJ_DATA_LIGHT_INTENSITY, 0x8000);


   reg_anim_combat_check(0);
   reg_anim_func(REG_ANIM_BEGIN, RB_UNRESERVED);
   reg_anim_animate(attacker_dummy, ANIM_point, -1);
   reg_anim_animate(attacker_dummy, ANIM_fire_single, -1);
   reg_anim_unset_flag(emp_expl, OBJECT_HIDDEN, -1);
   reg_anim_animate_and_hide(emp_expl, ANIM_stand, 0);
   reg_anim_destroy(attacker_dummy);
   reg_anim_callback(lvar_full_reset);
   reg_anim_end();
end

procedure electrical_chain_dmg_setup begin
   variable attacker;
   variable target;
   variable attack_result;
   variable timer;
   variable end_tile;
   variable obstacle;
   attacker = get_object_data(combat_data, C_ATTACK_SOURCE);
   attack_result = get_combat_attack_result;
   if attack_result <= CRITICAL_MISS then begin
      //call electrical_chain_dmg_fail(attacker);
      call lvar_full_reset;
      return;
   end

   if combat_data > 0 then
      target = get_object_data(combat_data, C_ATTACK_TARGET);

   if target <= 0 then begin
      call lvar_full_reset;
      return;
   end

   if (attack_result == MISS andAlso (target == pid_scroll_block orElse target == get_object_data(combat_data, C_ATTACK_MAIN_TARGET))) then begin
      call set_original_projectile(attacker, FLAGS_OBJECT_PROJECTILE, OUTLINE_BLINKING_CYAN);
      call lvar_full_reset;
      return;
   end

   Disable_SoundEffects

   combat_target_atk_result = attack_result;

   // A workaround to keep the combat turn running reg_anim_clear(attacker/target)
   timer = create_object_sid(PID_PROJ_LASER, 0, 0, -1);
   set_flags(timer, FLAGS_GHOST_OBJECT);
   reg_anim_combat_check(0);
   reg_anim_func(REG_ANIM_BEGIN, RB_RESERVED);
   reg_anim_animate(timer, ANIM_stand, 0);
   reg_anim_destroy(timer);
   reg_anim_end();

   end_tile = tile_num(target);

   call init_electrical_chain(end_tile);
   call electrical_chain_dmg(attacker, target, end_tile);
end

procedure get_attacker_coord begin
   variable attacker = gCurrentAttacker;
   if attacker <= 0 then
      return;

   gAttackerX = get_object_data(attacker, OBJ_DATA_CUR_X);
   gAttackerY = get_object_data(attacker, OBJ_DATA_CUR_Y);
end

procedure double_tap_damage begin
   variable attacker = gCurrentAttacker;
   variable target = gCurrentMainTarget;
   variable dmg;
   variable flags;
   if obj_type(target) != OBJ_TYPE_CRITTER then
      return;
   dmg = calc_dmg(attacker, target, random(gWeaponMinDmg, gWeaponMaxDmg), gWeaponDamageType, allow_critical);

   if dmg > DMG_FLAG_MULT then begin
      flags = dmg / DMG_FLAG_MULT;
      dmg = dmg % DMG_FLAG_MULT;
      if target == gCurrentTarget then begin
         write_int(combat_data + C_ATTACK_DAMAGE_TARGET, read_int(combat_data + C_ATTACK_DAMAGE_TARGET) + dmg);
         write_int(combat_data + C_ATTACK_FLAGS_TARGET, read_int(combat_data + C_ATTACK_FLAGS_TARGET) bwor flags);
      end
      else if target == attacker then begin
         write_int(combat_data + C_ATTACK_DAMAGE_SOURCE, read_int(combat_data + C_ATTACK_DAMAGE_SOURCE) + dmg);
         write_int(combat_data + C_ATTACK_FLAGS_SOURCE, read_int(combat_data + C_ATTACK_FLAGS_SOURCE) bwor flags);
      end
   end
   else
      flags = 0;

   call critter_inflict_dmg(target, attacker, dmg, gWeaponDamageType, flags, tile_num(attacker));
end

procedure double_tap_combat_damage begin
   variable attacker = gCurrentAttacker;
   variable target = gCurrentTarget;
   if gCurrentTarget > 0 andAlso obj_type(gCurrentTarget) == OBJ_TYPE_CRITTER then
      target = gCurrentTarget;
   else
      target = gCurrentMainTarget;

   call critter_inflict_dmg(target, attacker, DMG_DODGE, gWeaponDamageType, 0, tile_num(attacker));
end

procedure double_tap_get_coord_combat_damage_anim begin
   variable target = gCurrentTarget;
   variable attacker = gCurrentAttacker;
   variable projectile;
   variable atkr_rot;
   variable attacker_tile;
   variable target_tile;
   variable bullet_tile;
   variable end_tile;
   variable hit_sfx;
   variable obstacle;
   variable attack_results;

   if attacker <= 0 then
      return;

   target_tile = tile_num(target);
   attacker_tile = tile_num(attacker);
   attack_results = get_combat_attack_result;
   if gWeaponProjPid > 0 then begin
      if target <= 0 then
         return;


      if attack_results >= HIT then begin
         end_tile = target_tile;
         hit_sfx = sfx_build_weapon_name(snd_weapon_hitting, gWeapon, hit_right_weapon_primary, target);
      end
      else begin
         end_tile = tile_num_beyond(attacker_tile, target_tile, gWeaponRange);
         obstacle = get_first_non_critter_block_shoot(attacker, end_tile);
         if obstacle then begin
            hit_sfx = sfx_build_weapon_name(snd_weapon_hitting, gWeapon, hit_right_weapon_primary, obstacle);
            end_tile = tile_num(obstacle);
         end
      end

      atkr_rot = rotation_to_tile(attacker_tile, target_tile);
      projectile = create_hidden_projectile(gWeaponProjPid, atkr_rot);
      bullet_tile = tile_num_in_direction(attacker_tile, atkr_rot, 1);
      move_to(projectile, bullet_tile, elevation(attacker));
      reg_anim_combat_check(0);
      reg_anim_begin();
      reg_anim_unset_flag(projectile, OBJECT_HIDDEN, 0);
      reg_anim_animate_and_move(projectile, end_tile, ANIM_walk, 0);
      reg_anim_callback(double_tap_combat_damage);
      if hit_sfx != 0 then begin
         reg_anim_play_sfx(projectile, hit_sfx, -1);
      end
      reg_anim_destroy(projectile);
      reg_anim_end();
   end
   else begin
      if attack_results >= HIT then begin
         hit_sfx = sfx_build_weapon_name(snd_weapon_hitting, gWeapon, hit_right_weapon_primary, target);
      end
      else begin
         end_tile = tile_num_beyond(attacker_tile, target_tile, gWeaponRange);
         obstacle = get_first_non_critter_block_shoot(attacker, end_tile);
         if obstacle then begin
            hit_sfx = sfx_build_weapon_name(snd_weapon_hitting, gWeapon, hit_right_weapon_primary, obstacle);
            end_tile = tile_num(obstacle);
         end
      end
      call double_tap_combat_damage;
      play_sfx(hit_sfx);
   end
end


procedure set_attacker_coord_and_anim_projectile begin
   variable target = gCurrentMainTarget;
   variable attacker = gCurrentAttacker;
   variable projectile;
   variable atkr_rot;
   variable attacker_tile;
   variable target_tile;
   variable bullet_tile;
   variable end_tile;
   variable is_hit;
   variable hit_sfx;
   variable obstacle;
   variable rnd = random(1,100);
   if attacker <= 0 then
      return;

   set_object_data(attacker, OBJ_DATA_CUR_X, gAttackerX);
   set_object_data(attacker, OBJ_DATA_CUR_Y, gAttackerY);
   target_tile = tile_num(target);
   attacker_tile = tile_num(attacker);

   if gDoubleTapHitChance >= rnd then
      is_hit = 1;
   // find new target
   else begin
      end_tile = tile_num_beyond(attacker_tile, target_tile, gWeaponRange);
      obstacle = get_first_non_critter_block_shoot(attacker, end_tile, 20);
      if obstacle > 0 andAlso obstacle != target then begin
         target = obstacle;
         gCurrentMainTarget = obstacle;
         is_hit = 1;
      end
   end


   if gWeaponProjPid > 0 then begin
      if target <= 0 then
         return;

      if is_hit then begin
         end_tile = target_tile;
         hit_sfx = sfx_build_weapon_name(snd_weapon_hitting, gWeapon, hit_right_weapon_primary, target);
      end
      else begin
         end_tile = tile_num_beyond(attacker_tile, target_tile, gWeaponRange);
         obstacle = get_first_non_critter_block_shoot(attacker, end_tile);
         if obstacle then begin
            hit_sfx = sfx_build_weapon_name(snd_weapon_hitting, gWeapon, hit_right_weapon_primary, obstacle);
            end_tile = tile_num(obstacle);
         end
      end

      atkr_rot = rotation_to_tile(attacker_tile, target_tile);
      projectile = create_hidden_projectile(gWeaponProjPid, atkr_rot);
      bullet_tile = tile_num_in_direction(attacker_tile, atkr_rot, 1);
      move_to(projectile, bullet_tile, elevation(attacker));
      reg_anim_combat_check(0);
      reg_anim_begin();
      reg_anim_unset_flag(projectile, OBJECT_HIDDEN, 0);
      reg_anim_animate_and_move(projectile, end_tile, ANIM_walk, 0);
      if is_hit then begin
         reg_anim_callback(double_tap_damage);
      end
      if hit_sfx != 0 then begin
         reg_anim_play_sfx(projectile, hit_sfx, -1);
      end
      reg_anim_destroy(projectile);
      reg_anim_end();
   end
   else if is_hit then begin
      hit_sfx = sfx_build_weapon_name(snd_weapon_hitting, gWeapon, hit_right_weapon_primary, target);
      call double_tap_damage;
      play_sfx(hit_sfx);
   end
end

procedure callback_tile_refresh_display_disable begin
   tile_refresh_display_disable;
end

procedure callback_tile_refresh_display_enable2 begin
   tile_refresh_display_enable;
   tile_refresh_display;
end

procedure callback_tile_refresh_display_enable begin
   variable timer;
   timer = create_object_sid(pid_trans_block, 0, 0, -1);
   reg_anim_combat_check(0);
   reg_anim_begin();
   reg_anim_animate(timer, ANIM_stand, 0);
   reg_anim_animate_reverse(timer, ANIM_stand, 0);
   reg_anim_callback(callback_tile_refresh_display_enable2);
   reg_anim_destroy(timer);
   reg_anim_end();
end

procedure pistol_double_tap(variable attacker, variable main_target, variable cur_attack_target) begin
   variable target = main_target;
   variable atkr_tile;
   variable attacker_elev;
   variable real_orig_target_tile;
   variable tar_tile;
   variable atkr_rot;
   variable start_tile;
   variable new_tar;
   variable new_tar_tile;
   variable dmg;
   variable wpn_sfx_attack;
   variable dmg_to_tar;
   variable target_cur_fid;
   variable target_cur_frm;
   variable target_cur_rot;
   variable target_cur_X;
   variable target_cur_Y;
   variable target_will_die;
   variable target_outline;
   variable target_elevation;
   variable weapon_pid;
   variable timer;
   variable target_pid;
   variable target_pid_flags;
   //variable shot_count;
   //variable max_shot_count = 4;

   if target == cur_attack_target andAlso obj_type(target) == OBJ_TYPE_CRITTER then begin
      if (get_object_data(combat_data, C_ATTACK_FLAGS_TARGET) bwand DAM_DEAD) != 0 orElse get_critter_stat(target, STAT_current_hp) < get_object_data(combat_data, C_ATTACK_DAMAGE_TARGET) then begin
         target_pid = obj_pid(target);
         target_pid_flags = get_proto_data(target_pid, PROTO_CR_FLAGS);
         if target_pid_flags bwand CFLG_NODROP == 0 then
            set_proto_data(target_pid, PROTO_CR_FLAGS, target_pid_flags bwor CFLG_NODROP);
         else
            target_pid_flags = -5;

         tile_refresh_display_disable;
         target_will_die = 1;
         target_cur_fid = get_object_data(target, OBJ_DATA_FID);
         target_cur_frm = get_object_data(target, OBJ_DATA_CUR_FRM);
         target_cur_rot = get_object_data(target, OBJ_DATA_ROTATION);
         target_cur_X =  get_object_data(target, OBJ_DATA_CUR_X);
         target_cur_Y =  get_object_data(target, OBJ_DATA_CUR_Y);
         target_outline = get_outline(target);
         target_elevation = elevation(target);
      end
   end

   atkr_tile = tile_num(attacker);
   attacker_elev = elevation(attacker);
   real_orig_target_tile = tile_num(real_orig_target);
   tar_tile = tile_num(target);
   atkr_rot = rotation_to_tile(atkr_tile, tar_tile);
   start_tile = tile_num_in_direction(atkr_tile, atkr_rot, 1);

   wpn_sfx_attack = sfx_build_weapon_name(snd_weapon_attack, gWeapon, hit_right_weapon_primary, target);


   gCurrentAttacker = attacker;
   gCurrentMainTarget = target;
   gCurrentTarget = cur_attack_target;
   //gAllowProjHitSound = 1;

   gAttackerFid = obj_art_fid(attacker);
   gAttackerFlags = get_flags(attacker);


   if gWeaponProjPid > 0 then begin
      set_animate_to_move

   end
   reg_anim_combat_check(0);
   reg_anim_clear_forced(target);
   if target_will_die > 0 then begin
      if target_pid_flags != -5 then
         set_proto_data(target_pid, PROTO_CR_FLAGS, target_pid_flags);

      set_object_data(target, OBJ_DATA_FID, target_cur_fid);
      set_object_data(target, OBJ_DATA_CUR_FRM, target_cur_frm);
      set_object_data(target, OBJ_DATA_ROTATION, target_cur_rot);
      set_object_data(target, OBJ_DATA_CUR_X, target_cur_X);
      set_object_data(target, OBJ_DATA_CUR_Y, target_cur_Y);
      set_flags(target, get_flags(target) bwand MASK_OBJ_REMOVE_DEAD_FLAGS);
      set_outline(target, target_outline);
      tile_refresh_display_enable;
      tile_refresh_display;
   end
   reg_anim_clear_forced(attacker);

   Enable_SoundEffects

   reg_anim_func(REG_ANIM_BEGIN, RB_RESERVED);
   reg_anim_set_priority;
   reg_anim_turn_towards(attacker, tar_tile, -1);
   reg_anim_animate(attacker, ANIM_point, -1);
   reg_anim_callback(get_attacker_coord);
   reg_anim_callback(double_tap_get_coord_combat_damage_anim);
   if wpn_sfx_attack != 0 then begin
      reg_anim_play_sfx(attacker, wpn_sfx_attack, -1);
   end
   reg_anim_animate(attacker, ANIM_fire_single, 0);
   //if max_shot_count > 4 then
      //max_shot_count = 4;
   //for (shot_count := 0; shot_count < max_shot_count; shot_count++) begin
      reg_anim_callback(callback_tile_refresh_display_disable);
      reg_anim_animate(attacker, ANIM_point, -1);
      reg_anim_animate_reverse(attacker, ANIM_point, 0);
      reg_anim_callback(set_attacker_coord_and_anim_projectile);
      if wpn_sfx_attack != 0 then begin
         reg_anim_play_sfx(attacker, wpn_sfx_attack, -1);
      end
      reg_anim_callback(callback_tile_refresh_display_enable);
      reg_anim_animate(attacker, ANIM_fire_single, 0);
   //end
   alt_atk_wait_for_report = 1;
   reg_anim_callback(add_show_dmg_timer);
   reg_anim_animate(attacker, ANIM_unpoint, -1);
   reg_anim_end();


   if gWeaponProjPid > 0 then
      set_animate_to_move_and_wait

end


procedure pistol_double_tap_setup begin
   variable attacker;
   variable main_target;
   variable attack_result;
   variable timer;
   variable end_tile;
   variable obstacle;
   variable rotation_to_target;
   variable cur_target;
   variable attacker_tile;
   attacker = get_object_data(combat_data, C_ATTACK_SOURCE);
   attack_result = get_combat_attack_result;
   if attack_result <= CRITICAL_MISS then begin
      call lvar_full_reset;
      return;
   end

   if combat_data > 0 then
      main_target = get_object_data(combat_data, C_ATTACK_MAIN_TARGET);

   if main_target <= 0 then begin
      call lvar_full_reset;
      return;
   end

   cur_target = get_object_data(combat_data, C_ATTACK_TARGET);

   if cur_target <= 0 then begin
      call lvar_full_reset;
      return;
   end
   attacker_tile = tile_num(attacker);

   if rotation_to_tile(attacker_tile, tile_num(cur_target)) != rotation_to_tile(attacker_tile, tile_num(main_target)) then begin
      call lvar_full_reset;
      return;
   end

   Disable_SoundEffects

   combat_target_atk_result = attack_result;
   // A workaround to keep the combat turn running after reg_anim_clear(attacker/target)
   timer = create_object_sid(PID_PROJ_LASER, 0, 0, -1);
   set_flags(timer, FLAGS_GHOST_OBJECT);
   reg_anim_combat_check(0);
   reg_anim_func(REG_ANIM_BEGIN, RB_RESERVED);
   reg_anim_animate(timer, ANIM_stand, 0);
   reg_anim_destroy(timer);
   reg_anim_end();

   call pistol_double_tap(attacker, main_target, cur_target);
end


procedure get_dude_worn_armor_perk begin
   variable dude_armor = critter_inven_obj(dude_obj, INVEN_TYPE_WORN);
   variable armor_perk;
   if dude_armor > 0 then armor_perk = get_proto_data(obj_pid(dude_armor), PROTO_AR_PERK);
   return armor_perk;
end

procedure player_wearing_power_armor begin
   variable armor_perk = get_dude_worn_armor_perk;
   if armor_perk == PERK_armor_powered or armor_perk == PERK_armor_advanced_1 or armor_perk == PERK_armor_advanced_2 then begin
      return true;
   end
   else begin
      return false;
   end
end

procedure set_dude_weapon_button_non_aimed begin
   variable hand = (0x5970F8 + (active_hand * 0x18));

   if attack_is_aimed then begin
      write_int(hand + 0x10, read_int(hand + 0x10) - 1);
      intface_redraw;
   end
end

procedure get_attack_anim(variable weapon,variable attack_type) begin
   variable attack_anim;
   variable attack_anim_arr;
   variable index;
   if attack_type >= ATKTYPE_LWEP_RELOAD andAlso attack_type <= ATKTYPE_RWEP_RELOAD then begin
      return -1;
   end
   //kick
   if attack_type == ATKTYPE_KICK orElse (attack_type >= ATKTYPE_STRONGKICK andAlso attack_type <= ATKTYPE_PIERCINGKICK) then begin
      return ANIM_kick_leg;
   end
   //punch
   if weapon <= 0 then begin
      return ANIM_throw_punch;
   end
   attack_anim_arr = [ANIM_stand, ANIM_throw_punch, ANIM_kick_leg, ANIM_swing_anim, ANIM_thrust_anim, ANIM_throw_anim, ANIM_fire_single, ANIM_fire_burst, ANIM_fire_continuous];
   if attack_type == ATKTYPE_LWEP1 OrElse attack_type == ATKTYPE_RWEP1 then begin
      index = get_proto_data(obj_pid(weapon), PROTO_FLAG_EXT) bwand 0x0000000F;
   end
   else begin
      index = (get_proto_data(obj_pid(weapon), PROTO_FLAG_EXT) bwand 0x000000F0) / 16;
   end
   attack_anim = attack_anim_arr[index];
   return attack_anim;
end

procedure wpn_allow_alt_asault_rifles(variable weapon_ptr, variable atk_type) begin
   variable wpn_cur_anim;
   variable is_burst;
   variable pid;
   variable attack_anim;
   variable wpn_caliber;
   variable allowed_array;

   if alt_fire_selected > 0 orElse weapon_ptr <= 0 then
      return 0;

   pid = obj_pid(weapon_ptr);
   if AimedBurstModAnyWeapon < 1 then begin
      wpn_caliber = get_proto_data(pid, PROTO_WP_CALIBER);
      if wpn_caliber == gShotgunCaliber then
         return 0;
   end
   wpn_cur_anim = get_proto_data(pid, PROTO_WP_ANIM);
   attack_anim = get_attack_anim(weapon_ptr, atk_type);
   if attack_anim == ANIM_fire_burst orElse (attack_anim == ANIM_fire_continuous andAlso AimedBurstModAnyWeapon > 1) then
      is_burst = 1;

   allowed_array = [PID_HK_G11, PID_HK_G11E];
   if is_burst > 0 andAlso (AimedBurstModAnyWeapon > 0 orElse wpn_cur_anim == WPN_ANIM_RIFLE orElse wpn_cur_anim == WPN_ANIM_BIG_GUN orElse is_in_array(pid, allowed_array)) then begin
      //alt_fire_selected = alt_fire_aimed_burst;
      return 1;
   end
   else
      return 0;
end

procedure CALCAPCOST begin
   variable user = get_sfall_arg;
   variable atk_type = get_sfall_arg;
   variable is_aimed = get_sfall_arg;
   variable default_ap_cost = get_sfall_arg;
   variable item = get_sfall_arg;
   variable cur_ammo;
   variable attack_result;
   one_time_AFTERHITROLL = 0;
   gCurAtkType = atk_type;
   if AimedBurstMod > 0 then begin
      aimed_burst_allowed = 0;
      if is_aimed <= 0 andAlso user == dude_obj andAlso item > 0 then begin
         if obj_item_subtype(item) == item_type_weapon then begin
            if wpn_allow_alt_asault_rifles(item, atk_type) > 0 then begin
               aimed_burst_allowed = 1;
            end
         end
      end
   end

   if is_aimed > 0 then
      last_ap_cost_aimed = default_ap_cost;
   else begin
      last_ap_cost_aimed = default_ap_cost + 1;
   end
end

procedure get_weapon_ammo_cost(variable wpn_pid, variable rounds = 1) begin
   variable new_ammo_cost = ecco_ammocost_map[wpn_pid];

   if new_ammo_cost > 0 then
      return new_ammo_cost * rounds;
   else begin
      if wpn_pid == PID_SUPER_CATTLE_PROD orElse wpn_pid == PID_MEGA_POWER_FIST then
         return rounds * 2;
   end

   return rounds;
end

procedure calculate_and_apply_alt_attack_cost(variable weapon, variable alt_atk_type, variable targets_count, variable apply_cost) begin
   variable weapon_pid;
   variable base_cost;
   variable max_ammo;
   variable cur_ammo;
   variable alt_attack_cost;
   variable base_alt_attack_cost;
   variable multiplier = 2;

   if weapon <= 0 then
      return -1;

   cur_ammo = get_weapon_ammo_count(weapon);
   if cur_ammo <= 0 then
      return -1;

   weapon_pid = obj_pid(weapon);
   base_cost = get_weapon_ammo_cost(weapon_pid);
   if base_cost <= 0 then
      base_cost = 1;

   if alt_atk_type == alt_fire_laser then begin
      LaserAmmoBaseCost = base_cost;
      base_alt_attack_cost = base_cost;
      multiplier = 1;
   end
   else if alt_atk_type == alt_fire_double_tap then begin
      multiplier = 1;
   end
   else if base_cost > 2 then
      multiplier = 1;

   max_ammo = get_proto_data(weapon_pid, PROTO_WP_MAG_SIZE);
   alt_attack_cost = base_cost * multiplier;

   if alt_attack_cost > max_ammo andAlso multiplier > 2 then begin
      multiplier -= 1;
      alt_attack_cost = base_cost * multiplier;
      if alt_attack_cost > max_ammo andAlso multiplier > 2 then begin
         multiplier -= 1;
         alt_attack_cost = base_cost * multiplier;
      end
   end

   if targets_count > 1 then
      alt_attack_cost *= targets_count;

   alt_attack_cost += base_alt_attack_cost;

   if cur_ammo < alt_attack_cost + base_cost then
      return -1;

   if apply_cost > 0 then
      set_weapon_ammo_count(weapon, cur_ammo - alt_attack_cost);

   return alt_attack_cost;
end


procedure wpn_allow_alt_gauss(variable weapon_ptr, variable attack_type, variable bodypart, variable attacker, variable target) begin
   variable ammo_pid;
   variable cur_atk_anim;
   variable pid;

   if (GaussSecondaryAttackMod <= 0) orElse (attacker != dude_obj andAlso GaussSecondaryAttackMod <= 1) then
      return 0;

   if alt_fire_selected > 0 orElse weapon_ptr <= 0 then
      return 0;

   pid = obj_pid(weapon_ptr);

   cur_atk_anim = get_attack_anim(weapon_ptr, attack_type);
   if cur_atk_anim != ANIM_fire_single then
      return 0;

   ammo_pid = get_proto_data(pid, PROTO_WP_AMMO_PID);

   if (GaussForced > 0 orElse is_alt_fire_aimed(attacker, target, bodypart)) then begin
      if is_in_array(pid, GaussCustomPids) orElse ammo_pid == PID_2MM_EC_AMMO orElse (Sonora > 0 andAlso pid == pid_sonora_railgun) then begin
         alt_fire_selected = alt_fire_gauss;
         return 1;
      end
   end

   return 0;
end

procedure wpn_allow_alt_pulse(variable weapon_ptr, variable attack_type, variable bodypart, variable attacker, variable target, variable apply_ammo = 1) begin
   variable pid;
   variable damage_type;
   variable cur_atk_anim;

   if (ElecSecondaryAttackMod <= 0) orElse (attacker != dude_obj andAlso ElecSecondaryAttackMod < 2) then
      return 0;

   if alt_fire_selected > 0 orElse weapon_ptr <= 0 then
      return 0;

   pid = obj_pid(weapon_ptr);

   cur_atk_anim = get_attack_anim(weapon_ptr, attack_type);
   if cur_atk_anim != ANIM_fire_single then
      return 0;

   damage_type = get_proto_data(pid, PROTO_WP_DMG_TYPE);


   if (damage_type == DMG_electrical) orElse (damage_type == DMG_emp) orElse is_in_array(pid, ElecCustomPids) then begin
      if ElecForced > 0 orElse (is_alt_fire_aimed(attacker, target, bodypart) andAlso calculate_and_apply_alt_attack_cost(weapon_ptr, alt_fire_pulse, 1, apply_ammo) >= 0) then begin
         alt_fire_selected = alt_fire_pulse;
         return 1;
      end
   end

   return 0;
end

procedure wpn_allow_alt_plasma(variable weapon_ptr, variable attack_type, variable bodypart, variable attacker, variable target, variable apply_ammo = 1) begin
   variable pid;
   variable damage_type;
   variable cur_atk_anim;

   if (PlasmaSecondaryAttackMod <= 0) orElse (attacker != dude_obj andAlso PlasmaSecondaryAttackMod < 2) then
      return 0;

   if alt_fire_selected > 0 orElse weapon_ptr <= 0 then
      return 0;

   pid = obj_pid(weapon_ptr);

   cur_atk_anim = get_attack_anim(weapon_ptr, attack_type);
   if cur_atk_anim != ANIM_fire_single then
      return 0;

   damage_type = get_proto_data(pid, PROTO_WP_DMG_TYPE);

   if (damage_type == DMG_plasma) orElse (is_in_array(pid, PlasmaCustomPids)) then begin
      if PlasmaForced > 0 orElse (is_alt_fire_aimed(attacker, target, bodypart) andAlso calculate_and_apply_alt_attack_cost(weapon_ptr, alt_fire_plasma, 1, apply_ammo) >= 0) then begin
         alt_fire_selected = alt_fire_plasma;
         return 1;
      end
   end

   return 0;
end

procedure wpn_allow_alt_pistol(variable weapon_ptr, variable attack_type, variable attacker, variable target, variable hit_chance, variable bodypart, variable apply_ammo = 1) begin
   variable damage_type;
   variable cur_wpn_anim;
   variable cur_atk_anim;
   variable pid;
   variable foced;

   if (PistolSecondaryAttackMod <= 0) orElse (attacker != dude_obj andAlso PistolSecondaryAttackMod < 2) then
      return 0;

   if alt_fire_selected > 0 orElse weapon_ptr <= 0 then
      return 0;

   pid = obj_pid(weapon_ptr);

   cur_atk_anim = get_attack_anim(weapon_ptr, attack_type);
   if cur_atk_anim != ANIM_fire_single then
      return 0;

   damage_type = get_proto_data(pid, PROTO_WP_DMG_TYPE);
   cur_wpn_anim = get_proto_data(pid, PROTO_WP_ANIM);

   if (cur_wpn_anim == WPN_ANIM_PISTOL orElse cur_wpn_anim == WPN_ANIM_SMG)
   andAlso damage_type == DMG_normal_dam then begin
      if PistolDoubleTapForced == 1 orElse (PistolDoubleTapForced > 1 andAlso get_ranged_weapon_skill_lvl(attacker, weapon_ptr) >= PistolDoubleTapForced) then begin
         foced = 1;
      end

      if foced <= 0 andAlso attacker != dude_obj then begin
         if (bodypart != BODY_HIT_TORSO orElse bodypart != BODY_UNCALLED) andAlso random(0,12) > 2 * combat_difficulty andAlso hit_chance > 75 then
            return 0;
      end

      if (foced > 0 orElse is_alt_fire_aimed(attacker, target, bodypart)) andAlso calculate_and_apply_alt_attack_cost(weapon_ptr, alt_fire_double_tap, 1, apply_ammo) >= 0 then begin
         alt_fire_selected = alt_fire_double_tap;
         return 1;
      end
   end

   return 0;
end

procedure wpn_allow_alt_laser(variable weapon_ptr, variable attack_type, variable bodypart, variable attacker, variable target, variable apply_ammo = 0) begin
   variable pid;
   variable damage_type;
   variable cur_atk_anim;

   if (LaserSecondaryAttackMod <= 0) orElse (attacker != dude_obj andAlso LaserSecondaryAttackMod < 2) then
      return 0;

   if alt_fire_selected > 0 orElse weapon_ptr <= 0 then
      return 0;

   pid = obj_pid(weapon_ptr);

   cur_atk_anim = get_attack_anim(weapon_ptr, attack_type);
   if cur_atk_anim != ANIM_fire_single then
      return 0;

   damage_type = get_proto_data(pid, PROTO_WP_DMG_TYPE);

   if (damage_type == DMG_laser) orElse (is_in_array(pid, LaserCustomPids)) then begin
      if LaserForced > 0 orElse (is_alt_fire_aimed(attacker, target, bodypart) andAlso calculate_and_apply_alt_attack_cost(weapon_ptr, alt_fire_laser, 1, apply_ammo) >= 0) then begin
         alt_fire_selected = alt_fire_laser;
         return 1;
      end
   end

   return 0;
end


procedure write_string_to_addr(variable addr, variable text) begin
   variable i;
   while (i < strlen(text)) do begin
      write_byte(addr + i, charcode(substr(text, i, i + 1)));
      i++;
   end
   write_byte(addr + i, 0);
end

inline procedure restore_torso_name begin
   variable target;
   variable ptr;
   if gLastCritterCalledTargetTorsoName != 0 then begin
      target = gLastCritterCalledTarget;
      ptr = hitLocationGetName_str_ptr(target, BODY_HIT_TORSO);

      call write_string_to_addr(ptr, gLastCritterCalledTargetTorsoName);

      gLastCritterCalledTargetTorsoName = 0;
      gLastCritterCalledTarget = 0;
   end
end

procedure AFTERHITROLL begin
   variable attack_result = get_sfall_arg;
   variable attacker = get_sfall_arg;
   variable target = get_sfall_arg;
   variable bodypart = get_sfall_arg;
   variable hit_chance = get_sfall_arg;
   variable attacker_iq;
   variable attacker_lu;
   variable critical_chance;
   variable target_pid;
   variable rnd;
   variable Atktype;
   variable ammo_cost = 1;
   variable attacker_team;
   variable new_target;
   variable new_tar_team;
   variable new_tar_arr;
   variable distance;
   variable last_distance;
   variable wrong;
   variable combat_diff;
   variable nearest_target_is_friend;
   variable is_crit;
   variable attacker_cur_ap;
   variable returned_bodypart = -1;
   variable ap_refund;
   variable cells;
   variable small_cells;
   variable max_allowed;
   variable is_two_handed;
   variable timer;
   call restore_torso_name;

   attacker_frm = anim_busy(attacker);

   if attacker > 0 andAlso attacker_frm == 0 andAlso one_time_AFTERHITROLL <= 0 then begin
      if real_orig_target <= 0 then
         real_orig_target = get_object_data(combat_data, C_ATTACK_MAIN_TARGET);

      if array_exists(cur_attack_results_arr) then
         clear_array(cur_attack_results_arr);
      else
         cur_attack_results_arr = create_array_map;

      one_time_AFTERHITROLL = 1;
      laser_max_targets = 0;
      dmg_was_set_to_zero = 0;
      get_new_targets = 0;
      //gCombatHighlight = read_int(0x56D38C);
      clear_array(import_alt_attack_aoe_targets_arr);
      gauss_new_main_target = 0;
      laser_new_main_target = 0;
      last_target_on_a_line = 0;
      is_single_shot = 0;
      if real_orig_target > 0 then begin
         enemy_team = has_trait(TRAIT_OBJECT, real_orig_target, OBJECT_TEAM_NUM);
      end


      combat_diff = combat_difficulty;
      attacker_lu = get_critter_stat(attacker, STAT_lu);
      critical_chance = get_critter_stat(attacker, STAT_crit_chance);
      if target then target_pid = obj_pid(target);
      Atktype = get_object_data(combat_data, C_ATTACK_HIT_MODE);

      atk_rslt = attack_result;
      if atk_rslt <= MISS then
         set_array(cur_attack_results_arr, target, DMG_DODGE);

      if target != real_orig_target then
         set_array(cur_attack_results_arr, real_orig_target, DMG_DODGE);

      gWeapon = get_object_data(combat_data, C_ATTACK_WEAPON);
      if attacker == dude_obj then begin
         finesse = has_trait(TRAIT_TRAIT, attacker, TRAIT_finesse);
         if traits_plus > 0 andAlso allow_critical <= 1 then begin
            if attacker == dude_obj andAlso (finesse > 0 orElse finesse_plus > 1) then begin
               allow_critical = 1;
            end
            else begin
               allow_critical = 0;
            end
         end
         bloody_mess = has_trait(TRAIT_TRAIT, attacker, TRAIT_bloody_mess);
         one_hander = has_trait(TRAIT_TRAIT, attacker, TRAIT_one_hander);
         weapon_handling = has_trait(TRAIT_PERK, attacker, PERK_weapon_handling_perk);
         sharpshooter = has_trait(TRAIT_PERK, attacker, PERK_sharpshooter);
         bonus_crit_power_roll = get_critter_stat(attacker, STAT_better_crit);
         bonus_ranged_damage = has_trait(TRAIT_PERK, attacker, PERK_bonus_ranged_damage);
         living_anatomy = has_trait(TRAIT_PERK, attacker, PERK_living_anatomy_perk);
         night_vision = has_trait(TRAIT_PERK, attacker, PERK_night_vision);
         if AllowSniperPerk then begin
            sniper = has_trait(TRAIT_PERK, attacker, PERK_sniper);
         end
      end

      if gWeapon > 0 then begin
         gWeaponPid = obj_pid(gWeapon);
         weapon_flags = get_proto_data(gWeaponPid, PROTO_FLAG_EXT);
         weapon_ammo_pid = get_proto_data(gWeaponPid, PROTO_WP_AMMO_PID);
         weapon_caliber = get_proto_data(gWeaponPid, PROTO_WP_CALIBER);
         gWeaponDamageType = get_proto_data(gWeaponPid, PROTO_WP_DMG_TYPE);
         weapon_min_st = get_proto_data(gWeaponPid, PROTO_WP_MIN_ST);
         gWeaponMinDmg = get_proto_data(gWeaponPid, PROTO_WP_DMG_MIN) + 2 * bonus_ranged_damage;
         gWeaponMaxDmg = get_proto_data(gWeaponPid, PROTO_WP_DMG_MAX) + 2 * bonus_ranged_damage;
         weapon_perk = get_proto_data(gWeaponPid, PROTO_WP_PERK);
         weapon_cur_ammo = get_object_data(gWeapon, OBJ_DATA_CUR_CHARGES);
         weapon_anim = get_proto_data(gWeaponPid, PROTO_WP_ANIM);
         gWeaponProjPid = get_proto_data(gWeaponPid, PROTO_WP_PROJ_PID);
         //weapon_ammo_cost = get_proto_data(gWeaponPid, PROTO_WP_BURST);
         weapon_ammo_cost = get_weapon_ammo_cost(gWeaponPid);
         //weapon_ap_cost = get_weapon_ap_cost(gWeaponPid, Atktype);
         if weapon_ammo_cost <= 0 then
            weapon_ammo_cost = 1;

         if weapon_ammo_pid > 0 then begin
            //ammo_caliber = get_proto_data(weapon_ammo_pid, PROTO_AM_CALIBER);
            ammo_mult = get_proto_data(weapon_ammo_pid, PROTO_AM_DMG_MULT);
            ammo_div = get_proto_data(weapon_ammo_pid, PROTO_AM_DMG_DIV);
            ammo_dr_mod = get_proto_data(weapon_ammo_pid, PROTO_AM_DR_MOD);
            ammo_ac_mod = get_proto_data(weapon_ammo_pid, PROTO_AM_AC_MOD);
         end
         //get range of the first attack mode for weapons in the right/left hand
         if Atktype == ATKTYPE_LWEP1 or Atktype ==  ATKTYPE_RWEP1 then begin
            gWeaponRange = get_proto_data(gWeaponPid, PROTO_WP_RANGE_1);
            if (weapon_flags bwand ATKMODE_PRI_SINGLE) == ATKMODE_PRI_SINGLE andAlso ((weapon_flags bwand ATKMODE_PRI_BURST) != ATKMODE_PRI_BURST) then is_single_shot = 1;
         end
         //get range of the second attack mode for weapons in the right/left hand
         else if Atktype ==  ATKTYPE_LWEP2 or Atktype ==  ATKTYPE_RWEP2 then begin
            gWeaponRange = get_proto_data(gWeaponPid, PROTO_WP_RANGE_2);
            if (weapon_flags bwand ATKMODE_SEC_SINGLE) == ATKMODE_SEC_SINGLE andAlso ((weapon_flags bwand ATKMODE_SEC_BURST) != ATKMODE_SEC_BURST) then is_single_shot = 1;
         end
         if (ammo_mult - ammo_div) >= 0 andAlso ammo_div > 0 then begin
            gWeaponMinDmg = round(1.0 * gWeaponMinDmg * ammo_mult / ammo_div);
            gWeaponMaxDmg = round(1.0 * gWeaponMaxDmg * ammo_mult / ammo_div);
         end
         if one_hander then begin
            one_hander_bonus = get_one_hander_bonus(weapon_flags);
         end
      end

      // electrical and EMP set new proj_pid and weapon_cur_ammo
      if wpn_allow_alt_pulse(gWeapon, Atktype, target_bodypart, attacker, target) > 0 then begin
         if ElecForced <= 0 andAlso attacker != dude_obj then begin
            rnd = random(0, 100);
            attacker_iq = get_critter_stat(attacker, STAT_iq);
            if rnd >= (5 - attacker_iq) then begin
               attacker_iq += 2 * combat_diff;
               new_tar_arr = objects_in_radius(tile_num(real_orig_target),ElecRadius, elevation(real_orig_target), OBJ_TYPE_CRITTER);
               last_distance = ElecRadius;
               attacker_team = has_trait(TRAIT_OBJECT, attacker, OBJECT_TEAM_NUM);
               foreach new_target in new_tar_arr begin
                  if new_target <= 0 orElse new_target == real_orig_target orElse get_critter_stat(new_target, STAT_current_hp) <= 0 orElse get_array(death_array,new_target) > 0 then continue;
                  distance_objs(distance,target,new_target);
                  if distance == last_distance then begin
                     new_tar_team = has_trait(TRAIT_OBJECT, new_target, OBJECT_TEAM_NUM);
                     //Party members targets
                     if attacker_team == TEAM_PLAYER then begin
                        if new_tar_team == enemy_team then begin
                           enemy_targets_count += 1;
                        end
                        else if attacker_team == new_tar_team then begin
                           friendly_targets_count += 1;
                           nearest_target_is_friend = 1;
                           if new_target == attacker then friendly_targets_count += 1;
                        end
                     end
                     //Critter targets
                     else begin
                        if new_tar_team != attacker_team then begin
                           enemy_targets_count += 1;
                           nearest_target_is_friend = 0;
                        end
                        else if attacker_team == new_tar_team then begin
                           friendly_targets_count += 1;
                           nearest_target_is_friend = 1;
                           if new_target == attacker then friendly_targets_count += 1;
                        end
                     end
                  end
                  else if distance < last_distance then begin
                     //friendly_targets_count = 0;
                     //enemy_targets_count = 0;
                     nearest_target_is_friend = 0;
                     new_tar_team = has_trait(TRAIT_OBJECT, new_target, OBJECT_TEAM_NUM);
                     //Party members targets
                     if attacker_team == TEAM_PLAYER then begin
                        if new_tar_team == enemy_team then begin
                           enemy_targets_count += 1;
                        end
                        else if attacker_team == new_tar_team then begin
                           friendly_targets_count += 1;
                           nearest_target_is_friend = 1;
                           if new_target == attacker then friendly_targets_count += 1;
                        end
                     end
                     //Critter targets
                     else begin
                        if new_tar_team != attacker_team then begin
                           enemy_targets_count += 1;
                        end
                        else if attacker_team == new_tar_team then begin
                           friendly_targets_count += 1;
                           nearest_target_is_friend = 1;
                           if new_target == attacker then friendly_targets_count += 1;
                        end
                     end
                     last_distance = distance;
                  end
               end
               if attacker_team == TEAM_PLAYER then begin
                  rnd -= 15;
               end
               if rnd > attacker_iq * 5 then begin
                  wrong = 1;
               end
               if wrong > 0 or (enemy_targets_count < 1) or (nearest_target_is_friend > 0 andAlso (enemy_targets_count / friendly_targets_count) < 2) then begin
                  call lvar_full_reset;
                  wrong = 10;
               end
            end
         end

         if wrong < 10 then begin
            if gWeaponProjPid <= 0 then begin
               call change_weapon_proj_pid(gWeaponPid, PID_PROJ_ELECTRICITY);
               gWeaponProjPid = PID_PROJ_PLASMA_2;
            end

            timer = create_object_sid(pid_trans_block, 0, 0, -1);
            reg_anim_combat_check(0);
            reg_anim_begin();
            reg_anim_animate(timer, ANIM_stand, 0);
            reg_anim_animate_reverse(timer, ANIM_stand, 0);
            reg_anim_callback(electrical_chain_dmg_setup);
            reg_anim_destroy(timer);
            reg_anim_end();

         end
         else
            set_weapon_ammo_count(gWeapon, weapon_cur_ammo);
      end
      // electrical and EMP set new proj_pid and weapon_cur_ammo

      // plasma set new proj_pid and weapon_cur_ammo
      if wpn_allow_alt_plasma(gWeapon, Atktype, target_bodypart, attacker, target) then begin
         //ai plasma_alt use
         if PlasmaForced <= 0 andAlso attacker != dude_obj then begin
            rnd = random(0, 100);
            attacker_iq = get_critter_stat(attacker, STAT_iq);
            if rnd > (12 - attacker_iq) then begin
               attacker_iq += 2 * combat_diff;
               new_tar_arr = objects_in_radius(tile_num(real_orig_target),PlasmaBlastRadius, elevation(real_orig_target), OBJ_TYPE_CRITTER);
               attacker_team = has_trait(TRAIT_OBJECT, attacker, OBJECT_TEAM_NUM);
               friendly_targets_count = 0;
               enemy_targets_count = 0;
               foreach new_target in new_tar_arr begin
                  if new_target <= 0 orElse get_critter_stat(new_target, STAT_current_hp) <= 0 orElse get_array(death_array,new_target) > 0 then continue;
                  new_tar_team = has_trait(TRAIT_OBJECT, new_target, OBJECT_TEAM_NUM);
                  //Party members targets
                  if attacker_team == TEAM_PLAYER then begin
                     if new_tar_team == enemy_team then begin
                        enemy_targets_count += 1;
                     end
                     else if attacker_team == new_tar_team then begin
                        friendly_targets_count += 1;
                        if new_target == attacker then friendly_targets_count += 1;
                     end
                  end
                  //Critter targets
                  else begin
                     if new_tar_team != attacker_team then begin
                        enemy_targets_count += 1;
                     end
                     else if attacker_team == new_tar_team then begin
                        friendly_targets_count += 1;
                        if new_target == attacker then friendly_targets_count += 1;
                     end
                  end
               end
               if attacker_team == TEAM_PLAYER then begin
                  rnd -= 13;
               end
               if rnd > attacker_iq * 5 then begin
                  wrong = 1;
               end
               if wrong > 0 or (enemy_targets_count < 2 andAlso random(0,6)) or (friendly_targets_count > 0 andAlso (enemy_targets_count - 2) < friendly_targets_count) then begin
                  call lvar_full_reset;
                  wrong = 10;
                  //return;
               end
            end
         end

         if wrong < 10 then begin
            call change_weapon_proj_pid(gWeaponPid, PID_PROJ_PLASMA_2);
            gWeaponProjPid = PID_PROJ_PLASMA_2;
            timer = create_object_sid(pid_trans_block, 0, 0, -1);
            reg_anim_combat_check(0);
            reg_anim_begin();
            reg_anim_animate(timer, ANIM_stand, 0);
            reg_anim_animate_reverse(timer, ANIM_stand, 0);
            reg_anim_callback(plasma_aoe_dmg_setup);
            reg_anim_destroy(timer);
            reg_anim_end();
         end
         else
            set_weapon_ammo_count(gWeapon, weapon_cur_ammo);
      end
      // plasma set new proj_pid and weapon_cur_ammo end

      // laser get new targets
      if wpn_allow_alt_laser(gWeapon, Atktype, target_bodypart, attacker, target) then begin
         if target == real_orig_target orElse atk_rslt == CRITICAL_MISS then
            combat_target_atk_result = atk_rslt;
         else
            combat_target_atk_result = MISS;

         if Sonora > 0 then begin
            cells = PID_SONORA_MICRO_FUSION_CELL;
            small_cells = PID_SONORA_SMALL_ENERGY_CELL;
         end
         else begin
            cells = PID_MICRO_FUSION_CELL;
            small_cells = PID_SMALL_ENERGY_CELL;
         end
         if LaserForced <= 0 then begin
            laser_cur_ammo = weapon_cur_ammo / LaserAmmoBaseCost - 2 * LaserAmmoBaseCost;
         end
         else begin
            laser_cur_ammo = 9999;
         end

         is_two_handed = (get_proto_data(obj_pid(gWeapon), PROTO_FLAG_EXT) bwand WEAPON_2HAND) == WEAPON_2HAND;
         if weapon_ammo_pid == cells then begin
            if is_two_handed then
               max_allowed = laser_max_targets_two_handed_micro_fusion;
            else
               max_allowed = laser_max_targets_one_handed_micro_fusion;
         end
         else if weapon_ammo_pid == small_cells then begin
            if is_two_handed then
               max_allowed = laser_max_targets_two_handed_small_cell;
            else
               max_allowed = laser_max_targets_one_handed_small_cell;
         end
         else begin
            max_allowed =
            (laser_max_targets_two_handed_micro_fusion +
            laser_max_targets_one_handed_micro_fusion +
            laser_max_targets_two_handed_small_cell +
            laser_max_targets_one_handed_small_cell ) / 4;
         end
         if laser_cur_ammo > max_allowed then
            laser_cur_ammo = max_allowed;


         laser_max_targets = laser_cur_ammo;

         //get the maximum number of targets for penetration
         call get_targets_on_wide_line_laser(attacker, real_orig_target, gWeaponRange);

         // NPC check
         if attacker != dude_obj andAlso LaserForced <= 0 then begin
            if obj_type(real_orig_target) != OBJ_TYPE_CRITTER orElse (bodypart != BODY_HIT_TORSO andAlso bodypart != BODY_UNCALLED) then begin
               call lvar_full_reset;
               atk_rslt = -1;
               wrong = 10;
               return;
            end
            attacker_iq = get_critter_stat(attacker, STAT_iq);
            if enemy_targets_count <= 0 then
               wrong = 1;
            else if enemy_targets_count <= 1 then begin
               if friendly_targets_count > 0 then
                  wrong = 1;
               if friendly_targets_count <= 0 then begin
                  if get_critter_stat(real_orig_target, STAT_dmg_resist_laser) < 40 andAlso get_critter_stat(real_orig_target, STAT_dmg_thresh_laser) < 7 then
                     if random(0, 6) then begin
                        wrong = 1;
                  end
                  else if random(0, 13) > attacker_iq then
                     wrong = 1;
               end
            end
            else if enemy_targets_count > 1 then begin
               if friendly_targets_count > enemy_targets_count + 1 then
                  wrong = 1;
               else if friendly_targets_count < enemy_targets_count then
                  wrong = 0;
               else if friendly_targets_count == enemy_targets_count andAlso (attacker_iq <= 4 orElse random(1, 11) > attacker_iq) then
                  wrong = 1;
            end
            else
               wrong = 1;

            if wrong then begin
               call lvar_full_reset;
               atk_rslt = -1;
               wrong = 10;
               return;
            end
         end

         //calculate actual additional targets
         if target != real_orig_target then begin
            call get_targets_on_wide_line_laser(attacker, target, gWeaponRange);
         end

         if wrong < 10 then begin
            if laser_new_main_target > 0 andAlso laser_new_main_target != target then begin
               set_sfall_return(HIT);
               set_sfall_arg(0, HIT);
               set_sfall_return(BODY_UNCALLED);
               set_sfall_arg(3, BODY_UNCALLED);
               returned_bodypart = -1;
               set_sfall_return(laser_new_main_target);
               set_sfall_arg(2, laser_new_main_target);
             end

            timer = create_object_sid(pid_trans_block, 0, 0, -1);
            reg_anim_combat_check(0);
            reg_anim_begin();
            reg_anim_animate(timer, ANIM_stand, 0);
            reg_anim_animate_reverse(timer, ANIM_stand, 0);
            reg_anim_callback(laser_line_dmg_setup);
            reg_anim_destroy(timer);
            reg_anim_end();
            if laser_new_main_target <= 0 then
               laser_new_main_target = target;


            call calculate_and_apply_alt_attack_cost(gWeapon, alt_fire_laser, laser_max_targets, LaserForced <= 0);
         end

         return;
      end
      // gauss get new targets
      if wpn_allow_alt_gauss(gWeapon, Atktype, target_bodypart, attacker, target) then begin
         if target == real_orig_target orElse atk_rslt == CRITICAL_MISS then
            combat_target_atk_result = atk_rslt;
         else
            combat_target_atk_result = MISS;

         call get_targets_on_wide_line_gauss(attacker, target, gWeaponRange);

         //npc
         if target == attacker orElse (GaussForced <= 0 andAlso attacker != dude_obj andAlso (friendly_targets_count >= enemy_targets_count orElse enemy_targets_count < 2)) then begin
            call lvar_full_reset;
            wrong = 10;
            return;
         end
         //npc end
         if wrong < 10 then begin
            if gauss_new_main_target > 0 andAlso gauss_new_main_target != target then begin
               set_sfall_return(HIT);
               set_sfall_arg(0, HIT);
               set_sfall_return(BODY_UNCALLED);
               set_sfall_arg(3, BODY_UNCALLED);
               returned_bodypart = -1;
               set_sfall_return(gauss_new_main_target);
               set_sfall_arg(2, gauss_new_main_target);
             end

            timer = create_object_sid(pid_trans_block, 0, 0, -1);
            reg_anim_combat_check(0);
            reg_anim_begin();
            reg_anim_animate(timer, ANIM_stand, 0);
            reg_anim_animate_reverse(timer, ANIM_stand, 0);
            reg_anim_callback(gauss_line_dmg_setup);
            reg_anim_destroy(timer);
            reg_anim_end();
            if gauss_new_main_target <= 0 then begin
               gauss_new_main_target = target;
            end
         end
         return;
      end
      //gauss end

      // pistols double tap
      if PistolSecondaryAttackMod > 0 andAlso wpn_allow_alt_pistol(gWeapon, Atktype, attacker, target, hit_chance, target_bodypart) > 0 then begin
         gDoubleTapHitChance = hit_chance - PistolDoubleTapToHitPenalty - weapon_min_st * 3;
         if gDoubleTapHitChance < hit_chance / 2 then
            gDoubleTapHitChance = hit_chance / 2;
         timer = create_object_sid(pid_trans_block, 0, 0, -1);
         reg_anim_combat_check(0);
         reg_anim_begin();
         reg_anim_animate(timer, ANIM_stand, 0);
         reg_anim_animate_reverse(timer, ANIM_stand, 0);
         reg_anim_callback(pistol_double_tap_setup);
         reg_anim_destroy(timer);
         reg_anim_end();
         if PistolDoubleTapForced <= 0 andAlso attacker != dude_obj then
            returned_bodypart = BODY_HIT_TORSO;

         return;
      end
      // pistols double tap end
   end
   if returned_bodypart >= 0 then begin
      set_sfall_return(atk_rslt);
      set_sfall_arg(0, atk_rslt);
      set_sfall_return(returned_bodypart);
      set_sfall_arg(3, returned_bodypart);
   end
end

procedure COMBATDAMAGE begin
   variable target = get_sfall_arg;
   variable attacker = get_sfall_arg;
   variable damage_to_target = get_sfall_arg;
   variable damage_to_attacker = get_sfall_arg;
   variable target_flags = get_sfall_arg;
   variable attacker_flags = get_sfall_arg;
   variable weapon = get_sfall_arg;
   variable combat_body_part = get_sfall_arg;
   variable dmg_mult = get_sfall_arg;
   variable atktype = get_sfall_arg_at(11);
   variable atk_data = get_sfall_arg_at(12);
   variable target_kill_type;
   variable knockback_distance;
   variable attacker_target_distance;
   variable rnd;
   variable target_is_wearing_power_armor;
   variable stonewall_perk;
   variable actual_target = get_object_data(combat_data, C_ATTACK_TARGET);
   variable actual_attack;
   variable dmgtotar_was_return;
   variable shoot_block;
   variable attacker_tile;
   variable target_tile;
   variable arr_dmg;
   variable dist_to_actual_target;
   variable damage_to_target_new;
   variable damage_to_attacker_new;
   variable attacker_flags_new;
   variable target_flags_new;

   if (attacker != dude_obj andAlso actual_target > 0) orElse (attacker == dude_obj) then begin
      actual_attack = 1;
      call set_combat_targets_to_array;
   end

   if actual_attack <= 0 then
      return;

   if one_time_COMBATDAMAGE <= 0 then begin
      one_time_COMBATDAMAGE = 1;
      attacker_frm = anim_busy(attacker);
      if attacker == dude_obj andAlso is_aimed_burst == BODY_UNCALLED then
         set_object_data(combat_data, C_ATTACK_BODY_PART, BODY_HIT_TORSO);

      if is_aimed_burst > 0 then
         is_aimed_burst = 0;

      //LASER alt fire cmbt dmg
      if LaserSecondaryAttackMod > 0 andAlso alt_fire_selected == alt_fire_laser andAlso obj_type(target) == OBJ_TYPE_CRITTER then begin

         if (attacker_flags bwand DAM_HIT) != 0 then begin
            damage_to_target_new = calc_dmg_laser_main_target(attacker, target, attacker_flags);
            if damage_to_target > damage_to_target_new then
               damage_to_target_new = damage_to_target;

            if damage_to_target_new > 0 then begin
               target_flags = target_flags bwor DAM_BYPASS;
            end
            set_sfall_return(damage_to_target_new);
            set_sfall_arg(2, damage_to_target_new);
            set_sfall_return(damage_to_attacker);
            set_sfall_arg(3, damage_to_attacker);
            set_sfall_return(target_flags);
            set_sfall_arg(4, target_flags);
            if damage_to_target_new <= 0 then begin
               damage_to_target_new = DMG_ZERO;
               dmg_was_set_to_zero = 1;
            end
            else
               damage_to_target_new = damage_to_target_new + (((target_flags bwand 0xFFF) bwor DAM_HIT) * DMG_FLAG_MULT);
         end
         else begin
            damage_to_target_new = DMG_DODGE;
            set_sfall_return(0);
            set_sfall_arg(2, 0);
            set_sfall_return(0);
            set_sfall_arg(3, 0);
            set_sfall_return(0);
            set_sfall_arg(4, 0);
            set_sfall_return(0);
            set_sfall_arg(5, 0);
         end

         arr_dmg = get_array(Line_targets_array, target);
         if arr_dmg != 0 then begin
            if arr_dmg != damage_to_target_new then begin
               set_array(Line_targets_array, target, damage_to_target_new);
               dmg_was_set_to_zero = 1;
            end
         end

         set_array(cur_attack_results_arr, target, damage_to_target_new);
         return;
      end

      if ShotgunForced > 0 andAlso weapon > 0 then begin
         gWeaponPid = obj_pid(weapon);
         weapon_caliber = get_proto_data(gWeaponPid, PROTO_WP_CALIBER);
      end

      if attacker andAlso attacker_frm == 0 then begin
         // electric chain dmg
         //if ElecSecondaryAttackMod > 0 andAlso alt_fire_selected == alt_fire_pulse then begin
//
//
         //end
         // electric chain dmg end

         // plasma aoe dmg to attacker
         if PlasmaSecondaryAttackMod > 0 andAlso alt_fire_selected == alt_fire_plasma andAlso obj_type(target) == OBJ_TYPE_CRITTER then begin
            dist_to_actual_target = tile_distance_objs(attacker, actual_target);
            if dist_to_actual_target <= PlasmaBlastRadius andAlso ((attacker_flags bwand DAM_HIT) != 0) then
               damage_to_attacker_new = calc_dmg_plasma(attacker, attacker, dist_to_actual_target);

            if damage_to_attacker_new > 0 then begin
               set_array(cur_attack_results_arr, attacker, damage_to_attacker_new);
               attacker_flags_new = attacker_flags bwor (damage_to_attacker_new / DMG_FLAG_MULT);
               damage_to_attacker_new = damage_to_attacker + (damage_to_attacker_new % DMG_FLAG_MULT);

               set_sfall_return(damage_to_target);
               set_sfall_arg(2, damage_to_target);
               set_sfall_return(damage_to_attacker_new);
               set_sfall_arg(3, damage_to_attacker_new);
               set_sfall_return(target_flags);
               set_sfall_arg(4, target_flags);
               set_sfall_return(attacker_flags_new);
               set_sfall_arg(5, attacker_flags_new);
            end
            // if dmg is 0 now
            else if damage_to_attacker > 0 then begin
               damage_to_attacker_new = get_array(cur_attack_results_arr, attacker);
               if damage_to_attacker_new > 0 then begin
                  attacker_flags_new = attacker_flags bwand bwnot((damage_to_attacker_new / DMG_FLAG_MULT) bwand (DAM_KNOCKED_DOWN bwor DAM_CRITICAL));
                  damage_to_attacker_new = damage_to_attacker - (damage_to_attacker_new % DMG_FLAG_MULT);
                  if ((attacker_flags bwand (DAM_BACKWASH bwor DAM_HIT_SELF bwor DAM_HURT_SELF bwor DAM_EXPLODE)) != 0) then begin
                     if damage_to_attacker_new < 1 then
                        damage_to_attacker_new = 1;
                     set_sfall_return(damage_to_target);
                     set_sfall_arg(2, damage_to_target);
                     set_sfall_return(damage_to_attacker_new);
                     set_sfall_arg(3, damage_to_attacker_new);
                     set_sfall_return(target_flags);
                     set_sfall_arg(4, target_flags);
                     set_sfall_return(attacker_flags_new);
                     set_sfall_arg(5, attacker_flags_new);
                  end
                  else begin
                     if damage_to_attacker_new < 0 then
                        damage_to_attacker_new = 0;
                     set_sfall_return(damage_to_target);
                     set_sfall_arg(2, damage_to_target);
                     set_sfall_return(damage_to_attacker_new);
                     set_sfall_arg(3, damage_to_attacker_new);
                     set_sfall_return(target_flags);
                     set_sfall_arg(4, target_flags);
                     set_sfall_return(attacker_flags_new);
                     set_sfall_arg(5, attacker_flags_new);
                  end
               end
            end
            return;
         end
         // plasma aoe dmg end

         //shotgun alt fire(knockback)
         if ShotgunSecondaryAttackMod > 0 andAlso (attacker == dude_obj or ShotgunSecondaryAttackMod > 1) andAlso weapon andAlso weapon_caliber == gShotgunCaliber andAlso (target_bodypart == BODY_HIT_TORSO or ShotgunForced > 0 or ((attacker != dude_obj andAlso target_bodypart == BODY_UNCALLED) andAlso is_single_shot andAlso not(random(0,2)))) then begin
            if target == attacker orElse (attacker_flags bwand DAM_BACKWASH) then begin
               call lvar_full_reset;
               return;
            end
            distance_objs(attacker_target_distance, attacker, target);
            knockback_distance = random(ShotgunKnockbackMin, ShotgunKnockbackMax);
            if has_trait(TRAIT_OBJECT, target, OBJECT_TEAM_NUM) == TEAM_PLAYER then begin
               if target == dude_obj then begin
                  target_is_wearing_power_armor = player_wearing_power_armor;
                  stonewall_perk = has_trait(TRAIT_PERK, dude_obj, PERK_stonewall_perk);
               end
               if target_is_wearing_power_armor then begin
                  knockback_distance = 1;
                  rnd = 5;
               end
               else if stonewall_perk then begin
                  if random(0, 1) then begin
                     knockback_distance = 0;
                     rnd = 10;
                  end
                  else begin
                     knockback_distance = knockback_distance / 2;
                     rnd = random(0, 20 + 10 * ShotgunForced);
                  end
               end
               else begin
                  rnd = random(0, 10 + 10 * ShotgunForced);
               end
            end
            else begin
               target_kill_type = metarule(METARULE_CRITTER_KILL_TYPE, target);
               if power_armor_fid(critter_art_fid(target)) then target_is_wearing_power_armor = 1;
               if attacker_target_distance > 10 or is_multihex(target) or target_kill_type == KILL_TYPE_super_mutant_kills or target_kill_type == KILL_TYPE_deathclaw_kills or target_kill_type == KILL_TYPE_robot_kills or target_is_wearing_power_armor then begin
                  if knockback_distance > 1 then knockback_distance = random(1, knockback_distance / 2);
                  rnd = random(0, 4 + (6 * ShotgunForced));
               end
               else begin
                  knockback_distance = random(ShotgunKnockbackMin, ShotgunKnockbackMax);
                  rnd = random(0, 2 + (3 * ShotgunForced));
               end
            end
            if knockback_distance < 1 then knockback_distance = 1;
            if (attacker_target_distance < 10 or attacker_target_distance <= gWeaponRange / 2) then begin
               if dmgtotar_was_return <= 0 then begin
                  set_sfall_return(damage_to_target);
                  set_sfall_arg(2, damage_to_target);
                  dmgtotar_was_return = 1;
               end
               set_sfall_return(damage_to_attacker);
               set_sfall_arg(3, damage_to_attacker);
               if rnd <= 0 then begin
                  set_sfall_return(target_flags bwor DAM_KNOCKED_DOWN);
                  set_sfall_arg(4, target_flags bwor DAM_KNOCKED_DOWN);
               end
               else begin
                  set_sfall_return(target_flags);
                  set_sfall_arg(4, target_flags);
               end
               set_sfall_return(attacker_flags);
               set_sfall_arg(5, attacker_flags);
               set_sfall_return(knockback_distance);
               set_sfall_arg(10, knockback_distance);
            end
         end
         //shotgun alt fire(knockback) end

         //gauss alt dmg
         if GaussSecondaryAttackMod > 0 andAlso alt_fire_selected == alt_fire_gauss andAlso obj_type(target) == OBJ_TYPE_CRITTER then begin
            if (attacker_flags bwand DAM_HIT) != 0 then begin
               damage_to_target_new = get_array(Line_targets_array, target);
               if damage_to_target_new == 0 then begin
                  get_new_targets = 1;
                  call get_targets_on_wide_line_gauss(attacker, target, gWeaponRange);
                  damage_to_target_new = get_array(Line_targets_array, target);
               end
               if damage_to_target_new <= 0 then begin
                  damage_to_target_new = 0;
                  target_flags_new = 0;
               end
               else begin
                  target_flags_new = target_flags bwor DAM_BYPASS bwor (damage_to_target_new / DMG_FLAG_MULT);
                  damage_to_target_new = (damage_to_target_new % DMG_FLAG_MULT);
               end

               set_sfall_return(damage_to_target_new);
               set_sfall_arg(2, damage_to_target_new);
               set_sfall_return(damage_to_attacker);
               set_sfall_arg(3, damage_to_attacker);
               set_sfall_return(target_flags_new);
               set_sfall_arg(4, target_flags_new);
               if damage_to_target_new <= 0 then begin
                  damage_to_target_new = DMG_ZERO;
                  dmg_was_set_to_zero = 1;
               end
               else
                  damage_to_target_new = damage_to_target_new + (((target_flags bwand 0xFFF) bwor DAM_HIT) * DMG_FLAG_MULT);
            end
            else begin
               damage_to_target_new = DMG_DODGE;
               set_sfall_return(0);
               set_sfall_arg(2, 0);
               set_sfall_return(0);
               set_sfall_arg(3, 0);
               set_sfall_return(0);
               set_sfall_arg(4, 0);
               set_sfall_return(0);
               set_sfall_arg(5, 0);
            end

            arr_dmg = get_array(Line_targets_array, target);
            if arr_dmg != 0 then begin
               if arr_dmg != damage_to_target_new then begin
                  set_array(Line_targets_array, target, damage_to_target_new);
                  dmg_was_set_to_zero = 1;
               end
            end

            set_array(cur_attack_results_arr, target, damage_to_target_new);
            return;
         end
         //gauss alt dmg end
      end
   end
end


procedure set_spray_by_skill_and_dist(variable attacker, variable target, variable weapon, variable body_part) begin
   variable attacker_pe = get_critter_stat(attacker, STAT_pe);
   variable attacker_st = get_critter_stat(attacker, STAT_st);
   variable attacker_skill = get_ranged_weapon_skill_lvl(attacker, weapon);
   variable attacker_skill_mult = 5;
   variable wpn_pid = obj_pid(weapon);
   variable wpn_animation = get_proto_data(wpn_pid, PROTO_WP_ANIM);
   variable wpn_dmg_type = get_proto_data(wpn_pid, PROTO_WP_DMG_TYPE);
   variable burst_bullets_num = get_proto_data(wpn_pid, PROTO_WP_BURST);
   variable weapon_min_st = get_proto_data(wpn_pid, PROTO_WP_MIN_ST);
   variable Base_CenterMult = 1;
   variable CenterMult;
   variable CenterDiv = burst_bullets_num;
   variable TargetMult = 1;
   variable TargetDiv = burst_bullets_num;
   variable recoil;
   variable body_part_penalty = 1;
   variable distance = tile_distance_objs(attacker, target);
   variable distance_penalty = (10 + distance);
   variable distance_penalty_mult = 20;
   variable max_hit_chance = 100;
   variable max_hit_chance_devider;
   if distance <= 1 then
      return;

   if body_part != BODY_HIT_TORSO andAlso body_part != BODY_UNCALLED then
      max_hit_chance_devider = ((-get_bodypart_hit_modifier(body_part)) / 7.0) * 2;

   if attacker == dude_obj then begin
      attacker_pe +=  2 * has_trait(TRAIT_PERK, attacker, PERK_sharpshooter);
      attacker_st +=  3 * has_trait(TRAIT_PERK, attacker, PERK_weapon_handling_perk);
   end

   if attacker_skill > 174 then
      attacker_skill += 2.5 * (attacker_skill - 174);

   attacker_skill *=  attacker_skill_mult;

   if attacker_st < weapon_min_st then
      recoil = 1 + (weapon_min_st - attacker_st);
   else begin
      if wpn_animation != WPN_ANIM_SMG andAlso wpn_dmg_type != DMG_laser AndAlso wpn_dmg_type < DMG_electrical andAlso wpn_dmg_type > DMG_emp then begin
         if wpn_animation == WPN_ANIM_BIG_GUN then
            recoil *= 1.25;
         else if wpn_animation == WPN_ANIM_MINIGUN then
            weapon_min_st *= 1.35;
         else if wpn_animation != WPN_ANIM_SMG then
            recoil *= 1.1;
      end
      else
         weapon_min_st *= 1.05;

      recoil = 1 - (weapon_min_st - attacker_st) / 10.0;
   end

   if recoil <= 0.1 then
      recoil = 0.1;


   if distance > attacker_pe * 5 then
      distance_penalty += (distance - attacker_pe * 5);

   distance_penalty *= distance_penalty_mult * recoil * 0.2;


   CenterMult = round(attacker_skill / distance_penalty);

   if body_part == BODY_HIT_TORSO orElse body_part == BODY_UNCALLED then begin
      if CenterMult < burst_bullets_num * 0.34 then
         CenterMult = ceil(burst_bullets_num * 0.34);
   end

   if CenterMult < Base_CenterMult then
      CenterMult = Base_CenterMult;
   else if CenterMult > CenterDiv then
      CenterMult = CenterDiv;




   if max_hit_chance_devider > 0 then begin
      if recoil <= 0.5 then
         recoil = 0.5;
      max_hit_chance = round(attacker_skill / (max_hit_chance_devider * recoil));
      if max_hit_chance > 90 then
         max_hit_chance = 90;
   end

   set_spray_settings(CenterMult, CenterDiv, 1, 1);
   aimed_burst_max_hit = max_hit_chance;
   gAimedBurstTarget = target;
   return max_hit_chance;
end

procedure TOHIT begin
   variable hit_chance_capped = get_sfall_arg;
   variable attacker = get_sfall_arg;
   variable target = get_sfall_arg_at(2);
   variable hit_chance = get_sfall_arg_at(7);
   variable attacked_body_part = get_sfall_arg_at(3);
   variable new_hit_chance;
   variable npc_body_part;
   variable max_bullets;
   variable attack_anim;
   variable wpn;
   if is_aimed_burst > 0 andAlso gAimedBurstTarget > 0 andAlso target == gAimedBurstTarget then begin
      if combat_data > 0 andAlso get_object_data(combat_data, C_ATTACK_BODY_PART) != BODY_UNCALLED then begin
         //aimed_burst_max_hit = 1;
         set_sfall_return(aimed_burst_max_hit);
         set_sfall_arg(0, aimed_burst_max_hit);
         set_sfall_arg(7, aimed_burst_max_hit);
         gAimedBurstTarget = 0;
      end
   end


   if one_time_TOHIT <= 0 andAlso attacker != dude_obj andAlso combat_data > 0 andAlso get_object_data(combat_data, C_ATTACK_TARGET) > 0 then begin
      one_time_TOHIT = 1;

      real_orig_target = target;
      if attacked_body_part <= -1 then
         npc_body_part = BODY_UNCALLED;
   end
   if is_critter(target) andAlso (target == real_orig_target) then begin
      target_bodypart = attacked_body_part;
   end

   if AimedBurstMod > 0 andAlso combat_data > 0 andAlso get_object_data(combat_data, C_ATTACK_MAIN_TARGET) == target then begin
      wpn = get_object_data(combat_data, C_ATTACK_WEAPON);
      attack_anim = get_attack_anim(wpn, get_object_data(combat_data, C_ATTACK_HIT_MODE));
      if attack_anim == ANIM_fire_burst orElse (attack_anim == ANIM_fire_continuous andAlso AimedBurstModAnyWeapon > 1) then begin
         if attacker == dude_obj then begin
            if attacked_body_part != BODY_UNCALLED then begin
               is_aimed_burst = attacked_body_part + 5;
               new_hit_chance = set_spray_by_skill_and_dist(attacker, target, wpn, attacked_body_part);
            end
         end
         else if AimedBurstMod > 1 then begin
            if random(1,100) < 5 + (combat_difficulty * 5) then begin
               is_aimed_burst = random(BODY_HIT_HEAD, BODY_HIT_GROIN);
               if is_aimed_burst == BODY_HIT_EYES then begin
                  is_aimed_burst = BODY_HIT_HEAD;
               end
               //else begin
                  //if is_aimed_burst == BODY_HIT_TORSO then
                     new_hit_chance = set_spray_by_skill_and_dist(attacker, target, wpn, attacked_body_part);
               //end

                  //set_object_data(combat_data, C_ATTACK_BODY_PART, is_aimed_burst);
                  write_int(combat_data + C_ATTACK_BODY_PART, is_aimed_burst);
               is_aimed_burst = 0;
            end
         end
      end
   end
end


procedure set_torso_name(variable target, variable newName) begin
   variable newLen;
   variable ptr;
   variable max_len = 16;
   if target <= 0 then
      return 0;

   gLastCritterCalledTarget = target;
   ptr = hitLocationGetName_str_ptr(target, BODY_HIT_TORSO);

   if gLastCritterCalledTargetTorsoName == 0 then begin
      gLastCritterCalledTargetTorsoName = read_string(ptr);
   end

   newLen = strlen(newName);
   if sfall_510 > 0 then
      max_len = 5;

   if newLen > max_len then begin
      newName = substr(newName, 0, max_len);
   end

   call write_string_to_addr(ptr, newName);
end



procedure Change_torso_name(variable attacker, variable target) begin
   variable weapon = get_active_weapon(attacker);
   variable msg_id;

   if weapon <= 0 then
      return;

   if LaserForced <= 0 andAlso wpn_allow_alt_laser(weapon, gCurAtkType, BODY_HIT_TORSO, attacker, target, false) > 0 then begin
      msg_id = 101;
   end
   else if PlasmaForced <= 0 andAlso wpn_allow_alt_plasma(weapon, gCurAtkType, BODY_HIT_TORSO, attacker, target, false) > 0 then begin
      msg_id = 102;
   end
   else if ElecForced <= 0 andAlso wpn_allow_alt_pulse(weapon, gCurAtkType, BODY_HIT_TORSO, attacker, target, false) > 0 then begin
      if ElecSameTargets < 0 then
         msg_id = 103;
      else
         msg_id = 104;
   end
   else if GaussForced <= 0 andAlso wpn_allow_alt_gauss(weapon, gCurAtkType, BODY_HIT_TORSO, attacker, target) > 0 then begin
      msg_id = 105;
   end

   if msg_id > 0 then begin
      if sfall_510 > 0 then
         msg_id += 10;

      alt_fire_selected = 0;
      call set_torso_name(target, modmsg(msg_id));
   end
end

procedure TARGETOBJECT begin
   variable is_attacking = get_sfall_arg;
   variable can_be_attacked = get_sfall_arg;
   variable target = get_sfall_arg;
   call restore_torso_name;
   if target > 0 andAlso is_attacking andAlso can_be_attacked then begin
      real_orig_target = target;
      if attack_is_aimed andAlso obj_type(target) == OBJ_TYPE_CRITTER then begin
         call Change_torso_name(dude_obj, target);
      end
   end
end

//get combat speed
procedure GAMEMODECHANGE begin
   variable game_mode;
   call restore_torso_name;
   Enable_SoundEffects
end

inline procedure set_getting_up_anim(variable critter) begin
   variable cur_anim = critter_art_anim(critter);
   variable fall_fid;
   variable fall_frm;
   if critter > 0 andAlso (cur_anim == ANIM_fall_back_sf orElse cur_anim == ANIM_fall_front_sf) then begin
      if cur_anim == ANIM_fall_front_sf then
         fall_fid = critter_anim_fid(obj_art_fid(critter), ANIM_fall_front, 1);
      else
         fall_fid = critter_anim_fid(obj_art_fid(critter), ANIM_fall_back, 1);

      fall_frm = get_art_max_frames(fall_fid);

      set_object_data(critter, OBJ_DATA_FID, fall_fid);
      set_object_data(critter, OBJ_DATA_CUR_FRM, fall_frm);
      tile_refresh_display;
   end
end

procedure COMBATTURN begin
   if get_sfall_arg_at(0) <= 0 then begin
      call lvar_full_reset();
   end
end

procedure map_enter_p_proc begin
   set_proto_data(pid_ka_pow, PROTO_FID, LaserFID_expl);
   set_proto_data(pid_trans_block, PROTO_FID, INVISIBLE_MISC_FID);
end

procedure get_ini_section_int_to_int(variable file, variable section, variable fixArray := false) begin
   variable ar, ar2 := temp_array_map, k, v;
   ar := get_ini_section(file, section);
   foreach k: v in ar begin
      ar2[atoi(k)] := atoi(v);
   end

   if (fixArray) andAlso len_array(ar2) > 0 then
      fix_array(ar2);
   return ar2;
end

procedure set_aimed_button begin
   variable hand = (0x5970F8 + (active_hand * 0x18));
   variable current_mode_adr = (hand + 0x10);
   variable current_mode = read_int(current_mode_adr);
   write_int(current_mode_adr, current_mode + 1);
   write_int(0x519024, InterfaceBarWindow);
   intface_redraw;
end

procedure set_aimed_burst(variable key_is_pressed = 0) begin
   variable timer;
   variable combat_state;
   InterfaceBarWindow = read_int(0x519024);
   write_int(0x519024, -1);
   if key_is_pressed <= 0 then begin
      combat_state = read_int(0x510944);
      write_int(0x510944, 2);
      timer = create_object_sid(pid_trans_block, 0, 0, -1);
      reg_anim_combat_check(0);
      reg_anim_begin();
      reg_anim_animate(timer, ANIM_stand, 0);
      reg_anim_animate_reverse(timer, ANIM_stand, 0);
      reg_anim_callback(set_aimed_button);
      reg_anim_destroy(timer);
      reg_anim_end();
      write_int(0x510944, combat_state);
   end
   else
      call set_aimed_button in 0;
end

procedure MOUSECLICK begin
   variable is_pressed;
   variable mouse_button;
   variable game_mode;
   variable mouse_x;
   variable mouse_y ;
   variable IFACEBAR_X;
   variable IFACEBAR_Y;
   if aimed_burst_allowed > 0 then begin
      is_pressed = get_sfall_arg;
      mouse_button = get_sfall_arg;
      if is_pressed == 0 andAlso mouse_button == MOUSE_BTN_RIGHT then begin
         game_mode = get_game_mode;
         if (game_mode == 0 orElse game_mode == (COMBAT bwor PCOMBAT)) andAlso call_offset_r0(0x45EB90) then begin
            mouse_x = get_mouse_x;
            mouse_y = get_mouse_y;
            IFACEBAR_X = sfall_func2("get_window_attribute", WINTYPE_IFACEBAR, 1);
            IFACEBAR_Y = sfall_func2("get_window_attribute", WINTYPE_IFACEBAR, 2);
            if mouse_x >= IFACEBAR_X + read_int(0x518F68 + 0x14) andAlso mouse_x < IFACEBAR_X + read_int(0x518F68 + 0x1C) then begin
               if mouse_y >= IFACEBAR_Y + read_int(0x518F68 + 0x18) andAlso mouse_y < IFACEBAR_Y + read_int(0x518F68 + 0x20) then begin
                  call set_aimed_burst;
               end
            end
         end
      end
   end
end

procedure KEYPRESS begin
   variable is_pressed;
   variable dx_key;
   variable game_mode;
   if aimed_burst_allowed > 0 then begin
      is_pressed = get_sfall_arg;
      dx_key = get_sfall_arg;
      if dx_key == DIK_N andAlso is_pressed == 1 then begin
         game_mode = get_game_mode;
         if (game_mode == 0 orElse game_mode == (COMBAT bwor PCOMBAT)) andAlso call_offset_r0(0x45EB90) then begin
            call set_aimed_burst(true);
         end
      end
   end
end

procedure ROLLCHECK begin
   variable roll_type = get_sfall_arg;
   variable roll_result = get_sfall_arg;
   variable roll_chance = get_sfall_arg;
   variable roll_bonus = get_sfall_arg;
   variable roll_random = get_sfall_arg;
   variable body_part;
   if is_aimed_burst > 0 then begin
      if roll_type == 1 then begin
         body_part = get_object_data(combat_data, C_ATTACK_BODY_PART);
         if roll_result == ROLL_SUCCESS andAlso -(get_bodypart_hit_modifier(body_part)) >= random(0,100) then begin
            set_sfall_return(ROLL_CRITICAL_SUCCESS);
            set_sfall_arg(1, ROLL_CRITICAL_SUCCESS);
         end
      end
   end
end


procedure get_wpn_range(variable attacker, variable weapon,variable hit_type) begin
   variable weapon_range;
   if weapon <= 0 then begin
      if (get_proto_data(obj_pid(attacker), PROTO_CR_FLAGS) bwand CFLG_RANGED) == CFLG_RANGED then
         weapon_range = 2;
      else
         weapon_range = 1;

      return weapon_range;
   end

   if hit_type == hit_left_weapon_primary orElse hit_type == hit_right_weapon_primary then begin
      weapon_range = get_proto_data(obj_pid(weapon), PROTO_WP_RANGE_1);
   end
   else begin
      weapon_range = get_proto_data(obj_pid(weapon), PROTO_WP_RANGE_2);
   end

   return weapon_range;
end


procedure ITEMDAMAGE begin
   variable weapon;
   variable weapon_range;
   variable attack_hit_type;
   variable attacker;
   variable combat_target;
   variable dmg_to_target;
   variable set_new_min_dmg;
   variable set_new_max_dmg;
   variable set_new_dmg;
   if alt_fire_selected == alt_fire_gauss then begin
      combat_target = get_object_data(combat_data, C_ATTACK_TARGET);
      if combat_target > 0 then begin
         weapon = get_sfall_arg_at(2);
         if weapon <= 0 then
            return;
         dmg_to_target = get_array(Line_targets_array, combat_target);
         if dmg_to_target == 0 then begin
            attacker = get_sfall_arg_at(3);
            attack_hit_type = get_sfall_arg_at(4);
            weapon_range = get_wpn_range(attacker, weapon, attack_hit_type);
            get_new_targets = 1;
            call get_targets_on_wide_line_gauss(attacker, combat_target, weapon_range);

         end
         if gGaussWeaponDmgCombatTarget >= 0 then begin
            if gGaussWeaponDmgCombatTarget < 0 then
               gGaussWeaponDmgCombatTarget = 0;

            set_new_min_dmg = gGaussWeaponDmgCombatTarget;
            set_sfall_arg(0, set_new_min_dmg);
            set_new_max_dmg = gGaussWeaponDmgCombatTarget;
            set_sfall_arg(1, set_new_max_dmg);
            set_new_dmg = 1;
         end
      end
   end
   if alt_fire_selected == alt_fire_plasma then begin
      gWeaponMinDmg = get_sfall_arg_at(0);
      gWeaponMaxDmg = get_sfall_arg_at(1);

      set_new_min_dmg = ((gWeaponMinDmg * 12) / 10);
      set_new_max_dmg = ((gWeaponMaxDmg * 12) / 10);
      set_new_dmg = 1;
   end

   if set_new_dmg > 0 then begin
      gWeaponMinDmg = set_new_min_dmg;
      gWeaponMaxDmg = set_new_max_dmg;

      set_sfall_return(gWeaponMinDmg);
      set_sfall_arg(0, gWeaponMinDmg);
      set_sfall_return(gWeaponMaxDmg);
      set_sfall_arg(1, gWeaponMaxDmg);
   end
end

procedure start begin
   variable test;
   variable SecondaryAttackMod;
   variable AnimationsAtOnceLimit;
   if game_loaded then begin
      import_alt_attack_aoe_targets_arr = create_array_map;
      LaserFID = get_proto_data(pid_ka_pow, PROTO_FID);
      LaserFID_expl = get_proto_data(0x500001B, PROTO_FID); //PID_EXPLOSION_4
      set_proto_data(pid_ka_pow, PROTO_FID, LaserFID_expl);
      set_proto_data(pid_trans_block, PROTO_FID, INVISIBLE_MISC_FID);
      SecondaryAttackMod = get_ini_setting("mods\\F2MechanicsMiniRework.ini|MAIN|SecondaryAttackMod");
      if SecondaryAttackMod > 0 then begin
         AnimationsAtOnceLimit = get_ini_setting("ddraw.ini|Misc|AnimationsAtOnceLimit");
         if AnimationsAtOnceLimit < 127 then
            set_ini_setting("ddraw.ini|Misc|AnimationsAtOnceLimit", 127);

         //if get_proto_data(PID_10MM_AP, PROTO_AM_DR_MOD) > 0 orElse get_proto_data(PID_ROCKET_AP, PROTO_AM_DR_MOD) > 0 then
            //YAAM_active = 1;

         if get_ini_setting("ddraw.ini|Misc|DamageFormula") == 5 then
            YAAM_active = 1;


         sfall_ver_maj = sfall_ver_major;
         ver_minor = sfall_ver_minor;
         ver_build = sfall_ver_build;
         COMBAT_SPEED_MAX = 127;
         if sfall_ver_maj >= 5 then begin
            if ver_build >= 8 orElse sfall_ver_maj > 5 orElse ver_minor > 0 then begin
               if ver_minor > 0 then begin
                  sfall_510 = 1;
                  COMBAT_SPEED_MAX = 50;
                  unsafe_script;
               end
            end
         end
         //if sfall_510 <= 0 then
            //anim_priority_byte = read_byte(0x413C20);


         gLivingAnatomyBonus = get_ini_setting("sfall\\Perks.ini|PerksTweak|LivingAnatomyBonus");
         if gLivingAnatomyBonus < 0 then
            gLivingAnatomyBonus = 5;
         gPyromaniac_bonus = get_ini_setting("sfall\\Perks.ini|PerksTweak|PyromaniacBonus");
         if gPyromaniac_bonus < 0 then
            gPyromaniac_bonus = 5;

         allow_critical = get_ini_setting("mods\\F2MechanicsMiniRework.ini|SecondaryAttack|AllowCriticalHits");
         if allow_critical > 0 then begin
            allow_critical = 10;
         end
         traits_plus = get_ini_setting("mods\\F2MechanicsMiniRework.ini|Main|TraitsPlus");
         if traits_plus > 0 then begin
            //bloody_mess_plus = get_ini_setting("mods\\F2MechanicsMiniRework.ini|TraitsPlus|Bloody_Mess");
            //if bloody_mess_plus <= 0 then begin
               //bloody_mess_plus = -1;
            //end
            //else if bloody_mess_plus > 1 then begin
               //bloody_mess_plus = 10;
            //end

            //kamikaze_plus = get_ini_setting("mods\\F2MechanicsMiniRework.ini|TraitsPlus|Kamikaze");
            //if kamikaze_plus <= 0 then begin
               //kamikaze_plus = -1;
            //end
            //else if kamikaze_plus > 1 then begin
               //kamikaze_plus = 10;
            //end
            if allow_critical <= 0 then begin
               finesse_plus = get_ini_setting("mods\\F2MechanicsMiniRework.ini|TraitsPlus|Finesse");
               if finesse_plus <= 0 then begin
                  finesse_plus = -1;
               end
            end
         end
         Sonora = get_ini_setting("mods\\F2MechanicsMiniRework.ini|Main|Sonora");
         show_float_dmg = get_ini_setting("mods\\F2MechanicsMiniRework.ini|SecondaryAttack|SecondaryAttackShowFloatMSG");
         AllowSniperPerk = get_ini_setting("mods\\F2MechanicsMiniRework.ini|SecondaryAttack|AllowSniperPerk");
         LaserSecondaryAttackMod = get_ini_setting("mods\\F2MechanicsMiniRework.ini|SecondaryAttack|LaserSecondaryAttackMod");
         if LaserSecondaryAttackMod > 0 then begin
            //LaserLineWidth = get_ini_setting("mods\\F2MechanicsMiniRework.ini|SecondaryAttack|LaserLineWidth");
            //if LaserLineWidth < 0 then LaserLineWidth = 0;
            //if LaserLineWidth > 1 then LaserLineWidth = 1;
            //LaserLineWidth = 1;
            //LaserHitChance = get_ini_setting("mods\\F2MechanicsMiniRework.ini|SecondaryAttack|LaserHitChance");
            LaserHitChance = 1;
            LaserForced = get_ini_setting("mods\\F2MechanicsMiniRework.ini|SecondaryAttack|LaserForcedActivation");

            LaserCustomPids = string_split_ints(get_ini_string("mods\\F2MechanicsMiniRework.ini|SecondaryAttack|LaserCustomPids"), ",");

            laser_max_targets_two_handed_micro_fusion = 1 + get_ini_setting("mods\\F2MechanicsMiniRework.ini|SecondaryAttack|MaxAddTargets_TWMFC");
            if laser_max_targets_two_handed_micro_fusion < 1 then laser_max_targets_two_handed_micro_fusion = 999;
            laser_max_targets_one_handed_micro_fusion = 1 + get_ini_setting("mods\\F2MechanicsMiniRework.ini|SecondaryAttack|MaxAddTargets_OWMFC");
            if laser_max_targets_one_handed_micro_fusion < 1 then laser_max_targets_one_handed_micro_fusion = 999;
            laser_max_targets_two_handed_small_cell = 1 + get_ini_setting("mods\\F2MechanicsMiniRework.ini|SecondaryAttack|MaxAddTargets_TWSEC");
            if laser_max_targets_two_handed_small_cell < 1 then laser_max_targets_two_handed_small_cell = 999;
            laser_max_targets_one_handed_small_cell = 1 + get_ini_setting("mods\\F2MechanicsMiniRework.ini|SecondaryAttack|MaxAddTargets_OWSEC");
            if laser_max_targets_one_handed_small_cell < 1 then laser_max_targets_one_handed_small_cell = 999;

         end

         ElecSecondaryAttackMod = get_ini_setting("mods\\F2MechanicsMiniRework.ini|SecondaryAttack|PulseSecondaryAttackMod");
         if ElecSecondaryAttackMod > 0 then begin
            ElecSameTargets = get_ini_setting("mods\\F2MechanicsMiniRework.ini|SecondaryAttack|PulseAllowSameTargets");
            //ElecRNDTargets = get_ini_setting("mods\\F2MechanicsMiniRework.ini|SecondaryAttack|PulseRNDTargets");
            //if ElecRNDTargets > 0 then
               //ElecRNDTargets = 2;
            ElecDamageReductionPerTarget = get_ini_string("mods\\F2MechanicsMiniRework.ini|SecondaryAttack|PulseDamageReduction");
            if ElecDamageReductionPerTarget == "" then
               ElecDamageReductionPerTarget = 0.8;
            else begin
               ElecDamageReductionPerTarget = atof(ElecDamageReductionPerTarget);
               ElecDamageReductionPerTarget = 1 - (ElecDamageReductionPerTarget / 100.0);
            end



            ElecRadius = get_ini_setting("mods\\F2MechanicsMiniRework.ini|SecondaryAttack|PulseMaxRadius");
            if ElecRadius <= 0 then ElecRadius = 5;
            ElecMaxTargets = get_ini_setting("mods\\F2MechanicsMiniRework.ini|SecondaryAttack|PulseMaxTargets");
            if ElecMaxTargets <= 0 then
               ElecMaxTargets = 2;

            ElecForced = get_ini_setting("mods\\F2MechanicsMiniRework.ini|SecondaryAttack|PulseForcedActivation");
            //ElecFriendlyFire = get_ini_setting("mods\\F2MechanicsMiniRework.ini|SecondaryAttack|PulseDiableFriendlyFire");
            ElecCustomPids = string_split_ints(get_ini_string("mods\\F2MechanicsMiniRework.ini|SecondaryAttack|PulseCustomPids"), ",");
         end

         GaussSecondaryAttackMod = get_ini_setting ("mods\\F2MechanicsMiniRework.ini|SecondaryAttack|GaussSecondaryAttackMod");
         if GaussSecondaryAttackMod > 0 then begin
            //GaussLineWidth = get_ini_setting ("mods\\F2MechanicsMiniRework.ini|SecondaryAttack|GaussLineWidth");
            //if GaussLineWidth < 0 then GaussLineWidth = 0;
            //if GaussLineWidth > 1 then GaussLineWidth = 1;

            //GaussHitChance = get_ini_setting ("mods\\F2MechanicsMiniRework.ini|SecondaryAttack|GaussHitChance");
            GaussHitChance = 1;
            GaussDamageReductionPerTarget = get_ini_string("mods\\F2MechanicsMiniRework.ini|SecondaryAttack|GaussDamageReduction");
            if GaussDamageReductionPerTarget == "" then
               GaussDamageReductionPerTarget = 17;
            else
               GaussDamageReductionPerTarget = atof(GaussDamageReductionPerTarget);

            GaussForced = get_ini_setting("mods\\F2MechanicsMiniRework.ini|SecondaryAttack|GaussForcedActivation");

            GaussCustomPids = string_split_ints(get_ini_string("mods\\F2MechanicsMiniRework.ini|SecondaryAttack|GaussCustomPids"), ",");
         end

         PlasmaSecondaryAttackMod = get_ini_setting("mods\\F2MechanicsMiniRework.ini|SecondaryAttack|PlasmaSecondaryAttackMod");
         if PlasmaSecondaryAttackMod > 0 then begin
            PlasmaBlastRadius = get_ini_setting("mods\\F2MechanicsMiniRework.ini|SecondaryAttack|PlasmaBlastRadius");
            if PlasmaBlastRadius < 1 then PlasmaBlastRadius = 2;
            PlasmaDamageReductionPerTile = get_ini_string("mods\\F2MechanicsMiniRework.ini|SecondaryAttack|PlasmaDamageReduction");
            if PlasmaDamageReductionPerTile == "" then
               PlasmaDamageReductionPerTile = 25;
            else
               PlasmaDamageReductionPerTile = atof(PlasmaDamageReductionPerTile);

            PlasmaForced = get_ini_setting("mods\\F2MechanicsMiniRework.ini|SecondaryAttack|PlasmaForcedActivation");

            PlasmaCustomPids = string_split_ints(get_ini_string("mods\\F2MechanicsMiniRework.ini|SecondaryAttack|PlasmaCustomPids"), ",");
         end

         ShotgunSecondaryAttackMod = get_ini_setting("mods\\F2MechanicsMiniRework.ini|SecondaryAttack|ShotgunSecondaryAttackMod");
         if Sonora > 0 then
            gShotgunCaliber = 5;
         else
            gShotgunCaliber = CALIBER_12_GAUGE;

         if ShotgunSecondaryAttackMod > 0 then begin
            ShotgunKnockbackMin = get_ini_setting("mods\\F2MechanicsMiniRework.ini|SecondaryAttack|ShotgunKnockbackMin");
            if ShotgunKnockbackMin < 1 then ShotgunKnockbackMin = 1;
            ShotgunKnockbackMax = get_ini_setting("mods\\F2MechanicsMiniRework.ini|SecondaryAttack|ShotgunKnockbackMax");
            if ShotgunKnockbackMax < 1 then ShotgunKnockbackMax = 5;
            ShotgunForced = get_ini_setting("mods\\F2MechanicsMiniRework.ini|SecondaryAttack|ShotgunForcedActivation");
         end

         PistolSecondaryAttackMod = get_ini_setting("mods\\F2MechanicsMiniRework.ini|SecondaryAttack|PistolSecondaryAttackMod");
         if PistolSecondaryAttackMod > 0 then begin
            PistolDoubleTapToHitPenalty = get_ini_setting("mods\\F2MechanicsMiniRework.ini|SecondaryAttack|PistolDoubleTapToHitPenalty");
            PistolDoubleTapForced = get_ini_setting("mods\\F2MechanicsMiniRework.ini|SecondaryAttack|PistolForcedActivation");
         end

         AimedBurstMod = get_ini_setting("mods\\F2MechanicsMiniRework.ini|SecondaryAttack|AimedBurstSecondaryAttackMod");
         if AimedBurstMod > 0 then begin
            AimedBurstModAnyWeapon = get_ini_setting("mods\\F2MechanicsMiniRework.ini|SecondaryAttack|AimedBurstAnyWeapon");

         end

         SecondaryAttackMod_msg = add_extra_msg_file(msg_file);

         //ecco AMMOCOST
         ecco_ammocost_map = get_ini_section_int_to_int("ecco\\combat.ini","AMMOCOST", true);

         register_hook_proc(HOOK_ITEMDAMAGE, ITEMDAMAGE);
         register_hook_proc(HOOK_COMBATDAMAGE, COMBATDAMAGE);
         register_hook_proc_spec(HOOK_AFTERHITROLL, AFTERHITROLL);
         register_hook_proc_spec(HOOK_TARGETOBJECT, TARGETOBJECT);
         register_hook_proc_spec(HOOK_GAMEMODECHANGE, GAMEMODECHANGE);
         register_hook_proc_spec(HOOK_TOHIT, TOHIT);
         register_hook_proc_spec(HOOK_CALCAPCOST, CALCAPCOST);
         register_hook_proc_spec(HOOK_COMBATTURN, COMBATTURN);

         if AimedBurstMod > 0 then begin
            register_hook_proc_spec(HOOK_MOUSECLICK, MOUSECLICK);
            register_hook_proc_spec(HOOK_KEYPRESS, KEYPRESS);
            register_hook_proc_spec(HOOK_ROLLCHECK, ROLLCHECK);
         end

         set_global_script_type(0);
         set_global_script_repeat(0);

         intface_redraw;
      end
   end
end
