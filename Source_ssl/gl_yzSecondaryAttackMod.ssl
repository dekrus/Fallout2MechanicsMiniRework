#define SFALL_SC_EVALUATION   (true)  // short - circuit evaluation
#define msg_file "gl_SecondaryAttackMod.msg"
//#define combat_msg_file "COMBAT.msg"
#define is_critter(obj)   (obj_type(obj) == OBJ_TYPE_CRITTER)
#define is_multihex(critter_obj)  (get_flags(critter_obj) bwand FLAG_MULTIHEX)
#define is_prone(critter_obj)  (critter_state(critter_obj) == CRITTER_IS_PRONE)
#define is_dead(critter_obj) (critter_state(critter_obj) == CRITTER_IS_DEAD)
#define critter_art_fid(critter_obj)   (obj_art_fid(critter_obj) bwand 0xFFFF0FFF)
#define art_exists_death_anim(critter_obj,ANIM_num)  (art_exists((obj_art_fid(critter_obj) bwand 0xFF00FFFF) bwor (ANIM_num * 0x10000 + 0x10000000))) // knockdown and death   20-35
#define art_exists_basic_anim(critter_obj,ANIM_num)  (art_exists((obj_art_fid(critter_obj) bwand 0xFF00FFFF) bwor (ANIM_num * 0x10000)))
#define ShootThru(obj)   ((get_flags(obj) bwand FLAG_SHOOTTHRU) or (obj_type(obj) == OBJ_TYPE_CRITTER))

#define power_armor_fid(critter_fid)   (critter_fid == FID_HAPOWR or \
                                       critter_fid == FID_NAPOWR or \
                                       critter_fid == FID_HANPWR or \
                                       critter_fid == FID_MABOSS)


#define modmsg(x) message_str_game(SecondaryAttackMod_msg, x)
#define msg_hit 1
#define msg_hit_add 2
#define msg_critical_hit 3
#define msg_critical_hit_add 4
#define msg_dmg_KO random(5,9)
#define msg_death random(10,13)
#define msg_instant_death random(14,15)
#define msg_hit_no_dmg 16
#define msg_gift_exp_start 17
#define msg_gift_exp_end 18
#define msg_hit_1_hp 19
#define msg_hit_add_1_hp 20
#define msg_critical_hit_1_hp 21
#define msg_critical_hit_add_1_hp 22

#define combat_msg_you 506

#define combat_msg_hit_dmg 513
#define combat_msg_hit_1_dmg 523
#define combat_msg_hit_no_dmg 527






#define PID_SONORA_SMALL_ENERGY_CELL 1
#define PID_SONORA_MICRO_FUSION_CELL 2
#define pid_laser_projectile (0x05000009)
#define pid_plasma_big_projectile  (0x500000A)
#define pid_electric_projectile  (0x500000D)
#define pid_emp_expl  (0x5000008)
#define pid_sonora_railgun 183
#define SONORA_COMBAT_EXP_GLOBAL_NUM 20
#define CRITICAL_MISS          0
#define MISS                   1
#define HIT                    2
#define CRITICAL_HIT           3
#define LEFT_HAND              0
#define RIGHT_HAND             1
#define base_ammo_cost         1
#define base_alt_ammo_cost     1
#define PROTO_CR_BASE_DT(damage_type) (104 + (4 * damage_type))
#define PROTO_CR_BONUS_DT(damage_type) (244 + (4 * damage_type))
#define PROTO_CR_BASE_DR(damage_type) (132 + (4 * damage_type))
#define PROTO_CR_BONUS_DR(damage_type) (272 + (4 * damage_type))
#define reg_anim_animate_and_move(object, tile, animID, delay)                 sfall_func4("reg_anim_animate_and_move", object, tile, animID, delay)
#define set_obj_script_fixed_value(obj_sid, value) call_offset_v2(0x4A3B34, obj_sid, value)
#define set_obj_script_objects(obj_sid, source, target) call_offset_v3(0x4A3B0C, obj_sid, source, target)
#define exec_obj_script_proc(obj_sid, script_proc_type) call_offset_v2(0x4A4810, obj_sid, script_proc_type)
#define get_combat_exp read_int(0x56D398)
#define set_combat_exp(value) write_int(0x56D398,value)
#define inc_kill_count(kill_type) call_offset_v1(0x42D878, kill_type)
#define set_who_hit_me(critter,obj,attacker_critter_obj) call_offset_v2(0x42E4C0,critter,obj,attacker_critter_obj)
#define get_critter_xp(critter_obj) (get_proto_data(obj_pid(critter_obj), PROTO_CR_EXP_VAL))
#define DMG_BURST 16
#define DMG_BURST_HEAVY 32
#define OUTLINE_BLINKING_CYAN 0xEBF0
#define DAM_FLAGS_MULT 100000

#include "define_extra.h"
#include "DEFINE.H"
#include "sfall.h"
#include "lib.strings.h"


variable SecondaryAttackMod_msg;
variable LaserSecondaryAttackMod;
variable LaserLineWidth;
variable LaserHitChance;
variable LaserForced;
variable ElecSecondaryAttackMod;
variable ElecMaxTargets;
variable ElecRadius;
variable ElecDmgMin = 50;
variable ElecDmgMax = 100;
variable ElecHitChance;
variable ElecForced;
variable ElecAmmoCost = 3;
variable GaussSecondaryAttackMod;
variable GaussLineWidth;
variable GaussHitChance;
variable GaussDamageReductionPerTarget;
variable GaussForced;
variable PlasmaSecondaryAttackMod;
variable PlasmaBlastRadius;
variable PlasmaDamagePercentage;
variable PlasmaForced;
variable PlasmaAmmoCost = 3;
variable ShotgunSecondaryAttackMod;
variable ShotgunKnockbackMin;
variable ShotgunKnockbackMax;
variable ShotgunForced;
variable PistolSecondaryAttackMod;
variable AllowSniperPerk;
variable show_float_dmg;
variable Sonora;

variable target_bodypart;
variable atk_rslt =-1;
variable missed_shot;
variable combat_dmg;
variable first_combat_dmg;
variable orig_attacker;
variable orig_target;
variable COMBATDAMAGE_target;
variable real_orig_target;
variable new_dmg_to_orig_target;
variable pre_targets_array;
variable targets_array;
variable dmg_array;
variable crit_roll_array;
variable death_array;
variable crit_power_roll;
variable last_dmg;
variable new_targets_count;
variable targets_count;
variable friendly_targets_count;
variable enemy_targets_count;
variable enemy_team;
variable missed_targets_count;
variable multihex_targets_count;
variable laser_curr_ammo;
variable new_main_target;
variable last_target_on_a_line;
variable remainder;
variable one_time_call;
variable proj_pid_changed;
variable bonus_crit_power_roll;
variable bonus_ranged_damage;
variable living_anatomy;
variable living_anatomy_bonus;
variable night_vision;
variable sniper;
variable sharpshooter;
variable weapon_handling;
variable bloody_mess;
variable one_hander;
variable one_hander_bonus;
variable finesse;
variable weapon;
variable weapon_pid;
variable weapon_anim;
variable weapon_flags;
variable weapon_ammo_pid;
variable weapon_caliber;
variable weapon_damage_type;
variable weapon_range;
variable weapon_min_st;
variable weapon_min_dmg;
variable weapon_max_dmg;
variable weapon_perk;
variable weapon_proj_pid;
variable weapon_cur_ammo;
variable ammo_mult;
variable ammo_div;
variable ammo_dr_mod;
variable ammo_ac_mod;
variable laser_max_targets_two_handed_micro_fusion;
variable laser_max_targets_one_handed_micro_fusion;
variable laser_max_targets_two_handed_small_cell;
variable laser_max_targets_one_handed_small_cell;
variable pistol_double_tap_weapon;
variable pistol_double_tap_weapon_last_ammo;
variable pistol_double_tap_activated;
variable pistol_double_tap_in_process;
variable pistol_double_tap_in_process_missed;
variable pistol_double_tap_visual;
variable pistol_double_tap_target;
variable pistol_double_tap_current_target;
variable pistol_double_tap_target_selected;
variable pistol_double_tap_attacker_tile;
variable pistol_double_tap_taps;
variable pistol_double_tap_max_taps;
variable pistol_double_tap_ap_cost;
variable pistol_double_tap_miss;
variable pistol_double_tap_to_hit_penalty;
variable alt_fire_used;
variable attacker_frm = -1;
variable is_single_shot;
variable shotgun_caliber;
variable old_emp_expl;
variable npc_orig_tar;
variable elec_tar_num;
variable obj_make_visible;
variable lvar_cleared;

variable traits_plus;
variable kamikaze;
variable allow_critical;
variable kamikaze_plus;
variable finesse_plus;

//procedure disable_ui begin
   //if not(game_ui_is_disabled) then begin
      //call_offset_v1(0x443BFC,1);//game_ui_disable but allow screen_moving
      //call_offset_v1(0x44C840,26);// set_cursor_mode animated_watch_wait
   //end
//end

//procedure enable_ui begin
   //game_ui_enable;
//end

procedure kill_dude begin
   critter_heal(dude_obj, -(get_critter_stat(dude_obj, STAT_current_hp)));
end



procedure restore_weapon_proj_pid begin
   if proj_pid_changed > 0 then begin
      if weapon_proj_pid > 0 then begin
         set_proto_data(weapon_pid, PROTO_WP_PROJ_PID, weapon_proj_pid);
      end
      else begin
         set_proto_data(weapon_pid, PROTO_WP_PROJ_PID, 0);
      end
      proj_pid_changed = 0;
   end
end

procedure get_one_hander_bonus(variable weapon_flags) begin
   variable one_hander_bonus;
   if weapon_flags bwand WEAPON_2HAND then begin
      one_hander_bonus = -40;
   end
   else begin
      one_hander_bonus = 20;
   end
   return one_hander_bonus;
end

//get_target light for non dude_obj critter
procedure obj_get_visible_light(variable critter) begin
   variable ambient_light = get_light_level;
   variable target_tile_light = tile_light(elevation(critter), tile_num(critter));
   variable visible_light = ambient_light;
   if critter != dude_obj andAlso target_tile_light > ambient_light then begin
      visible_light = target_tile_light;
   end
   return visible_light;
end

// reproduced fallout 2 hit chance pseudo code for ranged weapons excluding throwing
procedure get_ranged_chance_to_hit(variable attacker,variable target) begin
   variable target_pid = obj_pid(target);
   variable target_ac = get_critter_stat(target, STAT_ac);
   variable attacker_pe = get_critter_stat(attacker, STAT_pe);
   variable attacker_st = get_critter_stat(attacker, STAT_st);
   variable tar_cur_frm = get_object_data(target, OBJ_DATA_CUR_FRM);
   variable obj_visible_light = obj_get_visible_light(target);
   variable bodypart_hit_modifier = get_bodypart_hit_modifier(target_bodypart);
   variable darkness_penalty;
   variable blocking_penalty = 5;//in Fallout 2 the default is 10
   variable multihex_blocking_penalty = 10;//in Fallout 2 the default is 20
   variable targets_num_between = (new_targets_count - 1);
   variable multihex_targets_num_between = multihex_targets_count;
   variable weapon_skill;
   variable hit_chance;
   variable distance;
   variable distance_beyond_visibility;// if attacker is blind
   variable PERK_bonus_distance;// if attacker is blind
   distance_objs(distance, attacker, target);
   // bodypart_hit_modifier penalty
   if bodypart_hit_modifier then begin
      hit_chance = hit_chance + bodypart_hit_modifier;
   end

   //darkness to_hit penalty in low light(considering PERK_night_vision) without PERK_weapon_night_sight
   if weapon_perk != PERK_weapon_night_sight andAlso obj_visible_light <= 52428 then begin
      if obj_visible_light < 26214 then begin
         darkness_penalty = 40;
      end
      else if obj_visible_light < 39321 then begin
         darkness_penalty = 25;
      end
      else if obj_visible_light < 52428 then begin
         darkness_penalty = 10;
      end
   end

   //bonus if target is prone
   if is_prone(target) then begin
      hit_chance = hit_chance + 40;
   end

   // Modify target AC by ammo_ac_mod
   if ammo_ac_mod then begin
      target_ac = target_ac + ammo_ac_mod;
   end
   // AC cannot be negative
   if target_ac < 0 then target_ac = 0;

   // get sharpshooter bonus to Perception. Works past 10 Perception
   if sharpshooter then begin
      attacker_pe = attacker_pe + 2 * sharpshooter;
   end

   // get weapon_handling_perk bonus to Strength. Works past 10 Strength
   if weapon_handling then begin
      attacker_st = attacker_st + 3 * weapon_handling;
   end
   // get strength penalty
   if attacker_st < weapon_min_st then begin
      hit_chance = hit_chance - 20 * (weapon_min_st - attacker_st);
   end

   // get the number of non-multihex targets between target and attacker
   if multihex_targets_num_between < 0 then multihex_targets_num_between = 0;
   if multihex_targets_num_between > 0 then begin
      targets_num_between = targets_num_between - multihex_targets_count;
      if targets_num_between < 0 then targets_num_between = 0;
   end

   // + 15% bonus to hit chance if target has FLAG_MULTIHEX
   if is_multihex(target) then begin
      hit_chance = hit_chance + 15;
   end

   //get attacker weapon_skill level
   if (weapon_flags bwand WEAPON_ENERGY) or weapon_damage_type == DMG_laser or weapon_damage_type == DMG_plasma or weapon_damage_type == DMG_electrical then begin
      weapon_skill = has_skill(attacker, SKILL_ENERGY_WEAPONS);
   end
   else begin
      if weapon_flags bwand WEAPON_BIGGUN then begin
         weapon_skill = has_skill(attacker, SKILL_BIG_GUNS);
      end
      else begin
         weapon_skill = has_skill(attacker, SKILL_SMALL_GUNS);
      end
   end

   // hit chance formula for weapons without perks
   if weapon_perk <= 0 or (weapon_perk != PERK_weapon_long_range andAlso weapon_perk != PERK_weapon_scope_range) then begin
      hit_chance = hit_chance + weapon_skill + ((attacker_pe - 2) * 8) - darkness_penalty - target_ac - (4 * (distance + 1)) - (blocking_penalty * targets_num_between) - (multihex_blocking_penalty * multihex_targets_num_between);
   end

   //new hit chance formula for PERK_weapon_long_range
   if weapon_perk == PERK_weapon_long_range then begin
      hit_chance = hit_chance + weapon_skill + ((attacker_pe - 2) * 16) - darkness_penalty - target_ac - (4 * (distance + 1)) - (blocking_penalty * targets_num_between) - (multihex_blocking_penalty * multihex_targets_num_between);
   end

   // new hit chance formula for PERK_weapon_scope_range
   if weapon_perk == PERK_weapon_scope_range then begin
      if distance < 7 then begin
         hit_chance = hit_chance + weapon_skill - 32 - darkness_penalty - target_ac - (4 * (distance + 1)) - (blocking_penalty * targets_num_between) - (multihex_blocking_penalty * multihex_targets_num_between);
      end
      else begin
         hit_chance = hit_chance + weapon_skill + ((attacker_pe - 2) * 20) - darkness_penalty - target_ac - (4 * (distance + 1)) - (blocking_penalty * targets_num_between) - (multihex_blocking_penalty * multihex_targets_num_between);
      end
   end

   // net +20% to_hit bonus for PERK_weapon_accurate
   if weapon_perk == PERK_weapon_accurate then begin
      hit_chance = hit_chance + 20;
   end

   // penalty if attacker is blind start
   if Is_Blind(attacker) then begin
      hit_chance = hit_chance - 25;
      // penalty if attacker is blind and weapons without perks
      if weapon_perk <= 0 or (weapon_perk != PERK_weapon_long_range andAlso weapon_perk != PERK_weapon_scope_range) then begin
         distance_beyond_visibility = 2 * attacker_pe - 5;
         if distance > distance_beyond_visibility then begin
            hit_chance = hit_chance - 8 * (distance - distance_beyond_visibility);
         end
      end
      //penalty if attacker is blind for PERK_weapon_long_range
      if weapon_perk == PERK_weapon_long_range then begin
         distance_beyond_visibility = (attacker_pe - 3) * 4 + 3;
         if attacker_pe >= 5 then begin
            PERK_bonus_distance = (attacker_pe - 4) * 2;
            if distance < PERK_bonus_distance then begin
               hit_chance = hit_chance - 4 * (PERK_bonus_distance - 1 - distance);
            end
         end
         if distance > distance_beyond_visibility then begin
            hit_chance = hit_chance - 8 * (distance - distance_beyond_visibility);
         end
      end
      // penalty if attacker is blind for PERK_weapon_scope_range
      if weapon_perk == PERK_weapon_scope_range then begin
         if distance < 7 then begin
            hit_chance = hit_chance - 72 - 8 * (distance);
         end
         else begin
            if attacker_pe < 4 then begin
               hit_chance = hit_chance - 48 - 8 * (distance) + (attacker_pe - 1) * 40;
            end
            else begin
               distance_beyond_visibility = 9 + (attacker_pe - 4) * 5;
               if distance > distance_beyond_visibility then begin
                  hit_chance = hit_chance - 8 * (distance - distance_beyond_visibility);
               end
               if attacker_pe >= 7 then begin
                  PERK_bonus_distance = 7 + (attacker_pe - 6) * 3;
                  if distance < PERK_bonus_distance then begin
                     hit_chance = hit_chance - 4 * (PERK_bonus_distance - distance);
                  end
               end
            end
         end
      end
   end
   // penalty if attacker is blind end

   return hit_chance;
end

procedure lvar_full_reset begin
   lvar_cleared = 1;
   if array_exists(dmg_array) then free_array(dmg_array);
   if array_exists(crit_roll_array) then free_array(crit_roll_array);
   if array_exists(pre_targets_array) then free_array(pre_targets_array);
   if array_exists(targets_array) then free_array(targets_array);
   friendly_targets_count = 0;
   enemy_targets_count = 0;
   targets_count = 0;
   npc_orig_tar = 0;
   elec_tar_num = 0;
   attacker_frm = -1;
   alt_fire_used = 0;
   is_single_shot = 0;
   real_orig_target = 0;
   new_targets_count = 0;
   missed_targets_count = 0;
   multihex_targets_count = 0;
   missed_shot = 0;
   one_time_call = 0;
   dmg_array = 0;
   crit_roll_array = 0;
   pre_targets_array = 0;
   targets_array = 0;
   target_bodypart = -1;
   atk_rslt = -1;
   finesse = 0;
   kamikaze = 0;
   bloody_mess = 0;
   one_hander = 0;
   weapon_handling = 0;
   sharpshooter = 0;
   bonus_crit_power_roll = 0;
   bonus_ranged_damage = 0;
   living_anatomy = 0;
   night_vision = 0;
   sniper = 0;
   one_hander_bonus = 0;
   combat_dmg = 0;
   weapon = 0;
   weapon_pid = 0;
   weapon_flags = 0;
   weapon_ammo_pid = 0;
   weapon_damage_type = 0;
   weapon_range = 0;
   weapon_min_dmg = 0;
   weapon_max_dmg = 0;
   weapon_perk = 0;
   weapon_proj_pid = 0;
   weapon_cur_ammo = 0;
   //ammo_caliber = 0;
   ammo_mult = 0;
   ammo_div = 0;
   ammo_dr_mod = 0;
   ammo_ac_mod = 0;
   pistol_double_tap_activated = 0;
   pistol_double_tap_in_process = 0;
   pistol_double_tap_visual = 0;
   pistol_double_tap_taps = 0;
   pistol_double_tap_target_selected = 0;
   pistol_double_tap_target = -1;
   pistol_double_tap_weapon = 0;
end

procedure is_hit_from_front(variable attacker_tile,variable target) begin
   variable tar_rot = has_trait(TRAIT_OBJECT, target, OBJECT_CUR_ROT);
   variable rot_to_atk = rotation_to_tile(tile_num(target), attacker_tile);
   if tar_rot == rot_to_atk or (tar_rot + 1)%6 == rot_to_atk or (tar_rot + 5)%6 == rot_to_atk then begin
      return true;
   end
   else begin
      return false;
   end
end

//checking that there are no not_shot_through obstacles between objects
procedure check_block_shoot(variable obj_1,variable obj_2) begin
   variable tile_1 = tile_num(obj_1);
   variable tile_2 = tile_num(obj_2);
   variable blocking_obj_1_to_2;
   variable last_blocking_obj_1_to_2;
   variable blocking_obj_2_to_1;
   variable last_blocking_obj_2_to_1;
   variable max_count = 25;
   variable i;
   if obj_1 <= 0 or obj_2 <= 0 then begin
      return false;
   end
   else begin
      blocking_obj_1_to_2 = obj_blocking_line(obj_1, tile_2, BLOCKING_TYPE_SHOOT);
      blocking_obj_2_to_1 = obj_blocking_line(obj_2, tile_1, BLOCKING_TYPE_SHOOT);
      for (i = 0;i <= max_count; i++) begin
         if (blocking_obj_1_to_2 == obj_2 andAlso blocking_obj_2_to_1 == obj_1) or (blocking_obj_1_to_2 == blocking_obj_2_to_1 andALso ShootThru(blocking_obj_1_to_2)) then begin
            return true;
         end
         else begin
            last_blocking_obj_1_to_2 = blocking_obj_1_to_2;
            last_blocking_obj_2_to_1 = blocking_obj_2_to_1;
            if not(ShootThru(blocking_obj_1_to_2)) or not(ShootThru(blocking_obj_2_to_1)) then begin
               return false;
            end
            else begin
               blocking_obj_1_to_2 = obj_blocking_line(last_blocking_obj_1_to_2, tile_2, BLOCKING_TYPE_SHOOT);
               blocking_obj_2_to_1 = obj_blocking_line(last_blocking_obj_2_to_1, tile_1, BLOCKING_TYPE_SHOOT);
               if blocking_obj_1_to_2 == last_blocking_obj_1_to_2 andAlso blocking_obj_2_to_1 == last_blocking_obj_2_to_1 then begin
                  return false;
               end
            end
         end
      end
   end
   return false;
end

//so far without taking into account CRITTER_KILL_TYPE critical hit tables
procedure get_crit_mult(variable crit_power_roll,variable target) begin
   variable crit_mult = 1;
   variable target_kill_type = metarule(METARULE_CRITTER_KILL_TYPE, target);
   if crit_power_roll <= 0 then begin
      crit_mult = 1;
   end
   else if crit_power_roll <= 45 then begin
      crit_mult = 1.5;
   end
   else if crit_power_roll <= 90 then begin
      crit_mult = 2.0;
   end
   else if crit_power_roll > 90 then begin
      crit_mult = 3.0;
   end
   //if boss kill type
   if target_kill_type > 17 then begin
      if crit_mult >= 2 then crit_mult = 1.5;
   end
   return crit_mult;
end


procedure calc_dmg_electric(variable attacker, variable target) begin
   variable attacker_lu = get_critter_stat(attacker, STAT_lu);
   variable critical_chance = get_critter_stat(attacker, STAT_crit_chance);
   variable target_dt;
   variable target_dr;
   variable weapon_dmg = random(weapon_min_dmg, weapon_max_dmg);
   variable rnd = random(0, 100);
   variable crit_roll = rnd;
   variable crit_mult = 1;
   variable min_dmg = 1;
   variable hit_chance;
   variable miss_local;
   variable dmg;
   variable flags = 1;
   if ElecDmgMin >= ElecDmgMax then ElecDmgMin = ElecDmgMax;
   if weapon_damage_type == DMG_electrical then begin
      target_dt = get_critter_stat(target,STAT_dmg_thresh_electrical);
      target_dr = get_critter_stat(target,STAT_dmg_resist_electrical);
   end
   else begin
      target_dt = get_critter_stat(target,STAT_dmg_thresh_emp);
      target_dr = get_critter_stat(target,STAT_dmg_resist_emp);
   end
   //Increase target_dr if it attacker has TRAIT_finesse
   if finesse then begin
      target_dr = target_dr + 30;
   end
   if weapon_damage_type != DMG_emp then begin
      if weapon_perk == PERK_weapon_penetrate then begin
         target_dt = target_dt * 0.2;
         //target_dr = target_dr * 0.3;
      end
      // if YAAM ammo active
      if ammo_dr_mod > 0 then begin
         ammo_dr_mod = 0;
         target_dt = target_dt - ammo_dr_mod;
         if target_dt < ammo_dr_mod then begin
            target_dr = target_dr + (10 * (target_dt - ammo_dr_mod) / 100.0);
         end
      end
   end
   // hit chance calculation start
   if ElecHitChance > 0 then begin
      if is_critter(target) then hit_chance = get_ranged_chance_to_hit(attacker, target);
       // +15% bonus hit chance. 5% guaranteed chance to hit
      hit_chance = hit_chance + 15;
      if rnd > 4 andAlso rnd > hit_chance or rnd > 95 then miss_local = 1;
   end
   else begin
      miss_local = 0;
   end
   //if (target == orig_target andAlso missed_shot) then miss = 1;

   //if miss
   //if miss then begin
      //dmg = -1;
      //return dmg;
   //end
   //if hit
   //else begin
      crit_power_roll = 0;
      //PERK_sniper crit chance bonus
      if allow_critical > 0 andAlso(crit_roll <= critical_chance or (sniper andAlso random(1,10) <= attacker_lu)) then begin
         crit_power_roll = random(1, (100 + bonus_crit_power_roll));
         crit_mult = get_crit_mult(crit_power_roll,target);

         //crit dmg reduction
         //if crit_mult > 2 then crit_mult = 2;
         flags = 1 bwor DAM_CRITICAL;
         if weapon_damage_type != DMG_emp then begin
            if crit_mult < 2 then begin
               target_dt = target_dt * 0.8;
               target_dr = target_dr * 0.8;
            end
            else begin
               if not(random(0,2)) then begin
                  flags = flags bwor DAM_KNOCKED_DOWN;
               end
               target_dt = target_dt * 0.2;
               target_dr = target_dr * 0.2;
            end
         end
      end
      if target_dt < 0 then target_dt = 0;
      if target_dr > 90 andAlso weapon_damage_type != DMG_emp then target_dr = 90;
      if target_dr < 0 then target_dr = 0;
      dmg = round(((weapon_dmg - target_dt) * (100 - target_dr) / 100.0) * crit_mult) + living_anatomy_bonus * living_anatomy;
      flags = flags * DAM_FLAGS_MULT;
      if dmg < min_dmg then begin
         return 0;
      end
      if miss_local > 0 then begin
         dmg = round(random((ElecDmgMin / 2), ElecDmgMin) * dmg / 100.0);
         return (dmg + flags);
      end
      else begin
         dmg = round(random(ElecDmgMin, ElecDmgMax) * dmg / 100.0);
         return (dmg + flags);
      end

   //end
end

procedure calc_dmg_laser(variable attacker, variable target) begin
   variable attacker_lu = get_critter_stat(attacker, STAT_lu);
   variable attacker_team = has_trait(TRAIT_OBJECT, attacker, OBJECT_TEAM_NUM);
   variable critical_chance = get_critter_stat(attacker, STAT_crit_chance);
   variable target_dt = get_critter_stat(target,STAT_dmg_thresh_laser);
   variable target_dr = get_critter_stat(target,STAT_dmg_resist_laser);
   variable target_team = has_trait(TRAIT_OBJECT, target, OBJECT_TEAM_NUM);
   variable weapon_dmg = random(weapon_min_dmg, weapon_max_dmg);
   variable rnd = random(0, 100);
   variable crit_roll = rnd;
   variable crit_mult = 1;
   variable min_dmg = 1;
   variable hit_chance;
   variable miss_local;
   variable dmg;
   if is_critter(target) then last_target_on_a_line = target;
   if is_multihex(target) then multihex_targets_count += 1;
   //Increase target_dr if it attacker has TRAIT_finesse
   if finesse then begin
      target_dr = target_dr + 30;
   end
   // if YAAM ammo active
   if ammo_dr_mod > 0 then begin
      ammo_dr_mod = 0;
      target_dt = target_dt - ammo_dr_mod;
      if target_dt < ammo_dr_mod then begin
         target_dr = target_dr + (10 * (target_dt - ammo_dr_mod) / 100.0);
      end
   end
   //guaranteed increase in laser armor-piercing when using an alternative firing mode
   if weapon_perk == PERK_weapon_penetrate then begin
      target_dt = target_dt * 0.2;
      target_dr = target_dr * 0.5 + ammo_dr_mod;
   end
   else begin
      if target_team != TEAM_PLAYER then begin
         target_dt = target_dt * 0.6;
         target_dr = target_dr * 0.6 + ammo_dr_mod;
      end
      else begin
         target_dt = target_dt * 0.8;
         target_dr = target_dr * 0.8 + ammo_dr_mod;
      end
   end
   // hit chance calculation start
   if LaserHitChance > 0 then begin
      if is_critter(target) then hit_chance = get_ranged_chance_to_hit(attacker, target);
      hit_chance = hit_chance + 15;
      if attacker_team == target_team then hit_chance = 95 - hit_chance;
       // +15% bonus hit chance. 5% guaranteed chance to hit

      if hit_chance < 0 or (rnd > 4 andAlso rnd > hit_chance) or rnd > 95 then begin
         miss_local = 1;
      end
   end
   else begin
      miss_local = 0;
   end
   if (target == orig_target andAlso missed_shot) then miss_local = 1;

   //if miss
   if miss_local then begin
      crit_power_roll = -1;
      missed_targets_count += 1;
      dmg = weapon_dmg;
      return dmg;
   end
   //if hit
   else begin
      crit_power_roll = 0;
      //PERK_sniper crit chance bonus
      if allow_critical > 0 andAlso(crit_roll <= critical_chance or (sniper andAlso random(1,10) <= attacker_lu)) then begin
         crit_power_roll = random(1, (100 + bonus_crit_power_roll));
         crit_mult = get_crit_mult(crit_power_roll,target);
         if crit_mult < 2 then begin
            target_dt = target_dt * 0.8;
            target_dr = target_dr * 0.8;
         end
         else begin
            target_dt = target_dt * 0.2;
            target_dr = target_dr * 0.2;
         end
      end
      if target_dt < 0 then target_dt = 0;
      if target_dr > 90 then target_dr = 90;
      if target_dr < 0 then target_dr = 0;
      dmg = round(((weapon_dmg - target_dt) * (100 - target_dr) / 100.0));
      if dmg < min_dmg then dmg = 0;
      dmg = dmg + living_anatomy_bonus * living_anatomy;
      if atk_rslt == MISS then begin
         new_main_target = target;
      end
      if new_main_target or target == orig_target then begin
         new_dmg_to_orig_target = round(dmg * crit_mult);
      end
      return dmg;
   end
end

procedure calc_dmg_gauss(variable attacker, variable target, variable weapon_dmg) begin
   variable attacker_lu = get_critter_stat(attacker, STAT_lu);
   variable critical_chance = get_critter_stat(attacker, STAT_crit_chance);
   variable target_dt = get_critter_stat(target,STAT_dmg_thresh);
   variable target_dr = get_critter_stat(target,STAT_dmg_resist);
   variable target_kill_type = metarule(METARULE_CRITTER_KILL_TYPE, target);
   variable rnd = random(0, 100);
   variable crit_roll = rnd;
   variable crit_mult = 1;
   variable min_dmg = 1;
   variable min_reduced_dmg;
   variable hit_chance;
   variable miss_local;
   variable dmg;
   //Increase target_dr if it attacker has TRAIT_finesse
   if finesse then begin
      target_dr = target_dr + 30;
   end
   if weapon_perk == PERK_weapon_penetrate or Sonora > 0 then begin
      target_dt = target_dt * 0.2;
      target_dr = target_dr * 0.7;
   end
   if is_critter(target) then last_target_on_a_line = target;
   if is_multihex(target) then multihex_targets_count += 1;
   // if YAAM ammo active
   if ammo_dr_mod > 0 then begin
      ammo_dr_mod = 0;
      target_dt = target_dt - ammo_dr_mod;
      if target_dt < ammo_dr_mod then begin
         target_dr = target_dr + (10 * (target_dt - ammo_dr_mod) / 100.0);
      end
   end

   if new_targets_count < 3 andAlso has_trait(TRAIT_OBJECT, target, OBJECT_TEAM_NUM) != TEAM_PLAYER then target_dt = target_dt * 0.8 - 2;
   target_dr = target_dr + ammo_dr_mod;

   // hit chance calculation
   if GaussHitChance > 0 then begin
      if is_critter(target) then hit_chance = get_ranged_chance_to_hit(attacker, target);
      // +15% bonus hit chance. 5% guaranteed chance to hit
      hit_chance = hit_chance + 15;
      if rnd > 4 andAlso (rnd > hit_chance or rnd > 95) then miss_local = 1;
   end
   else begin
      miss_local = 0;
   end
   if (target == orig_target andAlso missed_shot) then miss_local = 1;

   //if miss
   if miss_local > 0 then begin
      missed_targets_count += 1;
      crit_power_roll = -1;
      dmg = weapon_dmg;
      last_dmg = dmg;
      //last_missed_target = target;
      return dmg;
   end
   //if hit
   else begin
      crit_power_roll = 0;
      if allow_critical > 0 andAlso(crit_roll <= critical_chance or (sniper andAlso random(1,10) <= attacker_lu)) then begin
         crit_power_roll = random(1, (100 + bonus_crit_power_roll));
         crit_mult = get_crit_mult(crit_power_roll,target);
         if crit_mult < 2 then begin
            target_dt = target_dt * 0.8;
            target_dr = target_dr * 0.8;
         end
         else begin
            target_dt = target_dt * 0.2;
            target_dr = target_dr * 0.2;
         end
      end
      if target_dt < 0 then target_dt = 0;
      if target_dr > 90 then target_dr = 90;
      if target_dr < 0 then target_dr = 0;
      if Sonora > 0 andAlso weapon_dmg < 30 then weapon_dmg += random(5, 10);
      dmg = round((((weapon_dmg * 1.11) - target_dt) * (100 + random(0,10) - target_dr) / 100.0));
      if new_targets_count > 1 then begin
         min_reduced_dmg = round((last_dmg - GaussDamageReductionPerTarget * last_dmg * (new_targets_count - missed_targets_count)));
         //reduce damage by 0.5% per each tile in distance
         //distance_dmg_penalty = ((100 - distance / 2) / 100.0);
         //min_reduced_dmg = min_reduced_dmg * distance_dmg_penalty;
         if dmg > min_reduced_dmg then dmg = random(min_reduced_dmg,dmg);
      end
      if dmg < min_dmg then dmg = 0;
      last_dmg = dmg;
      if new_targets_count == 1 then dmg = dmg + living_anatomy_bonus * living_anatomy;
      if new_main_target or target == orig_target then begin
         new_dmg_to_orig_target = round(dmg * crit_mult);
      end
      return dmg;
   end
end

procedure re_count(variable counter) begin
   variable counter_floor = floor(counter);
   if (floor(remainder + counter) > counter_floor) then begin
      remainder = remainder + counter - floor(remainder + counter);
      return floor(counter + 1);
   end
   else begin
      remainder = remainder + (counter - counter_floor);
      return counter_floor;
   end
end

//get targets on thin line using draw_line algorithm from taget to attacker
//(only includes targets that are located on tiles in both directions)
procedure get_targets_on_thin_line_gauss_reversed(variable first_tile,variable last_tile, variable attacker) begin
   variable line_elevation = elevation(attacker);
   variable line_length = tile_distance(first_tile, last_tile);
   variable temp_rot = rotation_to_tile(first_tile, last_tile);
   variable temp_dist = tile_distance(first_tile, last_tile);
   variable temp_tile_in_dir = tile_num_in_direction(first_tile, temp_rot, temp_dist);
   variable temp_dist_in_dir = tile_distance(temp_tile_in_dir, last_tile);
   variable temp_rot_in_dir = rotation_to_tile(temp_tile_in_dir, last_tile);
   variable atk_cur_rot = (rotation_to_tile(first_tile, last_tile) + 3) % 6;
   variable check_tile = first_tile;
   variable weapon_dmg = random(weapon_min_dmg, weapon_max_dmg);
   variable local_dmg_array = create_array(50,0);
   variable local_crit_roll_array = create_array(50,0);
   variable modified;
   variable blocking_obj;
   variable side;
   variable tile_count;
   variable counter;
   variable new_target;
   variable new_tar_team;
   variable distance;
   variable dmg;
   variable attacker_team = has_trait(TRAIT_OBJECT, attacker, OBJECT_TEAM_NUM);
   new_targets_count = 0;
   missed_targets_count = 0;
   multihex_targets_count = 0;
   if modified == 0 andAlso temp_rot_in_dir == 0 andAlso atk_cur_rot == 4 andAlso rotation_to_tile(last_tile , first_tile) == 1 andAlso temp_rot == 4 then begin
      modified = 1;
      temp_rot =  (temp_rot + 1)%6;
   end
   if modified == 0 andAlso temp_rot_in_dir == 3 andAlso atk_cur_rot == 1 andAlso rotation_to_tile(last_tile , first_tile) == 4 andAlso temp_rot == 1 then begin
      modified = 1;
      temp_rot =  (temp_rot + 1)%6;
   end
   if modified == 0 andAlso temp_rot_in_dir == 3 andAlso atk_cur_rot == 4 andAlso rotation_to_tile(last_tile , first_tile) == 4 andAlso temp_rot == 1 then begin
      modified = 1;
      temp_rot =  (temp_rot + 1)%6;
   end
   if modified == 0 andAlso temp_rot_in_dir == 5 andAlso atk_cur_rot == 1 andAlso rotation_to_tile(last_tile , first_tile) == 4 andAlso temp_rot == 1 then begin
      modified = 1;
      temp_rot =  (temp_rot + 5)%6;
   end
   if modified == 0 andAlso temp_rot_in_dir == 5 andAlso atk_cur_rot == 4 andAlso rotation_to_tile(last_tile , first_tile) == 4 andAlso temp_rot == 1 then begin
      modified = 1;
      temp_rot =  (temp_rot + 5)%6;
   end
   if modified == 0 andAlso temp_rot_in_dir == 2 andAlso atk_cur_rot == 4 andAlso rotation_to_tile(last_tile , first_tile) == 1 andAlso temp_rot == 4 then begin
      modified = 1;
      temp_rot =  (temp_rot + 5)%6;
   end
   //if modified == 0 andAlso temp_rot_in_dir == 2 andAlso atk_cur_rot == 1 andAlso rotation_to_tile(last_tile , first_tile) == 1 andAlso temp_rot == 4 then begin
      //modified = 1;
      //temp_rot =  (temp_rot + 5)%6;
   //end
   temp_tile_in_dir = tile_num_in_direction(first_tile, temp_rot, temp_dist);
   temp_dist_in_dir = tile_distance(temp_tile_in_dir, last_tile);
   temp_rot_in_dir = rotation_to_tile(temp_tile_in_dir, last_tile);
   targets_array = create_array(50, 0);
   remainder = 0;
   if temp_dist_in_dir == 0 then begin
      side = temp_dist_in_dir;
   end
   else begin
      if temp_rot_in_dir == (temp_rot + 2) % 6 then begin
         side = 1;
      end
      else begin
         if temp_rot_in_dir == (temp_rot + 4) % 6 then begin
            side = 5;
         end
      end
   end
   if (side != 0) then begin
      counter = (temp_dist * 1.0) / temp_dist_in_dir / 2.0;
   end
   else begin
      counter = 100.0;
   end
   while (tile_count < line_length) do begin
      tile_count += 1;
      if (counter >= 1.0) then begin
         check_tile = tile_num_in_direction(check_tile, temp_rot, 1);
         counter = counter - 1.0;
      end
      else begin
         check_tile = tile_num_in_direction(check_tile, ((temp_rot + side) % 6), 1);
         counter = ((temp_dist * 1.0) / temp_dist_in_dir) + re_count(counter) - 1.0;
      end
      //create_object_sid(33555753, check_tile, elevation(dude_obj), -1); // create small blood spot on each tile on a line
      blocking_obj = obj_blocking_tile(check_tile, line_elevation, BLOCKING_TYPE_BLOCK);
      if blocking_obj andAlso obj_type(blocking_obj) == OBJ_TYPE_CRITTER then new_target = blocking_obj;
      if new_target then begin
         if (is_in_array(new_target,pre_targets_array) or tile_count == line_length) then begin
            distance_objs(distance, attacker, new_target);
            set_array(targets_array,distance, new_target);
         end
      end
   end
   new_target = 0;
   tile_count = 0;
   foreach new_target in targets_array begin
      if new_target then begin
         new_tar_team = has_trait(TRAIT_OBJECT, new_target, OBJECT_TEAM_NUM);
         if new_tar_team == enemy_team then begin
            enemy_targets_count += 1;
         end
         else if attacker_team == new_tar_team then begin
            friendly_targets_count += 1;
         end
         new_targets_count += 1;
         dmg = calc_dmg_gauss(attacker , new_target, weapon_dmg);
         weapon_dmg = dmg;
         set_array(local_dmg_array, (new_targets_count - 1), dmg);
         set_array(local_crit_roll_array, (new_targets_count - 1), crit_power_roll);
         new_dmg_to_orig_target = dmg;
         new_main_target = last_target_on_a_line;
         //set new main_target if the damage is not enough to penetrate all targets
         if dmg == 0 then begin
            new_main_target = new_target;
            break;
         end
      end
   end
   dmg_array = local_dmg_array;
   crit_roll_array = local_crit_roll_array;
end

//get targets on a thin line using the draw_line algorithm from the attacker(through the target) to a tile at a distance of 50 from the attacker
procedure get_targets_on_thin_line_gauss(variable attacker ,variable target, variable line_length) begin
   //variable line_length = 50;
   variable line_elevation = elevation(attacker);
   variable first_tile = tile_num(attacker);
   variable second_tile = tile_num(target);
   variable projectile_start_tile = tile_num_in_direction(first_tile, rotation_to_tile(first_tile, second_tile), 1);
   variable temp_rot = rotation_to_tile(projectile_start_tile, second_tile);
   variable rot_tar_to_atk = rotation_to_tile(second_tile , projectile_start_tile);
   variable atk_tile = projectile_start_tile;
   variable temp_dist = tile_distance(projectile_start_tile, second_tile);
   variable temp_tile_in_dir = tile_num_in_direction(atk_tile, temp_rot, temp_dist);
   variable temp_dist_in_dir = tile_distance(temp_tile_in_dir, second_tile);
   variable temp_rot_in_dir = rotation_to_tile(temp_tile_in_dir, second_tile);
   variable atk_cur_rot = rotation_to_tile(first_tile, second_tile);
   variable check_tile = atk_tile;
   variable side;
   variable tile_count;
   variable counter;
   variable new_target;
   variable tar_cur_frm;
   variable tar_cur_hp;
   variable tile_blocking_obj;
   variable blocking_obj;
   variable is_behind_target;
   variable modified;
   pre_targets_array = create_array(line_length+1,0);
   //if modified == 0 andAlso temp_rot_in_dir == 0 andAlso atk_cur_rot == 4 andAlso rotation_to_tile(tar_tile , projectile_start_tile) == 1 andAlso temp_rot == 4 then begin
      //modified = 1;
      //temp_rot =  (temp_rot + 1)%6;
      //temp_tile_in_dir = tile_num_in_direction(atk_tile, (temp_rot), temp_dist);
      //temp_dist_in_dir = tile_distance(temp_tile_in_dir, tar_tile);
      //temp_rot_in_dir = rotation_to_tile(temp_tile_in_dir, tar_tile);
   //end
   if modified == 0 andAlso temp_rot_in_dir == 4 andAlso atk_cur_rot == 5 andAlso rot_tar_to_atk == 2 andAlso temp_rot == 0 then begin
      modified = 1;
      temp_rot =  (temp_rot + 5)%6;
      temp_tile_in_dir = tile_num_in_direction(atk_tile, (temp_rot), temp_dist);
      temp_dist_in_dir = tile_distance(temp_tile_in_dir, second_tile);
      temp_rot_in_dir = rotation_to_tile(temp_tile_in_dir, second_tile);
   end
   if modified == 0 andAlso temp_rot_in_dir == 5 andAlso atk_cur_rot == 1 andAlso rot_tar_to_atk == 4 andAlso temp_rot == 1 then begin
      modified = 1;
      temp_rot =  (temp_rot + 5)%6;
      temp_tile_in_dir = tile_num_in_direction(atk_tile, (temp_rot), temp_dist);
      temp_dist_in_dir = tile_distance(temp_tile_in_dir, second_tile);
      temp_rot_in_dir = rotation_to_tile(temp_tile_in_dir, second_tile);
   end
   if modified == 0 andAlso temp_rot_in_dir == 4 andAlso atk_cur_rot == 0 andAlso rot_tar_to_atk == 2 andAlso temp_rot == 0 then begin
      modified = 1;
      temp_rot =  (temp_rot + 5)%6;
      temp_tile_in_dir = tile_num_in_direction(atk_tile, (temp_rot), temp_dist);
      temp_dist_in_dir = tile_distance(temp_tile_in_dir, second_tile);
      temp_rot_in_dir = rotation_to_tile(temp_tile_in_dir, second_tile);
   end
   if modified == 0 andAlso temp_rot_in_dir == 4 andAlso atk_cur_rot == 2 andAlso rot_tar_to_atk == 0 andAlso temp_rot == 2 then begin
      modified = 1;
      temp_rot =  (temp_rot + 1)%6;
      temp_tile_in_dir = tile_num_in_direction(atk_tile, (temp_rot), temp_dist);
      temp_dist_in_dir = tile_distance(temp_tile_in_dir, second_tile);
      temp_rot_in_dir = rotation_to_tile(temp_tile_in_dir, second_tile);
   end
   if modified == 0 andAlso temp_rot_in_dir == 4 andAlso atk_cur_rot == 3 andAlso rot_tar_to_atk == 0 andAlso temp_rot == 2 then begin
      modified = 1;
      temp_rot =  (temp_rot + 1)%6;
      temp_tile_in_dir = tile_num_in_direction(atk_tile, (temp_rot), temp_dist);
      temp_dist_in_dir = tile_distance(temp_tile_in_dir, second_tile);
      temp_rot_in_dir = rotation_to_tile(temp_tile_in_dir, second_tile);
   end
   //if modified == 0 andAlso temp_rot_in_dir == 2 andAlso atk_cur_rot == 4 andAlso rotation_to_tile(second_tile , projectile_start_tile) == 1 andAlso temp_rot == 4 then begin
      //modified = 1;
      //temp_rot =  (temp_rot + 5)%6;
      //temp_tile_in_dir = tile_num_in_direction(atk_tile, (temp_rot), temp_dist);
      //temp_dist_in_dir = tile_distance(temp_tile_in_dir, second_tile);
      //temp_rot_in_dir = rotation_to_tile(temp_tile_in_dir, second_tile);
   //end
   if modified == 0 andAlso temp_rot_in_dir == 3 andAlso atk_cur_rot == 1 andAlso rotation_to_tile(second_tile , projectile_start_tile) == 4 andAlso temp_rot == 1 then begin
      modified = 1;
      temp_rot =  (temp_rot + 1)%6;
      temp_tile_in_dir = tile_num_in_direction(atk_tile, (temp_rot), temp_dist);
      temp_dist_in_dir = tile_distance(temp_tile_in_dir, second_tile);
      temp_rot_in_dir = rotation_to_tile(temp_tile_in_dir, second_tile);
   end
   if modified == 0 andAlso temp_rot_in_dir == 1 andAlso atk_cur_rot == 2 andAlso rot_tar_to_atk == 0 andAlso temp_rot == 3 then begin
      modified = 1;
      projectile_start_tile = first_tile;
      atk_tile = projectile_start_tile;
      check_tile = atk_tile;
      //temp_rot = rotation_to_tile(projectile_start_tile, second_tile) + 1;
      temp_dist = tile_distance(projectile_start_tile, second_tile);
      temp_tile_in_dir = tile_num_in_direction(atk_tile, temp_rot, temp_dist);
      temp_dist_in_dir = tile_distance(temp_tile_in_dir, second_tile);
      temp_rot_in_dir = rotation_to_tile(temp_tile_in_dir, second_tile);
   end
   //atkr straight under tar
   if modified == 0 andAlso temp_rot_in_dir == 1 andAlso atk_cur_rot == 0 andAlso rot_tar_to_atk == 2 andAlso temp_rot == 5 then begin
      modified = 1;
      projectile_start_tile = first_tile;
      atk_tile = projectile_start_tile;
      check_tile = atk_tile;
      //temp_rot = rotation_to_tile(projectile_start_tile, second_tile) + 1;
      temp_dist = tile_distance(projectile_start_tile, second_tile);
      temp_tile_in_dir = tile_num_in_direction(atk_tile, temp_rot, temp_dist);
      temp_dist_in_dir = tile_distance(temp_tile_in_dir, second_tile);
      temp_rot_in_dir = rotation_to_tile(temp_tile_in_dir, second_tile);
   end
   if modified == 0 andAlso temp_dist == 1 andAlso tile_distance(first_tile, second_tile) == 2 then begin
      modified = 1;
      projectile_start_tile = first_tile;
      atk_tile = projectile_start_tile;
      check_tile = atk_tile;
      temp_rot = rotation_to_tile( projectile_start_tile, second_tile);
      temp_dist = tile_distance(projectile_start_tile, second_tile);
      temp_tile_in_dir = tile_num_in_direction(atk_tile, temp_rot, temp_dist);
      temp_dist_in_dir = tile_distance(temp_tile_in_dir, second_tile);
      temp_rot_in_dir = rotation_to_tile(temp_tile_in_dir, second_tile);
      if modified < 2 andAlso temp_rot_in_dir == 4 andAlso atk_cur_rot == 0 andAlso rotation_to_tile(second_tile , projectile_start_tile) == 2 andAlso temp_rot == 0 then begin
         modified = 2;
         temp_rot =  (temp_rot + 5)%6;
         temp_tile_in_dir = tile_num_in_direction(atk_tile, (temp_rot), temp_dist);
         temp_dist_in_dir = tile_distance(temp_tile_in_dir, second_tile);
         temp_rot_in_dir = rotation_to_tile(temp_tile_in_dir, second_tile);
      end
      if modified < 2 andAlso temp_rot_in_dir == 4 andAlso atk_cur_rot == 2 andAlso rotation_to_tile(second_tile , projectile_start_tile) == 0 andAlso temp_rot == 2 then begin
         modified = 2;
         temp_rot =  (temp_rot + 1)%6;
         temp_tile_in_dir = tile_num_in_direction(atk_tile, (temp_rot), temp_dist);
         temp_dist_in_dir = tile_distance(temp_tile_in_dir, second_tile);
         temp_rot_in_dir = rotation_to_tile(temp_tile_in_dir, second_tile);
      end
   end
   // point blank range
   if modified == 0 andAlso tile_distance(first_tile, second_tile) == 1 then begin
      modified = 1;
      projectile_start_tile = first_tile;
      atk_tile = projectile_start_tile;
      check_tile = atk_tile;
      temp_rot = rotation_to_tile( projectile_start_tile, second_tile);
      temp_dist = tile_distance(projectile_start_tile, second_tile);
      temp_tile_in_dir = tile_num_in_direction(atk_tile, temp_rot, temp_dist);
      temp_dist_in_dir = tile_distance(temp_tile_in_dir, second_tile);
      temp_rot_in_dir = rotation_to_tile(temp_tile_in_dir, second_tile);
   end
   remainder = 0;
   if temp_dist_in_dir == 0 then begin
      side = temp_dist_in_dir;
   end
   else begin
      if temp_rot_in_dir == (temp_rot + 2) % 6 then begin
         side = 1;
      end
      else begin
         if temp_rot_in_dir == (temp_rot + 4) % 6 then begin
            side = 5;
         end
      end
   end
   if (side != 0) then begin
      counter = (temp_dist * 1.0) / temp_dist_in_dir / 2.0;
   end
   else begin
      counter = 100.0;
   end
   while (tile_count < line_length) do begin
      tile_count += 1;
      if (counter >= 1.0) then begin
         check_tile = tile_num_in_direction(check_tile, temp_rot, 1);
         counter = counter - 1.0;
      end
      else begin
         check_tile = tile_num_in_direction(check_tile, (temp_rot + side) % 6, 1);
         counter = ((temp_dist * 1.0) / temp_dist_in_dir) + re_count(counter) - 1.0;
      end
      //create_object_sid(205, check_tile, elevation(dude_obj), -1);// create active flare on each tile on a line
      tile_blocking_obj = obj_blocking_tile(check_tile, line_elevation, BLOCKING_TYPE_BLOCK);
      if tile_blocking_obj andAlso obj_type(tile_blocking_obj) == OBJ_TYPE_CRITTER then new_target = tile_blocking_obj;

      //skip knocked targets? better not :)
      //tar_cur_frm = get_object_data(new_target, OBJ_DATA_CUR_FRM);
      if new_target then begin
         tar_cur_hp = get_critter_stat(new_target, STAT_current_hp);
         if tar_cur_frm == 0 andAlso tar_cur_hp > 0 andAlso obj_is_visible_flag(new_target) andAlso not(is_in_array(new_target,pre_targets_array)) then begin
            set_array(pre_targets_array, tile_count, new_target);
         end
      end
      // break cycle if tile contain blocking obj
      if check_tile == second_tile then is_behind_target = 1;
      if is_behind_target then begin
         blocking_obj = obj_blocking_tile(check_tile, line_elevation, BLOCKING_TYPE_SHOOT);
         if (blocking_obj andAlso not(ShootThru(blocking_obj))) or (tile_count == line_length) then begin
            break;
         end
      end
   end
   call get_targets_on_thin_line_gauss_reversed(check_tile, projectile_start_tile, attacker);
end

//get targets on thin line using draw_line algorithm from taget to attacker
//(only includes targets that are located on tiles in both directions)
procedure get_targets_on_thin_line_laser_reversed(variable first_tile,variable last_tile, variable attacker) begin
   variable line_elevation = elevation(attacker);
   variable line_length = tile_distance(first_tile, last_tile);
   variable temp_rot = rotation_to_tile( first_tile, last_tile);
   variable temp_dist = tile_distance(first_tile, last_tile);
   variable temp_tile_in_dir = tile_num_in_direction(first_tile, temp_rot, temp_dist);
   variable temp_dist_in_dir = tile_distance(temp_tile_in_dir, last_tile);
   variable temp_rot_in_dir = rotation_to_tile(temp_tile_in_dir, last_tile);
   variable atk_cur_rot = (rotation_to_tile(first_tile, last_tile) + 3) % 6;
   variable local_targets_array = create_array(50, 0);
   variable local_dmg_array = create_array(50,0);
   variable local_crit_roll_array = create_array(50,0);
   variable new_target_team;
   variable check_tile = first_tile;
   variable blocking_obj;
   variable side;
   variable tile_count;
   variable counter;
   variable new_target;
   variable modified;
   variable distance;
   variable dmg;
   variable new_tar_team;
   variable attacker_team = has_trait(TRAIT_OBJECT, attacker, OBJECT_TEAM_NUM);
   if modified == 0 andAlso temp_rot_in_dir == 0 andAlso atk_cur_rot == 4 andAlso rotation_to_tile(last_tile , first_tile) == 1 andAlso temp_rot == 4 then begin
      modified = 1;
      temp_rot =  (temp_rot + 1)%6;
   end
   if modified == 0 andAlso temp_rot_in_dir == 3 andAlso atk_cur_rot == 1 andAlso rotation_to_tile(last_tile , first_tile) == 4 andAlso temp_rot == 1 then begin
      modified = 1;
      temp_rot =  (temp_rot + 1)%6;
   end
   if modified == 0 andAlso temp_rot_in_dir == 3 andAlso atk_cur_rot == 4 andAlso rotation_to_tile(last_tile , first_tile) == 4 andAlso temp_rot == 1 then begin
      modified = 1;
      temp_rot =  (temp_rot + 1)%6;
   end
   if modified == 0 andAlso temp_rot_in_dir == 5 andAlso atk_cur_rot == 1 andAlso rotation_to_tile(last_tile , first_tile) == 4 andAlso temp_rot == 1 then begin
      modified = 1;
      temp_rot =  (temp_rot + 5)%6;
   end
   if modified == 0 andAlso temp_rot_in_dir == 5 andAlso atk_cur_rot == 4 andAlso rotation_to_tile(last_tile , first_tile) == 4 andAlso temp_rot == 1 then begin
      modified = 1;
      temp_rot =  (temp_rot + 5)%6;
   end
   if modified == 0 andAlso temp_rot_in_dir == 2 andAlso atk_cur_rot == 4 andAlso rotation_to_tile(last_tile , first_tile) == 1 andAlso temp_rot == 4 then begin
      modified = 1;
      temp_rot =  (temp_rot + 5)%6;
   end
   //if modified == 0 andAlso temp_rot_in_dir == 2 andAlso atk_cur_rot == 1 andAlso rotation_to_tile(last_tile , first_tile) == 1 andAlso temp_rot == 4 then begin
      //modified = 1;
      //temp_rot =  (temp_rot + 5)%6;
   //end
   temp_tile_in_dir = tile_num_in_direction(first_tile, temp_rot, temp_dist);
   temp_dist_in_dir = tile_distance(temp_tile_in_dir, last_tile);
   temp_rot_in_dir = rotation_to_tile(temp_tile_in_dir, last_tile);
   blocking_obj = obj_blocking_tile(check_tile, line_elevation, BLOCKING_TYPE_BLOCK);
   if blocking_obj andAlso obj_type(blocking_obj) == OBJ_TYPE_CRITTER then new_target = blocking_obj;
   if new_target then begin
      if (is_in_array(new_target,pre_targets_array) or tile_count == line_length) then begin
         distance_objs(distance, attacker, new_target);
         set_array(local_targets_array,distance, new_target);
      end
   end
   remainder = 0;
   if temp_dist_in_dir == 0 then begin
      side = temp_dist_in_dir;
   end
   else begin
      if temp_rot_in_dir == (temp_rot + 2) % 6 then begin
         side = 1;
      end
      else begin
         if temp_rot_in_dir == (temp_rot + 4) % 6 then begin
            side = 5;
         end
      end
   end
   if (side != 0) then begin
      counter = (temp_dist * 1.0) / temp_dist_in_dir / 2.0;
   end
   else begin
      counter = 100.0;
   end
   while (tile_count < line_length) do begin
      tile_count += 1;
      if (counter >= 1.0) then begin
         check_tile = tile_num_in_direction(check_tile, temp_rot, 1);
         counter = counter - 1.0;
      end
      else begin
         check_tile = tile_num_in_direction(check_tile, ((temp_rot + side) % 6), 1);
         counter = ((temp_dist * 1.0) / temp_dist_in_dir) + re_count(counter) - 1.0;
      end
      //create_object_sid(33555753, check_tile, elevation(dude_obj), -1); // create small blood spot on each tile on a line
      blocking_obj = obj_blocking_tile(check_tile, line_elevation, BLOCKING_TYPE_BLOCK);
      if blocking_obj andAlso obj_type(blocking_obj) == OBJ_TYPE_CRITTER then new_target = blocking_obj;

      if (is_in_array(new_target,pre_targets_array) or tile_count == line_length) then begin
         distance_objs(distance, attacker, new_target);
         set_array(local_targets_array,distance, new_target);
      end
   end
   new_target = 0;
   tile_count = 0;
   new_targets_count = 0;
   missed_targets_count = 0;
   multihex_targets_count = 0;
   targets_array = create_array(len_array(local_targets_array),0);
   if orig_target > 0 andAlso not(is_in_array(orig_target,local_targets_array)) then begin
      distance_objs(distance, attacker, orig_target);
      set_array(local_targets_array,distance,orig_target);
   end

   foreach new_target in local_targets_array begin
      if new_target andAlso new_target != attacker then begin


         new_targets_count += 1;
         if obj_type(new_target) == OBJ_TYPE_CRITTER then begin
            new_tar_team = has_trait(TRAIT_OBJECT, new_target, OBJECT_TEAM_NUM);
            if new_tar_team == enemy_team then begin
               enemy_targets_count += 1;
            end
            else if attacker_team == new_tar_team then begin
               friendly_targets_count += 1;
            end


            dmg = calc_dmg_laser(attacker, new_target);
            set_array(local_dmg_array, (new_targets_count - 1), dmg);
            set_array(local_crit_roll_array, (new_targets_count - 1), crit_power_roll);
            set_array(targets_array, (new_targets_count - 1), new_target);
            //terminate procedure if reached original target
            if new_target == orig_target then begin
               new_main_target = new_target;
               dmg_array = local_dmg_array;
               crit_roll_array = local_crit_roll_array;
               new_dmg_to_orig_target = dmg;
               local_dmg_array = 0;
               local_crit_roll_array = 0;
               pre_targets_array = 0;
               return;
            end
         end
         else begin
            //terminate procedure if reached original target
            if new_target == orig_target then begin
               dmg = 0;
               crit_power_roll = 1;
               set_array(local_dmg_array, (new_targets_count - 1), dmg);
               set_array(local_crit_roll_array, (new_targets_count - 1), crit_power_roll);
               set_array(targets_array, (new_targets_count - 1), new_target);
               new_main_target = new_target;
               dmg_array = local_dmg_array;
               crit_roll_array = local_crit_roll_array;
               new_dmg_to_orig_target = dmg;
               local_dmg_array = 0;
               local_crit_roll_array = 0;
               pre_targets_array = 0;
               return;
            end
         end

         //terminate procedure if there are not enough ammo to penetrate additional targets
         if LaserForced <= 0 andAlso (new_targets_count - missed_targets_count) == laser_curr_ammo - base_alt_ammo_cost then begin
            new_main_target = new_target;
            dmg_array = local_dmg_array;
            crit_roll_array = local_crit_roll_array;
            new_dmg_to_orig_target = dmg;
            local_dmg_array = 0;
            local_crit_roll_array = 0;
            pre_targets_array = 0;
            return;
         end
      end
   end
   new_main_target = new_target;
   dmg_array = local_dmg_array;
   crit_roll_array = local_crit_roll_array;
   local_dmg_array = 0;
   local_crit_roll_array = 0;
   pre_targets_array = 0;
end

//get targets on thin line using draw_line algorithm from attacker to taget
procedure get_targets_on_thin_line_laser(variable attacker ,variable target) begin
   variable line_length = 50;
   variable line_elevation = elevation(attacker);
   variable first_tile = tile_num(attacker);
   variable second_tile = tile_num(target);
   variable tar_tile = tile_num(target);
   variable projectile_start_tile = tile_num_in_direction(first_tile, rotation_to_tile(first_tile, tar_tile), 1);
   variable temp_rot = rotation_to_tile(projectile_start_tile, tar_tile);
   variable rot_tar_to_atk = rotation_to_tile(tar_tile , projectile_start_tile);
   variable atk_tile = projectile_start_tile;
   variable temp_dist = tile_distance(projectile_start_tile, second_tile);
   variable temp_tile_in_dir = tile_num_in_direction(atk_tile, temp_rot, temp_dist);
   variable temp_dist_in_dir = tile_distance(temp_tile_in_dir, tar_tile);
   variable temp_rot_in_dir = rotation_to_tile(temp_tile_in_dir, tar_tile);
   variable atk_cur_rot = rotation_to_tile(first_tile, second_tile);
   variable side;
   variable tile_count;
   variable check_tile = atk_tile;
   variable last_tile;
   variable counter;
   variable new_target;
   variable tar_cur_frm;
   variable tar_cur_hp;
   variable tile_blocking_obj;
   variable modified = 0;
   //if modified == 0 andAlso temp_rot_in_dir == 0 andAlso atk_cur_rot == 4 andAlso rotation_to_tile(tar_tile , projectile_start_tile) == 1 andAlso temp_rot == 4 then begin
      //modified = 1;
      //temp_rot =  (temp_rot + 1)%6;
      //temp_tile_in_dir = tile_num_in_direction(atk_tile, (temp_rot), temp_dist);
      //temp_dist_in_dir = tile_distance(temp_tile_in_dir, tar_tile);
      //temp_rot_in_dir = rotation_to_tile(temp_tile_in_dir, tar_tile);
   //end
   if modified == 0 andAlso temp_rot_in_dir == 4 andAlso atk_cur_rot == 5 andAlso rot_tar_to_atk == 2 andAlso temp_rot == 0 then begin
      modified = 1;
      temp_rot =  (temp_rot + 5)%6;
      temp_tile_in_dir = tile_num_in_direction(atk_tile, (temp_rot), temp_dist);
      temp_dist_in_dir = tile_distance(temp_tile_in_dir, tar_tile);
      temp_rot_in_dir = rotation_to_tile(temp_tile_in_dir, tar_tile);
   end
   if modified == 0 andAlso temp_rot_in_dir == 5 andAlso atk_cur_rot == 1 andAlso rot_tar_to_atk == 4 andAlso temp_rot == 1 then begin
      modified = 1;
      temp_rot =  (temp_rot + 5)%6;
      temp_tile_in_dir = tile_num_in_direction(atk_tile, (temp_rot), temp_dist);
      temp_dist_in_dir = tile_distance(temp_tile_in_dir, tar_tile);
      temp_rot_in_dir = rotation_to_tile(temp_tile_in_dir, tar_tile);
   end
   if modified == 0 andAlso temp_rot_in_dir == 4 andAlso atk_cur_rot == 0 andAlso rot_tar_to_atk == 2 andAlso temp_rot == 0 then begin
      modified = 1;
      temp_rot =  (temp_rot + 5)%6;
      temp_tile_in_dir = tile_num_in_direction(atk_tile, (temp_rot), temp_dist);
      temp_dist_in_dir = tile_distance(temp_tile_in_dir, tar_tile);
      temp_rot_in_dir = rotation_to_tile(temp_tile_in_dir, tar_tile);
   end
   if modified == 0 andAlso temp_rot_in_dir == 4 andAlso atk_cur_rot == 2 andAlso rot_tar_to_atk == 0 andAlso temp_rot == 2 then begin
      modified = 1;
      temp_rot =  (temp_rot + 1)%6;
      temp_tile_in_dir = tile_num_in_direction(atk_tile, (temp_rot), temp_dist);
      temp_dist_in_dir = tile_distance(temp_tile_in_dir, tar_tile);
      temp_rot_in_dir = rotation_to_tile(temp_tile_in_dir, tar_tile);
   end
   if modified == 0 andAlso temp_rot_in_dir == 4 andAlso atk_cur_rot == 3 andAlso rot_tar_to_atk == 0 andAlso temp_rot == 2 then begin
      modified = 1;
      temp_rot =  (temp_rot + 1)%6;
      temp_tile_in_dir = tile_num_in_direction(atk_tile, (temp_rot), temp_dist);
      temp_dist_in_dir = tile_distance(temp_tile_in_dir, tar_tile);
      temp_rot_in_dir = rotation_to_tile(temp_tile_in_dir, tar_tile);
   end
   //if modified == 0 andAlso temp_rot_in_dir == 2 andAlso atk_cur_rot == 4 andAlso rotation_to_tile(tar_tile , projectile_start_tile) == 1 andAlso temp_rot == 4 then begin
      //modified = 1;
      //temp_rot =  (temp_rot + 5)%6;
      //temp_tile_in_dir = tile_num_in_direction(atk_tile, (temp_rot), temp_dist);
      //temp_dist_in_dir = tile_distance(temp_tile_in_dir, tar_tile);
      //temp_rot_in_dir = rotation_to_tile(temp_tile_in_dir, tar_tile);
   //end
   if modified == 0 andAlso temp_rot_in_dir == 3 andAlso atk_cur_rot == 1 andAlso rotation_to_tile(tar_tile , projectile_start_tile) == 4 andAlso temp_rot == 1 then begin
      modified = 1;
      temp_rot =  (temp_rot + 1)%6;
      temp_tile_in_dir = tile_num_in_direction(atk_tile, (temp_rot), temp_dist);
      temp_dist_in_dir = tile_distance(temp_tile_in_dir, tar_tile);
      temp_rot_in_dir = rotation_to_tile(temp_tile_in_dir, tar_tile);
   end
   if modified == 0 andAlso temp_rot_in_dir == 1 andAlso atk_cur_rot == 2 andAlso rot_tar_to_atk == 0 andAlso temp_rot == 3 then begin
      modified = 1;
      projectile_start_tile = first_tile;
      atk_tile = projectile_start_tile;
      check_tile = atk_tile;
      //temp_rot = rotation_to_tile(projectile_start_tile, tar_tile) + 1;
      temp_dist = tile_distance(projectile_start_tile, second_tile);
      temp_tile_in_dir = tile_num_in_direction(atk_tile, temp_rot, temp_dist);
      temp_dist_in_dir = tile_distance(temp_tile_in_dir, tar_tile);
      temp_rot_in_dir = rotation_to_tile(temp_tile_in_dir, tar_tile);
   end
   //atkr straight under tar
   if modified == 0 andAlso temp_rot_in_dir == 1 andAlso atk_cur_rot == 0 andAlso rot_tar_to_atk == 2 andAlso temp_rot == 5 then begin
      modified = 1;
      projectile_start_tile = first_tile;
      atk_tile = projectile_start_tile;
      check_tile = atk_tile;
      //temp_rot = rotation_to_tile(projectile_start_tile, tar_tile) + 1;
      temp_dist = tile_distance(projectile_start_tile, second_tile);
      temp_tile_in_dir = tile_num_in_direction(atk_tile, temp_rot, temp_dist);
      temp_dist_in_dir = tile_distance(temp_tile_in_dir, tar_tile);
      temp_rot_in_dir = rotation_to_tile(temp_tile_in_dir, tar_tile);
   end
   if modified == 0 andAlso temp_dist == 1 andAlso tile_distance(first_tile, second_tile) == 2 then begin
      modified = 1;
      projectile_start_tile = first_tile;
      atk_tile = projectile_start_tile;
      check_tile = atk_tile;
      temp_rot = rotation_to_tile( projectile_start_tile, tar_tile);
      temp_dist = tile_distance(projectile_start_tile, second_tile);
      temp_tile_in_dir = tile_num_in_direction(atk_tile, temp_rot, temp_dist);
      temp_dist_in_dir = tile_distance(temp_tile_in_dir, tar_tile);
      temp_rot_in_dir = rotation_to_tile(temp_tile_in_dir, tar_tile);
      if modified < 2 andAlso temp_rot_in_dir == 4 andAlso atk_cur_rot == 0 andAlso rotation_to_tile(tar_tile , projectile_start_tile) == 2 andAlso temp_rot == 0 then begin
         modified = 2;
         temp_rot =  (temp_rot + 5)%6;
         temp_tile_in_dir = tile_num_in_direction(atk_tile, (temp_rot), temp_dist);
         temp_dist_in_dir = tile_distance(temp_tile_in_dir, tar_tile);
         temp_rot_in_dir = rotation_to_tile(temp_tile_in_dir, tar_tile);
      end
      if modified < 2 andAlso temp_rot_in_dir == 4 andAlso atk_cur_rot == 2 andAlso rotation_to_tile(tar_tile , projectile_start_tile) == 0 andAlso temp_rot == 2 then begin
         modified = 2;
         temp_rot =  (temp_rot + 1)%6;
         temp_tile_in_dir = tile_num_in_direction(atk_tile, (temp_rot), temp_dist);
         temp_dist_in_dir = tile_distance(temp_tile_in_dir, tar_tile);
         temp_rot_in_dir = rotation_to_tile(temp_tile_in_dir, tar_tile);
      end
   end
   // point blank range
   if modified == 0 andAlso tile_distance(first_tile, second_tile) == 1 then begin
      modified = 1;
      projectile_start_tile = first_tile;
      atk_tile = projectile_start_tile;
      check_tile = atk_tile;
      temp_rot = rotation_to_tile( projectile_start_tile, tar_tile);
      temp_dist = tile_distance(projectile_start_tile, second_tile);
      temp_tile_in_dir = tile_num_in_direction(atk_tile, temp_rot, temp_dist);
      temp_dist_in_dir = tile_distance(temp_tile_in_dir, tar_tile);
      temp_rot_in_dir = rotation_to_tile(temp_tile_in_dir, tar_tile);
   end
   pre_targets_array = create_array(line_length+1,0);
   remainder = 0;
   if temp_dist_in_dir == 0 then begin
      side = temp_dist_in_dir;
   end
   else begin
      if temp_rot_in_dir == (temp_rot + 2) % 6 then begin
         side = 1;
      end
      else begin
         if temp_rot_in_dir == (temp_rot + 4) % 6 then begin
            side = 5;
         end
      end
   end
   if (side != 0) then begin
      counter = (temp_dist * 1.0) / temp_dist_in_dir / 2.0;
   end
   else begin
      counter = 100.0;
   end
   while (tile_count < line_length) do begin
      tile_count += 1;
      if (counter >= 1.0) then begin
         check_tile = tile_num_in_direction(check_tile, temp_rot, 1);
         counter = counter - 1.0;
      end
      else begin
         check_tile = tile_num_in_direction(check_tile, (temp_rot + side) % 6, 1);
         counter = ((temp_dist * 1.0) / temp_dist_in_dir) + re_count(counter) - 1.0;
      end
      //create_object_sid(205, check_tile, elevation(dude_obj), -1);// create active flare on each tile on a line
      tile_blocking_obj = obj_blocking_tile(check_tile, line_elevation, BLOCKING_TYPE_BLOCK);
      if tile_blocking_obj andAlso obj_type(tile_blocking_obj) == OBJ_TYPE_CRITTER then new_target = tile_blocking_obj;
      //skip knocked targets? better not :)
      //tar_cur_frm = get_object_data(new_target, OBJ_DATA_CUR_FRM);

      if new_target then begin
         tar_cur_hp = get_critter_stat(new_target, STAT_current_hp);
         if tar_cur_frm == 0 andAlso tar_cur_hp > 0 andAlso obj_is_visible_flag(new_target) andAlso not(is_in_array(new_target,pre_targets_array)) then begin
            set_array(pre_targets_array, tile_count, new_target);
         end
      end
      if check_tile == tar_tile then begin
         break;
      end
   end
   call get_targets_on_thin_line_laser_reversed(check_tile, projectile_start_tile, attacker);
end

//get last_tile's tile_num on a line (max_distance tiles long) between start_tile and any other tile
procedure get_last_tile_on_line(variable start_tile,variable tile_2,variable max_distance) begin
   variable temp_rot = rotation_to_tile(start_tile, tile_2);
   variable temp_dist = tile_distance(start_tile, tile_2);
   variable temp_tile_in_dir = tile_num_in_direction(start_tile, temp_rot, temp_dist);
   variable temp_dist_in_dir = tile_distance(temp_tile_in_dir, tile_2);
   variable temp_rot_in_dir = rotation_to_tile(temp_tile_in_dir, tile_2);
   variable check_tile = start_tile;
   variable side;
   variable tile_count;
   variable last_tile;
   variable counter;
   remainder = 0;
   if temp_dist_in_dir == 0 then begin
      side = temp_dist_in_dir;
   end
   else begin
      if temp_rot_in_dir == (temp_rot + 2) % 6 then begin
         side = 1;
      end
      else begin
         if temp_rot_in_dir == (temp_rot + 4) % 6 then begin
            side = 5;
         end
      end
   end
   if (side != 0) then begin
      counter = (temp_dist * 1.0) / temp_dist_in_dir / 2.0;
   end
   else begin
      counter = 100.0;
   end
   while (tile_count < max_distance) do begin
      tile_count += 1;
      if (counter >= 1.0) then begin
         check_tile = tile_num_in_direction(check_tile, temp_rot, 1);
         counter = counter - 1.0;
      end
      else begin
         check_tile = tile_num_in_direction(check_tile, (temp_rot + side) % 6, 1);
         counter = ((temp_dist * 1.0) / temp_dist_in_dir) + re_count(counter) - 1.0;
      end
   end
   last_tile = check_tile;
   return last_tile;
end

//get targets on "WIDE" line using obj_blocking_line
procedure get_targets_on_wide_line_gauss(variable attacker ,variable target) begin
   variable local_targets_array;
   variable local_dmg_array;
   variable local_crit_roll_array;
   variable atk_tile = tile_num(attacker);
   variable target_tile = tile_num(target);
   variable target_elevation = elevation(target);
   variable distant_target_tile = get_last_tile_on_line(atk_tile,target_tile,50);
   variable weapon_dmg = random(weapon_min_dmg, weapon_max_dmg);
   variable rot_atk_to_tar = rotation_to_tile(atk_tile, target_tile);
   variable pseudo_attacker = create_object_sid(pid_laser_projectile, tile_num_in_direction(atk_tile,rot_atk_to_tar,1), target_elevation, -1);
   variable blocking_obj;
   variable count;
   variable distance;
   variable tar_cur_frm;
   variable tar_cur_hp;
   variable dmg;
   variable new_tar_team;
   variable attacker_team = has_trait(TRAIT_OBJECT, attacker, OBJECT_TEAM_NUM);
   set_obj_visibility(pseudo_attacker, 1);
   local_targets_array = create_array(50,0);
   local_dmg_array = create_array(50,0);
   local_crit_roll_array = create_array(50,0);
   new_targets_count = 0;
   missed_targets_count = 0;
   multihex_targets_count = 0;
   //blocking_obj = obj_blocking_tile(tile_num(pseudo_attacker), target_elevation, BLOCKING_TYPE_BLOCK);
   blocking_obj = tile_get_next_critter(tile_num(pseudo_attacker), elevation(target), pseudo_attacker);
   if blocking_obj andAlso obj_type(blocking_obj) == OBJ_TYPE_CRITTER then begin
      //skip knocked targets? better not :)
      //tar_cur_frm = get_object_data(blocking_obj, OBJ_DATA_CUR_FRM);

      tar_cur_hp = get_critter_stat(blocking_obj, STAT_current_hp);
      if tar_cur_frm == 0 andAlso tar_cur_hp > 0 andAlso obj_is_visible_flag(blocking_obj) andAlso not(is_in_array(blocking_obj,local_targets_array))then begin
         new_tar_team = has_trait(TRAIT_OBJECT, blocking_obj, OBJECT_TEAM_NUM);
         if new_tar_team == enemy_team then begin
            enemy_targets_count += 1;
         end
         else if attacker_team == new_tar_team then begin
            friendly_targets_count += 1;
         end
         new_targets_count += 1;
         distance_objs(distance, pseudo_attacker, blocking_obj);
         set_array(local_targets_array, (distance + 1), blocking_obj);
         dmg = calc_dmg_gauss(attacker , blocking_obj, weapon_dmg);
         weapon_dmg = dmg;
         set_array(local_dmg_array, (new_targets_count - 1), dmg);
         set_array(local_crit_roll_array, (new_targets_count - 1), crit_power_roll);
         // new main_target if the damage is not enough to penetrate all targets
         new_main_target = last_target_on_a_line;
         if dmg == 0 then new_main_target = blocking_obj;
      end
   end
   blocking_obj = obj_blocking_line(pseudo_attacker, target_tile, BLOCKING_TYPE_BLOCK);
   while blocking_obj andAlso (obj_type(blocking_obj) == OBJ_TYPE_CRITTER or (get_flags(blocking_obj) bwand FLAG_SHOOTTHRU))  do begin
      if blocking_obj == target then begin
         //new_targets_count += 1;
         //break;
      end
      if count > 51 then break;
      if blocking_obj andAlso obj_type(blocking_obj) == OBJ_TYPE_CRITTER then begin
         //skip knocked targets? better not :)
         //tar_cur_frm = get_object_data(blocking_obj, OBJ_DATA_CUR_FRM);

         tar_cur_hp = get_critter_stat(blocking_obj, STAT_current_hp);
         if tar_cur_frm == 0 andAlso tar_cur_hp > 0 andAlso not(is_in_array(blocking_obj,local_targets_array)) then begin
            new_tar_team = has_trait(TRAIT_OBJECT, blocking_obj, OBJECT_TEAM_NUM);
            if new_tar_team == enemy_team then begin
               enemy_targets_count += 1;
            end
            else if attacker_team == new_tar_team then begin
               friendly_targets_count += 1;
            end
            new_targets_count += 1;
            if new_targets_count > 1 then weapon_dmg = last_dmg;
            distance_objs(distance, pseudo_attacker, blocking_obj);
            set_array(local_targets_array, (distance + 1), blocking_obj);
            dmg = calc_dmg_gauss(attacker , blocking_obj, weapon_dmg);
            weapon_dmg = dmg;
            set_array(local_dmg_array, (new_targets_count - 1), dmg);
            set_array(local_crit_roll_array, (new_targets_count - 1), crit_power_roll);
            new_main_target = last_target_on_a_line;
            // new main_target if the damage is not enough to penetrate all targets
            if dmg == 0 andAlso new_main_target == 0 then new_main_target = blocking_obj;
         end
      end
      if blocking_obj andAlso obj_type(blocking_obj) != OBJ_TYPE_CRITTER andAlso (get_flags(blocking_obj) bwand FLAG_SHOOTTHRU) then begin

      end
      blocking_obj = obj_blocking_line(blocking_obj, target_tile, BLOCKING_TYPE_BLOCK);
      count += 1;
   end

   blocking_obj = obj_blocking_line(target, distant_target_tile, BLOCKING_TYPE_BLOCK);
   while blocking_obj andAlso blocking_obj != target andAlso (obj_type(blocking_obj) == OBJ_TYPE_CRITTER or (get_flags(blocking_obj) bwand FLAG_SHOOTTHRU))  do begin
      if count > 51 then break;
      if blocking_obj andAlso obj_type(blocking_obj) == OBJ_TYPE_CRITTER then begin
         //skip knocked targets? better not :)
         //tar_cur_frm = get_object_data(blocking_obj, OBJ_DATA_CUR_FRM);

         tar_cur_hp = get_critter_stat(blocking_obj, STAT_current_hp);
         if not(is_in_array(blocking_obj,local_targets_array)) andAlso tar_cur_frm == 0 andAlso tar_cur_hp > 0 andAlso obj_is_visible_flag(blocking_obj) then begin
            new_tar_team = has_trait(TRAIT_OBJECT, blocking_obj, OBJECT_TEAM_NUM);
            if new_tar_team == enemy_team then begin
               enemy_targets_count += 1;
            end
            else if attacker_team == new_tar_team then begin
               friendly_targets_count += 1;
            end
            new_targets_count += 1;
            distance_objs(distance, pseudo_attacker, blocking_obj);
            set_array(local_targets_array, (distance + 1), blocking_obj);
            dmg = calc_dmg_gauss(attacker , blocking_obj, weapon_dmg);
            weapon_dmg = dmg;
            set_array(local_dmg_array, (new_targets_count - 1), dmg);
            set_array(local_crit_roll_array, (new_targets_count - 1), crit_power_roll);
            new_main_target = last_target_on_a_line;
            // new target if the damage is not enough to penetrate all targets
            if dmg == 0 andAlso new_main_target == 0 then new_main_target = blocking_obj;
         end
      end
      if blocking_obj andAlso obj_type(blocking_obj) != OBJ_TYPE_CRITTER andAlso (get_flags(blocking_obj) bwand FLAG_SHOOTTHRU) then begin

      end
      blocking_obj = obj_blocking_line(blocking_obj, distant_target_tile, BLOCKING_TYPE_BLOCK);
      count += 1;
   end
   if pseudo_attacker then destroy_object(pseudo_attacker);
   new_main_target = last_target_on_a_line;
   targets_array = local_targets_array;
   dmg_array = local_dmg_array;
   crit_roll_array = local_crit_roll_array;
end

//get targets on "WIDE" line using obj_blocking_line
procedure get_targets_on_wide_line_laser(variable attacker ,variable target) begin
   variable pre_targets_array;
   variable local_dmg_array;
   variable local_crit_roll_array;
   variable atk_tile = tile_num(attacker);
   variable target_tile = tile_num(target);
   variable rot_atk_to_tar = rotation_to_tile(atk_tile, target_tile);
   variable pseudo_attacker = create_object_sid(pid_laser_projectile, tile_num_in_direction(atk_tile,rot_atk_to_tar,1), elevation(attacker), -1);
   variable tar_cur_hp;
   variable blocking_obj;
   variable count;
   variable dmg;
   variable tar_cur_frm;
   variable new_tar_team;
   variable attacker_team = has_trait(TRAIT_OBJECT, attacker, OBJECT_TEAM_NUM);
   set_obj_visibility(pseudo_attacker, 1);
   pre_targets_array = create_array(50,0);
   local_dmg_array = create_array(50,0);
   local_crit_roll_array = create_array(50,0);
   new_targets_count = 0;
   missed_targets_count = 0;
   multihex_targets_count = 0;
   //blocking_obj = obj_blocking_tile(tile_num(pseudo_attacker), elevation(target), BLOCKING_TYPE_BLOCK);
   blocking_obj = tile_get_next_critter(tile_num(pseudo_attacker), elevation(target), pseudo_attacker);
      if blocking_obj andAlso obj_type(blocking_obj) == OBJ_TYPE_CRITTER then begin
         //skip knocked targets? better not :)
         //tar_cur_frm = get_object_data(blocking_obj, OBJ_DATA_CUR_FRM);
         tar_cur_hp = get_critter_stat(blocking_obj, STAT_current_hp);
         if tar_cur_hp > 0 andAlso tar_cur_frm == 0 andAlso obj_is_visible_flag(blocking_obj) andAlso not(is_in_array(blocking_obj,pre_targets_array)) then begin
            new_tar_team = has_trait(TRAIT_OBJECT, blocking_obj, OBJECT_TEAM_NUM);
            if new_tar_team == enemy_team then begin
               enemy_targets_count += 1;
            end
            else if attacker_team == new_tar_team then begin
               friendly_targets_count += 1;
            end
            new_targets_count += 1;
            //terminate procedure if there are not enough ammo to penetrate additional targets
            if LaserForced <= 0 andAlso (new_targets_count -  missed_targets_count) == laser_curr_ammo - base_alt_ammo_cost then begin
               new_main_target = blocking_obj;
               target = blocking_obj;
               dmg = calc_dmg_laser(attacker, blocking_obj);
               set_array(local_dmg_array, (new_targets_count - 1), dmg);
               set_array(local_crit_roll_array, (new_targets_count - 1), crit_power_roll);
               set_array(pre_targets_array, (new_targets_count - 1), blocking_obj);
               new_dmg_to_orig_target = dmg;
               targets_array = pre_targets_array;
               dmg_array = local_dmg_array;
               crit_roll_array = local_crit_roll_array;
               local_dmg_array = 0;
               local_crit_roll_array = 0;
               pre_targets_array = 0;
               return;
            end
            dmg = calc_dmg_laser(attacker, blocking_obj);
            set_array(local_dmg_array, (new_targets_count - 1), dmg);
            set_array(local_crit_roll_array, (new_targets_count - 1), crit_power_roll);
            set_array(pre_targets_array, (new_targets_count - 1), blocking_obj);
         end
      end
   blocking_obj = obj_blocking_line(pseudo_attacker, target_tile, BLOCKING_TYPE_SHOOT);
   while blocking_obj andAlso (obj_type(blocking_obj) == OBJ_TYPE_CRITTER or (get_flags(blocking_obj) bwand FLAG_SHOOTTHRU)) do begin
      if count > 50 then break;
      if blocking_obj andAlso obj_type(blocking_obj) == OBJ_TYPE_CRITTER then begin
         //skip knocked targets? better not :)
         //tar_cur_frm = get_object_data(blocking_obj, OBJ_DATA_CUR_FRM);
         tar_cur_hp = get_critter_stat(blocking_obj, STAT_current_hp);
         if tar_cur_hp > 0 andAlso tar_cur_frm == 0 andAlso obj_is_visible_flag(blocking_obj) andAlso not(is_in_array(blocking_obj,pre_targets_array)) then begin
            new_tar_team = has_trait(TRAIT_OBJECT, blocking_obj, OBJECT_TEAM_NUM);
            if new_tar_team == enemy_team then begin
               enemy_targets_count += 1;
            end
            else if attacker_team == new_tar_team then begin
               friendly_targets_count += 1;
            end
            new_targets_count += 1;
            if blocking_obj == target then begin
               //new_main_target = blocking_obj;
               target = blocking_obj;
               dmg = calc_dmg_laser(attacker, blocking_obj);
               new_dmg_to_orig_target = dmg;
               set_array(local_dmg_array, (new_targets_count - 1), dmg);
               set_array(local_crit_roll_array, (new_targets_count - 1), crit_power_roll);
               set_array(pre_targets_array, (new_targets_count - 1), blocking_obj);
               break;
            end
            //terminate cycle if there are not enough ammo to penetrate additional targets
            if LaserForced <= 0 andAlso (new_targets_count -  missed_targets_count) == laser_curr_ammo - base_alt_ammo_cost then begin
               new_main_target = blocking_obj;
               target = blocking_obj;
               dmg = calc_dmg_laser(attacker, blocking_obj);
               new_dmg_to_orig_target = dmg;
               set_array(local_dmg_array, (new_targets_count - 1), dmg);
               set_array(local_crit_roll_array, (new_targets_count - 1), crit_power_roll);
               set_array(pre_targets_array, (new_targets_count - 1), blocking_obj);
               break;
            end
            dmg = calc_dmg_laser(attacker, blocking_obj);
            set_array(local_dmg_array, (new_targets_count - 1), dmg);
            set_array(local_crit_roll_array, (new_targets_count - 1), crit_power_roll);
            set_array(pre_targets_array, (new_targets_count - 1), blocking_obj);
         end
      end
      if blocking_obj andAlso obj_type(blocking_obj) != OBJ_TYPE_CRITTER andAlso (get_flags(blocking_obj) bwand FLAG_SHOOTTHRU) then begin

      end
      blocking_obj = obj_blocking_line(blocking_obj, target_tile, BLOCKING_TYPE_SHOOT);
      count += 1;
   end
   if pseudo_attacker then destroy_object(pseudo_attacker);
   dmg_array = local_dmg_array;
   crit_roll_array = local_crit_roll_array;
   targets_array = pre_targets_array;
   local_dmg_array = 0;
   local_crit_roll_array = 0;
   pre_targets_array = 0;
end

procedure show_dmg_combat_msg(variable target,variable attacker,variable dmg_value) begin
   variable target_gender;
   variable target_name;
   variable combat_msg_num;
   variable target_cur_hp;
   variable flags;
   variable is_crit;
   variable is_KO;
   variable str_end = ".";
   flags = dmg_value / DAM_FLAGS_MULT;
   dmg_value = dmg_value % DAM_FLAGS_MULT;
   if flags > 1 then begin
      //if flags bwand DAM_CRITICAL != 0 then
         //is_crit = 1;
      if flags bwand DAM_KNOCKED_DOWN != 0 then
         is_KO = 1;
   end
   //return if no target
   if target <= 0 then return;
   target_cur_hp = get_critter_stat(target, STAT_current_hp);
   // npc msg
   if target != dude_obj then begin
      target_name = obj_name(target);
      target_gender = get_critter_stat(target, STAT_gender) * 100;
      combat_msg_num += (target_gender + 100);
   end
   //dude msg
   else begin
      target_name = modmsg(combat_msg_you);
      target_gender = get_critter_stat(target, STAT_gender) * 50;
      combat_msg_num += target_gender;
   end
   // dmg msg
   if dmg_value > 1 then begin
      combat_msg_num += combat_msg_hit_dmg;
      if is_crit > 0 then begin
         combat_msg_num += 7;
      end
   end
   // 1 dmg msg
   else if dmg_value == 1 then begin
      combat_msg_num += combat_msg_hit_1_dmg;
      if is_crit > 0 then begin
         combat_msg_num += 1;
      end
   end
   //no dmg msg
   else begin
      combat_msg_num += combat_msg_hit_no_dmg;
   end
   //show msg
   if target_cur_hp > dmg_value then begin
      if is_KO > 0 then
         str_end = modmsg(msg_dmg_KO);
      display_msg(sprintf2(modmsg(combat_msg_num), target_name, dmg_value)+str_end);
   end
   //show death msg
   else begin
      display_msg(sprintf2(modmsg(combat_msg_num), target_name, dmg_value)+modmsg(msg_death));
   end
end

procedure show_death_msg begin
   variable target;
   variable dmg_value;
   variable target_sid;
   variable target_frm;
   foreach (target : dmg_value in death_array) begin
      target_frm = art_anim(obj_art_fid(target));
      if target_frm >= ANIM_bad_landing_sf andAlso target_frm <= ANIM_fall_front_blood_sf then begin
         set_array(death_array, target, 0);
         target_sid = get_object_data(target, OBJ_DATA_SID);
         if target_sid > 0 then begin
            set_obj_script_objects(target_sid, orig_attacker, 0);
            exec_obj_script_proc(target_sid, destroy_proc);
         end
         call show_dmg_combat_msg(target, -1, dmg_value);
         set_outline(target,  OUTLINE_NONE);
         if target != dude_obj then begin
            // kill_critter without programStack
            reg_anim_clear(target);
            call_offset_v1(0x426DDC, target);//remove from combat
            call_offset_v3(0x42DA64, target, target_frm, true);//kill critter
            //kill_critter(target, target_frm);
         end
         else begin
            dmg_value = dmg_value % DAM_FLAGS_MULT;
            critter_heal(target,-dmg_value);
         end
      end
   end
   if len_array(death_array) <= 0 then begin
      free_array(death_array);
   end
end

procedure get_death_anim(variable target, variable attacker, variable dmg_value, variable dmg_type, variable dmg_source_tile) begin
   variable death_anim = ANIM_fall_back;
   variable target_cur_anim = art_anim(obj_art_fid(target));
   variable target_max_hp = get_critter_stat(target, STAT_max_hp);
   variable death_anim_sf;
   variable is_front_hit = is_hit_from_front(dmg_source_tile, target);
   variable is_burst = dmg_type bwand DMG_BURST;
   //add target to array of creatures that will die. critter_PTR as key, dmg as value
   if not(array_exists(death_array)) then begin
      death_array = create_array_map;
      set_array(death_array, target, dmg_value);
   end
   else begin
      set_array(death_array, target, dmg_value);
   end
   //remove flags from dmg
   dmg_value = dmg_value % DAM_FLAGS_MULT;
   //Death animation for Horrigan
   if target > 0 andAlso obj_pid(target) == PID_END_BOSS then begin
      death_anim = ANIM_exploded_to_nothing;
      return death_anim;
   end
   //Death animation for a knocked out target
   if target_cur_anim == ANIM_fall_back then begin
      death_anim = ANIM_fall_back_blood;
      return death_anim;
   end
   else if target_cur_anim == ANIM_fall_front then begin
      death_anim = ANIM_fall_front_blood;
      return death_anim;
   end
   //Death animation for a standing target
   else begin
      dmg_type -= is_burst;
      //standard death_anim
      if dmg_type == DMG_normal_dam andAlso is_burst < 0 andAlso (dmg_value < 35 or dmg_value < target_max_hp) andAlso random(0,2) then begin
         death_anim = ANIM_fall_front - is_front_hit;
      end
      //brutal death_anim
      else begin
         if dmg_type == DMG_plasma then begin
            if random(0, 3) then begin
               death_anim = ANIM_melted_to_nothing;
            end
            else begin
               death_anim = ANIM_charred_body;
            end
         end
         else if dmg_type == DMG_electrical then begin
            if random(0, 3) then begin
               death_anim = ANIM_electrify;
            end
            else begin
               death_anim = ANIM_electrified_to_nothing;
            end
         end
         else if dmg_type == DMG_laser then begin
            death_anim = ANIM_sliced_in_half;
         end
         else if dmg_type == DMG_explosion then begin
            death_anim = ANIM_exploded_to_nothing;
         end
         else if dmg_type == DMG_normal_dam then begin
            //brust death_anim
            if is_burst > 0 then begin
               //heavy burst
               if is_burst > DMG_BURST then begin
                  death_anim = ANIM_chunks_of_flesh;
               end
               //light burst
               else begin
                  death_anim = ANIM_dancing_autofire;
               end
            end
            //single death_anim
            else begin
               if dmg_value < 99 andAlso dmg_value < target_max_hp then begin
                  death_anim = ANIM_big_hole;
               end
               else begin
                  death_anim = ANIM_exploded_to_nothing;
               end
            end
         end
         else if dmg_type == DMG_fire then begin
            death_anim = ANIM_fire_dance;
            death_anim_sf = death_anim + 28;
            if not(art_exists_death_anim(target,death_anim)) andAlso not(art_exists_basic_anim(target,death_anim)) andAlso not(art_exists_death_anim(target,death_anim_sf)) andAlso not(art_exists_basic_anim(target,death_anim_sf)) then begin
               death_anim = ANIM_burned_to_nothing;
            end
         end
         else begin
            death_anim = ANIM_fall_front - is_front_hit;
         end
      end
      death_anim_sf = death_anim + 28;
      //if death_anim exist then return it
      if art_exists_death_anim(target,death_anim) orElse art_exists_basic_anim(target,death_anim) orElse art_exists_death_anim(target,death_anim_sf) orElse art_exists_basic_anim(target,death_anim_sf) then begin
         return death_anim;
      end
      //else return standard death_anim
      else begin
         if is_front_hit or (not(art_exists_death_anim(target,ANIM_fall_front)) andAlso not(art_exists_basic_anim(target,ANIM_fall_front)) andAlso not(art_exists_death_anim(target,ANIM_fall_front_sf)) andAlso not(art_exists_basic_anim(target,ANIM_fall_front_sf))) then begin
            return ANIM_fall_back;
         end
         else begin
            return ANIM_fall_front;
         end
      end
   end
end

procedure critter_inflict_dmg(variable target,variable attacker,variable dmg_value, variable dmg_type, variable animate, variable dmg_source_tile) begin
   variable target_cur_hp;
   variable target_cur_anim;
   variable target_sid;
   variable orig_target_team;
   variable target_team = -1;
   variable attacker_team = -1;
   variable who_hit_target;
   variable death_anim;
   variable death_anim_part2;
   variable death_anim_sf;
   variable attacker_weapon;
   variable combat_xp_bonus;
   variable in_combat;
   variable flags;
   //check if the target exists and is a creature
   if target <= 0 orElse obj_type(target) != OBJ_TYPE_CRITTER orElse attacker <= 0 orElse get_array(death_array,target) > 0 then begin
      return;
   end
   target_cur_hp = get_critter_stat(target, STAT_current_hp);
   target_cur_anim = art_anim(obj_art_fid(target));
   target_sid = get_object_data(target, OBJ_DATA_SID);
   orig_target_team = has_trait(TRAIT_OBJECT, real_orig_target, OBJECT_TEAM_NUM);
   target_team = has_trait(TRAIT_OBJECT, target, OBJECT_TEAM_NUM);
   attacker_team = has_trait(TRAIT_OBJECT, attacker, OBJECT_TEAM_NUM);
   if combat_is_initialized then begin
      in_combat = 1;
      attacker_weapon = get_object_data(combat_data, C_ATTACK_WEAPON);
   end
   //check dmg source tile
   if dmg_source_tile < 0 or dmg_source_tile == tile_num(target) then begin
      dmg_source_tile = tile_num(attacker);
   end
   //chance to set who hit the target if they are from different teams
   if attacker_team != target_team andAlso (get_object_data(target, OBJ_DATA_WHO_HIT_ME) <= 0 orElse dmg_value >= target_cur_hp orElse not(random(0,2))) then begin
      set_object_data(target, OBJ_DATA_WHO_HIT_ME, attacker);
   end
   //set flags
   flags = animate * DAM_FLAGS_MULT;
   //cause non-lethal damage
   if target_cur_hp > dmg_value then begin
      //party_remove(target);
      //if the target has a script, set and execute damage_p_proc
      if target_sid > 0 andAlso attacker_team != target_team then begin
         set_obj_script_fixed_value(target_sid, dmg_value);
         if target_team == orig_target_team or not(random(0,5)) then begin
            set_obj_script_objects(target_sid, attacker, attacker_weapon);
         end
         exec_obj_script_proc(target_sid, damage_proc);
      end
      if animate > 0 andAlso target_cur_anim != ANIM_fall_back andAlso target_cur_anim != ANIM_fall_front then begin
         if animate bwand DAM_KNOCKED_DOWN != 0 then begin
            reg_anim_combat_check(0);
            reg_anim_clear(target);
            reg_anim_func(REG_ANIM_BEGIN, RB_UNRESERVED);
            if is_hit_from_front(dmg_source_tile, target) or (not(art_exists_death_anim(target,ANIM_fall_front)) andAlso not(art_exists_basic_anim(target,ANIM_fall_front)) andAlso not(art_exists_death_anim(target,ANIM_fall_front_sf)) andAlso not(art_exists_basic_anim(target,ANIM_fall_front_sf))) then begin
               reg_anim_play_sfx(target,sfx_build_char_name(target,ANIM_fall_back,snd_knock_down),0);
               reg_anim_animate(target, ANIM_fall_back, 0);
            end
            else begin
               reg_anim_play_sfx(target,sfx_build_char_name(target,ANIM_fall_front,snd_knock_down),0);
               reg_anim_animate(target, ANIM_fall_front, 0);
            end
            reg_anim_end();
         end
         else begin
            reg_anim_combat_check(0);
            reg_anim_clear(target);
            reg_anim_func(REG_ANIM_BEGIN, RB_UNRESERVED);
            if is_hit_from_front(dmg_source_tile, target) or not(art_exists_basic_anim(target,ANIM_hit_from_back)) then begin
               reg_anim_play_sfx(target,sfx_build_char_name(target,ANIM_hit_from_front,snd_contact),0);
               reg_anim_animate(target, ANIM_hit_from_front, 0);
            end
            else begin
               reg_anim_play_sfx(target,sfx_build_char_name(target,ANIM_hit_from_back,snd_contact),0);
               reg_anim_animate(target, ANIM_hit_from_back, 0);
            end
            reg_anim_end();
         end
      end
      call show_dmg_combat_msg(target, attacker, (dmg_value + flags));
      critter_heal(target, -dmg_value);
   end
   //cause lethal damage
   else begin
      //if the target has a script, set and execute damage_p_proc
      if target_sid > 0 andAlso attacker_team != target_team then begin
         set_obj_script_fixed_value(target_sid, dmg_value);
         set_obj_script_objects(target_sid, attacker, attacker_weapon);
         exec_obj_script_proc(target_sid, damage_proc);
      end
      if animate > 0 then begin
         death_anim = get_death_anim(target,attacker,(dmg_value + flags),dmg_type,dmg_source_tile);
         reg_anim_combat_check(0);
         reg_anim_clear(target);
         reg_anim_func(REG_ANIM_BEGIN, RB_UNRESERVED);
         //standardt death anim
         if death_anim == ANIM_fall_back or death_anim == ANIM_fall_front then begin
            death_anim_part2 = death_anim + 14;
            death_anim_sf = death_anim_part2 + 28;
            reg_anim_play_sfx(target,sfx_build_char_name(target,death_anim,snd_knock_down),0);
            reg_anim_animate(target, death_anim, 0);
            reg_anim_play_sfx(target,sfx_build_char_name(target,death_anim_part2,snd_knock_down),-1);
            reg_anim_animate(target, death_anim_part2, 0);
         end
         //KO target death
         else if death_anim == ANIM_fall_back_blood or death_anim == ANIM_fall_back_blood then begin
            death_anim_sf = death_anim + 28;
            reg_anim_play_sfx(target,sfx_build_char_name(target,death_anim,snd_knock_down),0);
            reg_anim_animate(target, death_anim, 0);
         end
         //brutal fire_dance death
         else if death_anim == ANIM_fire_dance then begin
            death_anim_part2 = death_anim - 4;
            death_anim_sf = death_anim_part2 + 28;
            reg_anim_play_sfx(target,sfx_build_char_name(target,death_anim,snd_knock_down),0);
            reg_anim_animate(target, death_anim, 0);
            reg_anim_play_sfx(target,sfx_build_char_name(target,death_anim_part2,snd_knock_down),-1);
            reg_anim_animate(target, death_anim_part2, 0);
         end
         //brutal death
         else begin
            death_anim_sf = death_anim + 28;
            reg_anim_play_sfx(target,sfx_build_char_name(target,death_anim,snd_knock_down),0);
            reg_anim_animate(target, death_anim, 0);
         end
         reg_anim_animate(target, death_anim_sf, -1);
         reg_anim_callback(show_death_msg);
         reg_anim_end();
      end
      //increase combat_xp and increase kill_count
      if in_combat andAlso attacker_team == TEAM_PLAYER then begin
         if target_team != TEAM_PLAYER then begin
            //inc combat exp
            if Sonora <= 0 then begin
               combat_xp_bonus = get_combat_exp + get_critter_xp(target);
               set_combat_exp(combat_xp_bonus);
            end
            inc_kill_count(critter_kill_type(target));
         end
         else begin
            inc_kill_count(critter_kill_type(target));
         end
      end
   end
end

procedure STDPROCEDURE begin
   variable i;
   variable attacker;
   variable new_tar;
   variable new_tar_pid;
   variable new_tar_critter_flags;
   variable new_tar_frame;
   variable crit_mult;
   variable dmg;
   variable tar_cur_hp;
   variable accumulated_experience;
   variable critter_team;
   variable party;
   variable target_sid;
   variable attacker_team = has_trait(TRAIT_OBJECT, attacker, OBJECT_TEAM_NUM);
   variable orig_target_team = has_trait(TRAIT_OBJECT, real_orig_target, OBJECT_TEAM_NUM);
   variable in_combat = combat_is_initialized;
   combat_dmg = get_object_data(combat_data, C_ATTACK_DAMAGE_TARGET);
   if in_combat andAlso one_time_call == 1 andAlso targets_array != 0 then begin
      attacker = orig_attacker;
      party = party_member_list(0);
      if missed_shot andAlso show_float_dmg > 0 andAlso obj_type(orig_target) == OBJ_TYPE_CRITTER andAlso not(is_in_array(orig_target,targets_array)) andAlso targets_count > 1 then begin
         if combat_dmg <= 0 then begin
            float_msg(orig_target, "0", 2);
         end
         else begin
            float_msg(orig_target, "-"+combat_dmg, 2);
         end
      end
      reg_anim_combat_check(0);
      reg_anim_begin();
      foreach (new_tar in targets_array) begin
               if new_tar == orig_target andAlso obj_type(orig_target) != OBJ_TYPE_CRITTER then begin
                  i += 1;
               end
                  if new_tar andAlso obj_type(new_tar) == OBJ_TYPE_CRITTER andAlso new_tar != attacker andAlso (not(is_dead(new_tar)) or new_tar == orig_target) then begin
                  tar_cur_hp = get_critter_stat(new_tar, STAT_current_hp);
                  crit_power_roll = get_array(crit_roll_array, i);
                  if new_tar == last_target_on_a_line andAlso obj_type(orig_target) == OBJ_TYPE_CRITTER then crit_power_roll = -1;
                  crit_mult = get_crit_mult(crit_power_roll,new_tar);
                  new_tar_pid = obj_pid(new_tar);
                  new_tar_critter_flags = get_proto_data(new_tar_pid, PROTO_CR_FLAGS);
                  new_tar_frame = art_anim(obj_art_fid(new_tar));
                  critter_team = has_trait(TRAIT_OBJECT, new_tar, OBJECT_TEAM_NUM);
                  target_sid = get_object_data(new_tar, OBJ_DATA_SID);
                  //on a hit, the target becomes hostile
                  if critter_team == TEAM_PLAYER then begin
                     //on a hit, a friendly(non-companion) target with low health has a 33% chance to become hostile
                     if (tar_cur_hp < 20 andAlso not(random(0,2))) andAlso not(is_in_array(new_tar, party)) then attack_setup(new_tar, attacker);
                  end
                  else begin
                     //on a hit, a neutral target has a 66% chance to become hostile
                     if random(0,2) then attack_setup(new_tar, attacker);
                  end

                  if new_tar == orig_target then begin
                     dmg = combat_dmg;
                  end
                  else begin
                     if (new_tar_critter_flags bwand CFLG_INVULN) then begin
                        dmg = 0;
                     end
                     else begin
                        dmg = round(get_array(dmg_array, i) * crit_mult);
                     end
                  end
                  i += 1;


                        if dmg <= 0 then begin
                           if show_float_dmg > 0 andAlso targets_count > 1 then begin
                              if crit_power_roll < 0 or (missed_shot andAlso new_tar == orig_target) then begin
                                 float_msg(new_tar,"~", 2);
                              end
                              else begin
                                 float_msg(new_tar,"0", 2);
                              end
                           end
                           if new_tar != orig_target then display_msg(parse_str_2(modmsg(msg_hit_no_dmg), obj_name(new_tar), dmg));
                           if not(new_tar_critter_flags bwand CFLG_INVULN) andAlso weapon_damage_type == DMG_normal_dam then break;
                        end
                        if show_float_dmg > 0 andAlso new_tar == orig_target andAlso targets_count > 1 then begin
                           if dmg <= 0 then begin
                              if missed_shot then begin
                                 float_msg(new_tar, "~", 2);
                              end
                              else begin
                                 float_msg(new_tar, "0", 2);
                              end
                           end
                           else begin
                              if first_combat_dmg > 0 then begin
                                 float_msg(new_tar, "-"+first_combat_dmg, 2);
                              end
                              else begin
                                 float_msg(new_tar, "-"+combat_dmg, 2);
                              end
                           end
                        end
                        if dmg > 0 andAlso new_tar != orig_target then begin
                           if crit_power_roll < 0 then begin
                              if show_float_dmg > 0 andAlso targets_count > 1 andAlso (new_tar != real_orig_target or (new_tar == real_orig_target andAlso real_orig_target == COMBATDAMAGE_target)) then begin
                                 float_msg(new_tar, "~", 2);
                              end
                              display_msg(parse_str_2(modmsg(msg_hit_no_dmg), obj_name(new_tar), dmg));
                           end
                           else begin

                                 // new_target will take non lethal dmg
                                 if (tar_cur_hp - dmg) > 0 andAlso crit_power_roll <= 100 then begin
                                    if crit_mult == 2 then begin
                                       critter_injure(new_tar, DAM_KNOCKED_DOWN);
                                    end
                                    if crit_mult == 3 then begin
                                       critter_injure(new_tar, DAM_KNOCKED_OUT);
                                    end
                                    //non critical + low_critical dmg msg
                                    if crit_mult < 2 then begin
                                       // 1 hp dmg
                                       if dmg == 1 then begin
                                          //non critical 1 hp dmg msg
                                          if crit_mult == 1 then begin
                                             display_msg(parse_str_2(modmsg(msg_hit_1_hp), obj_name(new_tar), dmg));
                                          end
                                          // critical 1 hp dmg not KO
                                          else begin
                                             display_msg(parse_str_2(modmsg(msg_hit_1_hp), obj_name(new_tar), dmg));
                                             //display_msg(parse_str_2(modmsg(msg_critical_hit_1_hp), obj_name(new_tar), dmg));
                                          end
                                       end
                                       // > 1 hp dmg
                                       else begin
                                          //non critical dmg msg
                                          if crit_mult == 1 then begin
                                             display_msg(parse_str_2(modmsg(msg_hit), obj_name(new_tar), dmg));
                                          end
                                          // critical dmg not KO
                                          else begin
                                             display_msg(parse_str_2(modmsg(msg_hit), obj_name(new_tar), dmg));
                                             //display_msg(parse_str_2(modmsg(msg_critical_hit), obj_name(new_tar), dmg));
                                          end
                                       end
                                    end
                                    else begin
                                       // critical 1 hp dmg KO
                                       if dmg == 1 then begin
                                          display_msg(parse_str_2(modmsg(msg_hit_add_1_hp), obj_name(new_tar), dmg) + modmsg(msg_dmg_KO));
                                          //display_msg(parse_str_2(modmsg(msg_critical_hit_add_1_hp), obj_name(new_tar), dmg) + modmsg(msg_dmg_KO));
                                       end
                                       // critical dmg KO
                                       else begin
                                          display_msg(parse_str_2(modmsg(msg_hit_add), obj_name(new_tar), dmg) + modmsg(msg_dmg_KO));
                                          //display_msg(parse_str_2(modmsg(msg_critical_hit_add), obj_name(new_tar), dmg) + modmsg(msg_dmg_KO));
                                       end
                                    end
                                    //call dmg_p_proc in critter script
                                    critter_heal(new_tar, -dmg);
                                    if target_sid > 0 andAlso attacker_team != critter_team then begin
                                       set_obj_script_fixed_value(target_sid, dmg);
                                       if critter_team == orig_target_team or not(random(0,3)) then begin
                                          set_obj_script_objects(target_sid, attacker, weapon);
                                       end
                                       exec_obj_script_proc(target_sid, damage_proc);
                                    end
                                    if show_float_dmg > 0 then float_msg(new_tar, "-"+dmg, 2);
                                 end
                                 //if new_target will die
                                 else begin

                                    if sonora <= 0 then accumulated_experience += get_critter_xp(new_tar);
                                    set_outline(new_tar, OUTLINE_NONE);
                                    //call dmg_p_proc in critter script
                                    if target_sid > 0 andAlso attacker_team != critter_team then begin
                                       set_obj_script_fixed_value(target_sid, dmg);
                                       set_obj_script_objects(target_sid, attacker, weapon);
                                       exec_obj_script_proc(target_sid, damage_proc);
                                    end

                                    if show_float_dmg > 0 then float_msg(new_tar, "-"+dmg, 2);

                                    //if in_combat add kill xp
                                    if in_combat andAlso attacker_team == TEAM_PLAYER then begin
                                       if attacker_team != TEAM_PLAYER then begin
                                          inc_kill_count(critter_kill_type(new_tar));
                                          accumulated_experience += get_critter_xp(new_tar);
                                       end
                                       else begin
                                          inc_kill_count(critter_kill_type(new_tar));
                                       end
                                    end

                                    //if the target has a script, set and execute destroy_p_proc
                                    if target_sid > 0 then begin
                                       set_obj_script_objects(target_sid, new_tar, attacker);
                                       exec_obj_script_proc(target_sid, destroy_proc);
                                    end
                                    if new_tar_frame == ANIM_fall_back then begin
                                       reg_anim_clear(new_tar);
                                       reg_anim_animate(new_tar, ANIM_fall_back_blood, random(1,3));
                                    end
                                    if new_tar_frame == ANIM_fall_front then begin
                                       reg_anim_clear(new_tar);
                                       reg_anim_animate(new_tar, ANIM_fall_front_blood, random(1,3));
                                    end
                                    if crit_power_roll <= 100 then begin
                                       // non critical death msg
                                       if crit_mult <= 1 then begin
                                          // non critical death 1 hp dmg msg
                                          if dmg == 1 then begin
                                             display_msg(parse_str_2(modmsg(msg_hit_add_1_hp), obj_name(new_tar), dmg) + modmsg(msg_death));
                                          end
                                          // non critical death > 1 hp dmg msg
                                          else begin
                                             display_msg(parse_str_2(modmsg(msg_hit_add), obj_name(new_tar), dmg) + modmsg(msg_death));
                                          end
                                       end
                                       // critical death msg
                                       else begin
                                         //critical death 1 hp dmg msg
                                         if dmg == 1 then begin
                                             display_msg(parse_str_2(modmsg(msg_hit_add_1_hp), obj_name(new_tar), dmg) + modmsg(msg_death));
                                             //display_msg(parse_str_2(modmsg(msg_critical_hit_add_1_hp), obj_name(new_tar), dmg) + modmsg(msg_death));
                                          end
                                           //critical death >1 hp dmg msg
                                          else begin
                                             display_msg(parse_str_2(modmsg(msg_hit_add), obj_name(new_tar), dmg) + modmsg(msg_death));
                                             //display_msg(parse_str_2(modmsg(msg_critical_hit_add), obj_name(new_tar), dmg) + modmsg(msg_death));
                                          end
                                       end
                                    end
                                    // if rolled instant death
                                    else begin
                                       // instant death 1 hp dmg msg
                                       if dmg == 1 then begin
                                          display_msg(parse_str_2(modmsg(msg_hit_add_1_hp), obj_name(new_tar), dmg) + modmsg(msg_instant_death));
                                          //display_msg(parse_str_2(modmsg(msg_critical_hit_add_1_hp), obj_name(new_tar), dmg) + modmsg(msg_instant_death));
                                       end
                                       // instant death >1 hp dmg msg
                                       else begin
                                          display_msg(parse_str_2(modmsg(msg_hit_add), obj_name(new_tar), dmg) + modmsg(msg_instant_death));
                                          //display_msg(parse_str_2(modmsg(msg_critical_hit_add), obj_name(new_tar), dmg) + modmsg(msg_instant_death));
                                       end
                                    end
                                    if new_tar != orig_target then critter_heal(new_tar, -tar_cur_hp);
                                 end
                             end
                        end
                  end

      end
      if accumulated_experience > 1 andAlso attacker_team == TEAM_PLAYER then begin
         if Sonora <= 0 then begin
            accumulated_experience = accumulated_experience + get_combat_exp;
            set_combat_exp(accumulated_experience);
         end
      end
      reg_anim_end();

   call lvar_full_reset();
   end
   if one_time_call > 0 andAlso combat_is_initialized then begin
      one_time_call = 0;
      real_orig_target = 0;
   end
   if proj_pid_changed then begin
      call restore_weapon_proj_pid();
      real_orig_target = 0;
   end
   tile_refresh_display;
end

procedure laser_line_dmg(variable attacker,variable target) begin
   variable atkr_tile = tile_num(attacker);
   variable attacker_elev = elevation(attacker);
   variable rot_atk_to_tar = rotation_to_tile(atkr_tile, tile_num(target));
   variable crit_mult = 1;
   variable anim_frame = 0;
   variable new_tar;
   variable new_tar_critter_flags;
   variable new_tar_special_death;
   variable tar_cur_frm;
   variable anim_delay = -1;
   variable dmg;
   variable i;
   variable projectile;
   variable placeholder;
   variable timer;
   variable new_tar_tile;
   variable new_tar_cur_hp;
   variable start_tile = tile_num_in_direction(atkr_tile, rot_atk_to_tar, 1);
   foreach (new_tar in targets_array) begin
      targets_count += 1;
      if new_tar andAlso new_tar == target then begin
         i += 1;
         new_tar_tile = tile_num(new_tar);

         placeholder = create_object_sid(pid_laser_projectile, 0, attacker_elev, -1);
         set_obj_visibility(placeholder, 1);
         set_object_data(placeholder, OBJ_DATA_FID, obj_art_fid(attacker));


         projectile = create_object_sid(pid_laser_projectile, 0, attacker_elev, -1);
         anim(projectile, ANIMATE_ROTATION, rot_atk_to_tar);
         set_obj_visibility(projectile, 1);
         move_to(projectile, start_tile, attacker_elev);

         timer = create_object_sid(pid_laser_projectile, 0, attacker_elev, -1);
         set_obj_visibility(timer, 1);

         reg_anim_combat_check(0);
         reg_anim_func(REG_ANIM_BEGIN, RB_UNRESERVED);
         reg_anim_turn_towards(placeholder, new_tar_tile, -1);
         reg_anim_animate(placeholder, ANIM_point, -1);
         reg_anim_animate(placeholder, ANIM_fire_single, -1);
         reg_anim_animate(timer, ANIM_stand, 0);
         reg_anim_animate_and_move(projectile, new_tar_tile, ANIMATE_RUN, 0);
         reg_anim_destroy(projectile);
         reg_anim_animate(timer, anim_frame, -1);
         reg_anim_animate_reverse(timer, anim_frame, -1);
         reg_anim_animate(timer, anim_frame, -1);
         reg_anim_animate_reverse(timer, anim_frame, 4);
         reg_anim_destroy(timer);
         reg_anim_destroy(placeholder);
         reg_anim_callback(restore_weapon_proj_pid);
         reg_anim_callback(STDPROCEDURE);
         reg_anim_end();
         break;
      end
      if new_tar andAlso new_tar != target andAlso new_tar != attacker then begin
      tar_cur_frm = get_object_data(new_tar, OBJ_DATA_CUR_FRM);
            //animate if target is not in anim
            if tar_cur_frm == 0 then begin
               new_tar_critter_flags = get_proto_data(obj_pid(new_tar), PROTO_CR_FLAGS);
               new_tar_special_death = (new_tar_critter_flags bwand CFLG_SPECIAL);
               crit_power_roll = get_array(crit_roll_array, i);
               crit_mult = get_crit_mult(crit_power_roll,new_tar);
               dmg = round(get_array(dmg_array, i) * crit_mult);
               new_tar_cur_hp = get_critter_stat(new_tar, STAT_current_hp);
               i += 1;
               new_tar_tile = tile_num(new_tar);
               placeholder = create_object_sid(pid_laser_projectile, tile_num_in_direction(atkr_tile, rot_atk_to_tar+1, 3), attacker_elev, -1);
               set_obj_visibility(placeholder, 1);
               set_object_data(placeholder, OBJ_DATA_FID, obj_art_fid(attacker));

               projectile = create_object_sid(pid_laser_projectile, 0, attacker_elev, -1);
               anim(projectile, ANIMATE_SET_FRAME, 5);
               set_obj_visibility(projectile, 1);
               move_to(projectile, start_tile, attacker_elev);

               timer = create_object_sid(pid_laser_projectile, 0, attacker_elev, -1);
               set_obj_visibility(timer, 1);

               //miss animation
               if crit_power_roll < 0 or (new_tar_critter_flags bwand CFLG_INVULN) then begin
                  reg_anim_combat_check(0);
                  reg_anim_func(REG_ANIM_BEGIN, RB_UNRESERVED);
                  reg_anim_turn_towards(placeholder, new_tar_tile, -1);
                  reg_anim_animate(placeholder, ANIM_point, -1);
                  reg_anim_animate_and_move(projectile, new_tar_tile, ANIMATE_RUN, -1);
                  reg_anim_animate(new_tar, ANIM_dodge_anim, anim_delay);
                  reg_anim_play_sfx(new_tar,sfx_build_char_name(new_tar,ANIM_dodge_anim,snd_contact),0);
                  reg_anim_destroy(projectile);
                  reg_anim_destroy(timer);
                  reg_anim_destroy(placeholder);
                  reg_anim_end();
               end
               else begin
                  //hit animation start

                  if (new_tar_cur_hp - dmg) > 0 andAlso crit_power_roll <= 100 then begin
                     if crit_mult < 2 or dmg <= 0 or (new_tar_critter_flags bwand CFLG_NOKNOCKBACK) then begin
                        if is_hit_from_front(atkr_tile, new_tar) or not(art_exists_basic_anim(new_tar,ANIM_hit_from_back)) then begin
                           reg_anim_combat_check(0);
                           reg_anim_clear(new_tar);
                           reg_anim_func(REG_ANIM_BEGIN, RB_UNRESERVED);
                           reg_anim_turn_towards(placeholder, new_tar_tile, -1);
                           reg_anim_animate(placeholder, ANIM_point, -1);
                           reg_anim_animate_and_move(projectile, new_tar_tile, ANIMATE_RUN, -1);

                           reg_anim_animate(new_tar, ANIM_hit_from_front, anim_delay);
                           reg_anim_play_sfx(new_tar,sfx_build_char_name(new_tar,ANIM_hit_from_front,snd_contact),0);
                           reg_anim_destroy(projectile);
                           reg_anim_destroy(timer);
                           reg_anim_destroy(placeholder);
                           reg_anim_end();
                        end
                        else begin
                           reg_anim_combat_check(0);
                           reg_anim_clear(new_tar);
                           reg_anim_func(REG_ANIM_BEGIN, RB_UNRESERVED);
                           reg_anim_turn_towards(placeholder, new_tar_tile, -1);
                           reg_anim_animate(placeholder, ANIM_point, -1);
                           reg_anim_animate_and_move(projectile, new_tar_tile, ANIMATE_RUN, -1);
                           reg_anim_animate(new_tar, ANIM_hit_from_back, anim_delay);
                           reg_anim_play_sfx(new_tar,sfx_build_char_name(new_tar,ANIM_hit_from_back,snd_contact),0);
                           reg_anim_destroy(projectile);
                           reg_anim_destroy(timer);
                           reg_anim_destroy(placeholder);
                           reg_anim_end();
                        end
                     end
                     else begin
                        if is_hit_from_front(atkr_tile, new_tar) or (not(art_exists_death_anim(new_tar,ANIM_fall_front)) andAlso not(art_exists_basic_anim(new_tar,ANIM_fall_front)) andAlso not(art_exists_death_anim(new_tar,ANIM_fall_front_sf)) andAlso not(art_exists_basic_anim(new_tar,ANIM_fall_front_sf))) then begin
                           reg_anim_combat_check(0);
                           reg_anim_clear(new_tar);
                           reg_anim_func(REG_ANIM_BEGIN, RB_UNRESERVED);
                           reg_anim_turn_towards(placeholder, new_tar_tile, -1);
                           reg_anim_animate(placeholder, ANIM_point, -1);
                           reg_anim_animate_and_move(projectile, new_tar_tile, ANIMATE_RUN, -1);

                           reg_anim_animate(new_tar, ANIM_fall_back, anim_delay);
                           reg_anim_play_sfx(new_tar,sfx_build_char_name(new_tar,ANIM_fall_back,snd_knock_down),0);
                           reg_anim_destroy(projectile);
                           reg_anim_destroy(timer);
                           reg_anim_destroy(placeholder);
                           reg_anim_end();
                        end
                        else begin
                           reg_anim_combat_check(0);
                           reg_anim_clear(new_tar);
                           reg_anim_func(REG_ANIM_BEGIN, RB_UNRESERVED);
                           reg_anim_turn_towards(placeholder, new_tar_tile, -1);
                           reg_anim_animate(placeholder, ANIM_point, -1);
                           reg_anim_animate_and_move(projectile, new_tar_tile, ANIMATE_RUN, -1);

                           reg_anim_animate(new_tar, ANIM_fall_front, anim_delay);
                           reg_anim_play_sfx(new_tar,sfx_build_char_name(new_tar,ANIM_fall_front,snd_knock_down),0);
                           reg_anim_destroy(projectile);
                           reg_anim_destroy(timer);
                           reg_anim_destroy(placeholder);
                           reg_anim_end();
                        end
                     end
                     if crit_mult == 2 andAlso not(new_tar_critter_flags bwand CFLG_NOKNOCKBACK) then begin
                        critter_injure(new_tar, DAM_KNOCKED_DOWN);
                     end
                     if crit_mult == 3 andAlso not(new_tar_critter_flags bwand CFLG_NOKNOCKBACK) then begin
                        critter_injure(new_tar, DAM_KNOCKED_OUT);
                     end
                  end
                  //hit animation end

                  //death animation start
                  else begin
                  //non gore death
                       if dmg > 0 andAlso dmg < 30 andAlso not(bloody_mess) then begin
                           if is_hit_from_front(atkr_tile, new_tar) or (not(art_exists_death_anim(new_tar,ANIM_fall_front)) andAlso not(art_exists_basic_anim(new_tar,ANIM_fall_front)) andAlso not(art_exists_death_anim(new_tar,ANIM_fall_front_sf)) andAlso not(art_exists_basic_anim(new_tar,ANIM_fall_front_sf))) then begin
                              reg_anim_combat_check(0);
                              reg_anim_clear(new_tar);
                              reg_anim_func(REG_ANIM_BEGIN, RB_UNRESERVED);
                              reg_anim_turn_towards(placeholder, new_tar_tile, -1);
                              reg_anim_animate(placeholder, ANIM_point, -1);
                              reg_anim_animate_and_move(projectile, new_tar_tile, ANIMATE_RUN, -1);

                              reg_anim_animate(new_tar, ANIM_fall_back, anim_delay);
                              reg_anim_play_sfx(new_tar,sfx_build_char_name(new_tar,ANIM_fall_back,snd_knock_down),0);
                              reg_anim_destroy(projectile);
                              reg_anim_destroy(timer);
                              reg_anim_destroy(placeholder);
                              reg_anim_end();
                           end
                           else begin
                              reg_anim_combat_check(0);
                              reg_anim_clear(new_tar);
                              reg_anim_func(REG_ANIM_BEGIN, RB_UNRESERVED);
                              reg_anim_turn_towards(placeholder, new_tar_tile, -1);
                              reg_anim_animate(placeholder, ANIM_point, -1);
                              reg_anim_animate_and_move(projectile, new_tar_tile, ANIMATE_RUN, -1);

                              reg_anim_animate(new_tar, ANIM_fall_front, anim_delay);
                              reg_anim_play_sfx(new_tar,sfx_build_char_name(new_tar,ANIM_fall_front,snd_knock_down),0);
                              reg_anim_destroy(projectile);
                              reg_anim_destroy(timer);
                              reg_anim_destroy(placeholder);
                              reg_anim_end();
                           end
                        end
                        if dmg >= 30 or bloody_mess then begin
                           // if obj dont have ANIM_sliced_in_half death anim then
                            if (not(art_exists_death_anim(new_tar,ANIM_sliced_in_half)) andAlso not(art_exists_basic_anim(new_tar,ANIM_sliced_in_half)) andAlso not(art_exists_death_anim(new_tar,ANIM_sliced_in_half_sf)) andAlso not(art_exists_basic_anim(new_tar,ANIM_sliced_in_half_sf))) then begin
                              //critter is not the Horrigan
                              if obj_pid(new_tar) != PID_END_BOSS then begin
                                 if is_hit_from_front(atkr_tile, new_tar) or (not(art_exists_death_anim(new_tar,ANIM_fall_front)) andAlso not(art_exists_basic_anim(new_tar,ANIM_fall_front)) andAlso not(art_exists_death_anim(new_tar,ANIM_fall_front_sf)) andAlso not(art_exists_basic_anim(new_tar,ANIM_fall_front_sf))) then begin
                                    reg_anim_combat_check(0);
                                    reg_anim_clear(new_tar);
                                    reg_anim_func(REG_ANIM_BEGIN, RB_UNRESERVED);
                                    reg_anim_turn_towards(placeholder, new_tar_tile, -1);
                                    reg_anim_animate(placeholder, ANIM_point, -1);
                                    reg_anim_animate_and_move(projectile, new_tar_tile, ANIMATE_RUN, -1);

                                    reg_anim_animate(new_tar, ANIM_fall_back, anim_delay);
                                    reg_anim_play_sfx(new_tar,sfx_build_char_name(new_tar,ANIM_fall_back,snd_knock_down),0);
                                    reg_anim_destroy(projectile);
                                    reg_anim_destroy(timer);
                                    reg_anim_destroy(placeholder);
                                    reg_anim_end();
                                 end
                                 else begin
                                    reg_anim_combat_check(0);
                                    reg_anim_clear(new_tar);
                                    reg_anim_func(REG_ANIM_BEGIN, RB_UNRESERVED);
                                    reg_anim_turn_towards(placeholder, new_tar_tile, -1);
                                    reg_anim_animate(placeholder, ANIM_point, -1);
                                    reg_anim_animate_and_move(projectile, new_tar_tile, ANIMATE_RUN, -1);

                                    reg_anim_animate(new_tar, ANIM_fall_front, anim_delay);
                                    reg_anim_play_sfx(new_tar,sfx_build_char_name(new_tar,ANIM_fall_front,snd_knock_down),0);
                                    reg_anim_destroy(projectile);
                                    reg_anim_destroy(timer);
                                    reg_anim_destroy(placeholder);
                                    reg_anim_end();
                                 end
                              end
                              // horrigan death
                              else begin
                                 reg_anim_combat_check(0);
                                 reg_anim_clear(new_tar);
                                 reg_anim_func(REG_ANIM_BEGIN, RB_UNRESERVED);
                                 reg_anim_turn_towards(placeholder, new_tar_tile, -1);
                                 reg_anim_animate(placeholder, ANIM_point, -1);
                                 reg_anim_animate_and_move(projectile, new_tar_tile, ANIMATE_RUN, -1);
                                 reg_anim_animate(new_tar, ANIM_exploded_to_nothing, anim_delay);
                                 reg_anim_play_sfx(new_tar,sfx_build_char_name(new_tar,ANIM_exploded_to_nothing,snd_die),0);
                                 reg_anim_destroy(projectile);
                                 reg_anim_destroy(timer);
                                 reg_anim_destroy(placeholder);
                                 reg_anim_end();
                              end
                           end
                           else begin
                              reg_anim_combat_check(0);
                              reg_anim_clear(new_tar);
                              reg_anim_func(REG_ANIM_BEGIN, RB_UNRESERVED);
                              reg_anim_turn_towards(placeholder, new_tar_tile, -1);
                              reg_anim_animate(placeholder, ANIM_point, -1);
                              reg_anim_animate_and_move(projectile, new_tar_tile, ANIMATE_RUN, -1);
                              reg_anim_animate(new_tar, ANIM_sliced_in_half, anim_delay);
                              reg_anim_play_sfx(new_tar,sfx_build_char_name(new_tar,ANIM_sliced_in_half,snd_die),0);
                              reg_anim_destroy(projectile);
                              reg_anim_destroy(timer);
                              reg_anim_destroy(placeholder);
                              reg_anim_end();
                           end
                        end
                     end
                  end
            end
            else begin
               i += 1;
            end
         end
      end

end

procedure gauss_line_dmg(variable attacker,variable target) begin
   variable new_tar;
   variable new_tar_critter_flags;
   variable new_tar_special_death;
   variable tar_cur_frm;
   variable i = 0;
   variable anim_delay = 0;
   variable dmg;
   variable crit_mult = 1;
   variable new_tar_cur_hp;
   variable atkr_tile = tile_num(attacker);
   variable placeholder;
   placeholder = create_object_sid(pid_laser_projectile, 0, elevation(attacker), -1);
   set_obj_visibility(placeholder, 1);
   set_object_data(placeholder, OBJ_DATA_FID, obj_art_fid(attacker));

   reg_anim_combat_check(0);
   reg_anim_func(REG_ANIM_BEGIN, RB_UNRESERVED);
   reg_anim_turn_towards(placeholder, tile_num(target), -1);
   reg_anim_animate(placeholder, ANIM_point, -1);
   reg_anim_animate(placeholder, ANIM_fire_single, -1);

   foreach (new_tar in targets_array) begin
      if new_tar andAlso new_tar == target then begin
         targets_count += 1;
         i += 1;
      end
      if new_tar andAlso new_tar != target andAlso new_tar != attacker then begin
      tar_cur_frm = get_object_data(new_tar, OBJ_DATA_CUR_FRM);
      crit_power_roll = get_array(crit_roll_array, i);
      crit_mult = get_crit_mult(crit_power_roll,new_tar);
      dmg = round(get_array(dmg_array, i) * crit_mult);
      targets_count += 1;
      i += 1;
         if tar_cur_frm == 0 andAlso dmg > 0 then begin
            new_tar_critter_flags = get_proto_data(obj_pid(new_tar), PROTO_CR_FLAGS);
            new_tar_special_death = (new_tar_critter_flags bwand CFLG_SPECIAL);
            new_tar_cur_hp = get_critter_stat(new_tar, STAT_current_hp);
            //miss animation
            if crit_power_roll < 0 or (new_tar_critter_flags bwand CFLG_INVULN) then begin
               reg_anim_animate(new_tar, ANIM_dodge_anim, anim_delay);
               reg_anim_play_sfx(new_tar,sfx_build_char_name(new_tar,ANIM_dodge_anim,snd_contact),0);
            end
            else begin
              //hit animation start
               if new_tar_cur_hp - dmg > 0 andAlso crit_power_roll <= 100 then begin
                  if crit_mult < 2 or (new_tar_critter_flags bwand CFLG_NOKNOCKBACK) then begin
                     if is_hit_from_front(atkr_tile, new_tar) or not(art_exists_basic_anim(new_tar,ANIM_hit_from_back)) then begin
                        reg_anim_animate(new_tar, ANIM_hit_from_front, anim_delay);
                        reg_anim_play_sfx(new_tar,sfx_build_char_name(new_tar,ANIM_hit_from_front,snd_contact),0);
                     end
                     else begin
                        reg_anim_animate(new_tar, ANIM_hit_from_back, anim_delay);
                        reg_anim_play_sfx(new_tar,sfx_build_char_name(new_tar,ANIM_hit_from_back,snd_contact),0);
                     end
                  end
                  else begin
                     if is_hit_from_front(atkr_tile, new_tar) or (not(art_exists_death_anim(new_tar,ANIM_fall_front)) andAlso not(art_exists_basic_anim(new_tar,ANIM_fall_front)) andAlso not(art_exists_death_anim(new_tar,ANIM_fall_front_sf)) andAlso not(art_exists_basic_anim(new_tar,ANIM_fall_front_sf))) then begin
                        reg_anim_animate(new_tar, ANIM_fall_back, anim_delay);
                        reg_anim_play_sfx(new_tar,sfx_build_char_name(new_tar,ANIM_fall_back,snd_knock_down),0);
                     end
                     else begin
                        reg_anim_animate(new_tar, ANIM_fall_front, anim_delay);
                        reg_anim_play_sfx(new_tar,sfx_build_char_name(new_tar,ANIM_fall_front,snd_knock_down),0);
                     end
                  end
                  if crit_mult == 2 andAlso not(new_tar_critter_flags bwand CFLG_NOKNOCKBACK) then begin
                     critter_injure(new_tar, DAM_KNOCKED_DOWN);
                  end
                  if crit_mult == 3 andAlso not(new_tar_critter_flags bwand CFLG_NOKNOCKBACK) then begin
                     critter_injure(new_tar, DAM_KNOCKED_OUT);
                  end
               end
               //hit animation end

               //death animation start
               else begin
                  //low dmg start
                  if dmg <= 30 andAlso not(bloody_mess) then begin
                     if is_hit_from_front(atkr_tile, new_tar) or (not(art_exists_death_anim(new_tar,ANIM_fall_front)) andAlso not(art_exists_basic_anim(new_tar,ANIM_fall_front)) andAlso not(art_exists_death_anim(new_tar,ANIM_fall_front_sf)) andAlso not(art_exists_basic_anim(new_tar,ANIM_fall_front_sf))) then begin
                        reg_anim_animate(new_tar, ANIM_fall_back, anim_delay);
                        reg_anim_play_sfx(new_tar,sfx_build_char_name(new_tar,ANIM_fall_back,snd_knock_down),0);
                     end
                     else begin
                        reg_anim_animate(new_tar, ANIM_fall_front, anim_delay);
                        reg_anim_play_sfx(new_tar,sfx_build_char_name(new_tar,ANIM_fall_front,snd_knock_down),0);
                     end
                  end
                  //low dmg end

                  //dmg > 30 and <= 60 start
                  else if dmg <= 60 or (bloody_mess andAlso dmg <= 50) then begin
                     // if obj dont have big_hole death anim then
                     if is_hit_from_front(atkr_tile, new_tar) or (not(art_exists_death_anim(new_tar,ANIM_big_hole)) andAlso not(art_exists_basic_anim(new_tar,ANIM_big_hole)) andAlso not(art_exists_death_anim(new_tar,ANIM_big_hole_sf)) andAlso not(art_exists_basic_anim(new_tar,ANIM_big_hole_sf))) then begin
                        if obj_pid(new_tar) != PID_END_BOSS then begin
                           reg_anim_animate(new_tar, ANIM_fall_back, anim_delay);
                           reg_anim_play_sfx(new_tar,sfx_build_char_name(new_tar,ANIM_fall_back,snd_die),0);
                        end
                        else begin
                           reg_anim_animate(new_tar, ANIM_exploded_to_nothing, anim_delay);
                           reg_anim_play_sfx(new_tar,sfx_build_char_name(new_tar,ANIM_exploded_to_nothing,snd_die),0);
                        end
                     end
                     else begin
                        if random(0,4) or (not(art_exists_death_anim(new_tar,ANIM_exploded_to_nothing)) andAlso not(art_exists_basic_anim(new_tar,ANIM_exploded_to_nothing)) andAlso not(art_exists_death_anim(new_tar,ANIM_exploded_to_nothing_sf)) andAlso not(art_exists_basic_anim(new_tar,ANIM_exploded_to_nothing_sf))) then begin
                           reg_anim_animate(new_tar, ANIM_big_hole, anim_delay);
                           reg_anim_play_sfx(new_tar,sfx_build_char_name(new_tar,ANIM_big_hole,snd_die),0);
                        end
                        else begin
                           reg_anim_animate(new_tar, ANIM_exploded_to_nothing, anim_delay);
                           reg_anim_play_sfx(new_tar,sfx_build_char_name(new_tar,ANIM_exploded_to_nothing,snd_die),0);
                        end
                     end
                  end
                  //dmg > 30 and <= 60 end

                  //dmg > 60 start
                  else if dmg > 60 or (bloody_mess andAlso dmg > 50) then begin
                     // if obj dont have explode death anim then
                     if (new_tar_cur_hp < (dmg / 2)) or (not(art_exists_death_anim(new_tar,ANIM_exploded_to_nothing)) andAlso not(art_exists_basic_anim(new_tar,ANIM_exploded_to_nothing)) andAlso not(art_exists_death_anim(new_tar,ANIM_exploded_to_nothing_sf)) andAlso not(art_exists_basic_anim(new_tar,ANIM_exploded_to_nothing_sf))) then begin
                        // if obj dont have big_hole death anim then
                        if (not(art_exists_death_anim(new_tar,ANIM_big_hole)) andAlso not(art_exists_basic_anim(new_tar,ANIM_big_hole)) andAlso not(art_exists_death_anim(new_tar,ANIM_big_hole_sf)) andAlso not(art_exists_basic_anim(new_tar,ANIM_big_hole_sf))) then begin
                            if obj_pid(new_tar) != PID_END_BOSS then begin
                              reg_anim_animate(new_tar, ANIM_fall_back, anim_delay);
                              reg_anim_play_sfx(new_tar,sfx_build_char_name(new_tar,ANIM_fall_back,snd_die),0);
                           end
                           else begin
                              reg_anim_animate(new_tar, ANIM_exploded_to_nothing, anim_delay);
                              reg_anim_play_sfx(new_tar,sfx_build_char_name(new_tar,ANIM_exploded_to_nothing,snd_die),0);
                           end
                        end
                        else begin
                           reg_anim_animate(new_tar, ANIM_big_hole, anim_delay);
                           reg_anim_play_sfx(new_tar,sfx_build_char_name(new_tar,ANIM_big_hole,snd_die),0);
                        end
                     end
                     else begin
                        reg_anim_animate(new_tar, ANIM_exploded_to_nothing, anim_delay);
                        reg_anim_play_sfx(new_tar,sfx_build_char_name(new_tar,ANIM_exploded_to_nothing,snd_die),0);
                     end
                  end
                  //dmg 60 end
               end
               //death animation end

            end
         end
      end
   end
   reg_anim_destroy(placeholder);
   reg_anim_callback(restore_weapon_proj_pid);
   reg_anim_callback(STDPROCEDURE);
   reg_anim_end();
end

procedure plasma_alt_explosion begin
   variable attacker = orig_attacker;
   variable target_elevation = elevation(orig_target);
   variable tar_tile = tile_num(orig_target);
   variable target_rot_to_attacker = rotation_to_tile(tar_tile, tile_num(attacker));
   variable test_tile;
   variable target_dt;
   variable target_dr;
   variable critter_team = -5;
   variable blast_radius = PlasmaBlastRadius;
   variable new_tar_dmg_mult;
   variable array_critters_in_radius = objects_in_radius(tar_tile,blast_radius, target_elevation, OBJ_TYPE_CRITTER);
   variable new_tar;
   variable new_tar_tile;
   variable new_tar_cur_hp;
   variable distance;
   variable exlposion;
   variable pid = 0x500001D;
   variable sfx = "WHS1FXX1";
   variable attacker_lu = get_critter_stat(attacker, STAT_lu);
   variable critical_chance = get_critter_stat(attacker, STAT_crit_chance);
   variable crit_mult = 1;
   variable crit_roll;
   variable dmg;
   variable party = party_member_list(0);
   variable dead_attacker;
   variable new_tar_count;
   variable tar_is_critter = is_critter(orig_target);
   variable blocking;
   variable last_block;
   variable is_blocked;
   variable count;
   variable dmg_to_attacker = -1;
   variable animate = true;
   variable flags = animate;
   if tar_is_critter <= 0 then test_tile = tile_num_in_direction(tar_tile,target_rot_to_attacker,1);
   combat_dmg = get_object_data(combat_data, C_ATTACK_DAMAGE_TARGET);
   exlposion = create_object(pid, tar_tile, target_elevation);
   reg_anim_combat_check(0);
   reg_anim_begin();
   reg_anim_animate(exlposion,0, 0);
   if (weapon_anim == WPN_ANIM_RIFLE) or (weapon_anim == WPN_ANIM_BIG_GUN) then begin
      reg_anim_animate_reverse(exlposion,0, 2);
   end
   else begin
      reg_anim_animate_reverse(exlposion,0, 0);
   end
   reg_anim_play_sfx(exlposion,sfx, 0);
   reg_anim_destroy(exlposion);
   reg_anim_end();
   if show_float_dmg > 0 andAlso orig_target > 0 andAlso obj_type(orig_target) == OBJ_TYPE_CRITTER then begin
      if combat_dmg > 0 then begin
         float_msg(orig_target,"-"+combat_dmg, 2);
      end
      else begin
         float_msg(orig_target,"0", 2);
      end
   end
   foreach new_tar in array_critters_in_radius begin
      if new_tar <= 0 then
         continue;
      new_tar_cur_hp = get_critter_stat(new_tar, STAT_current_hp);
      if new_tar != orig_target andAlso new_tar != dead_attacker andAlso new_tar_cur_hp > 0 andAlso not(is_dead(new_tar)) andAlso obj_is_visible_flag(new_tar) then begin
         //BLOCKING_TYPE_SHOOT check
         new_tar_tile = tile_num(new_tar);
         blocking = obj_blocking_line(orig_target, new_tar_tile, BLOCKING_TYPE_SHOOT);
         if blocking != new_tar then begin
            is_blocked = 1;
            if (ShootThru(blocking)) then begin
               for (count := 0; count <= (blast_radius + 2); count++) begin
                  last_block = blocking;
                  blocking = obj_blocking_line(last_block, new_tar_tile, BLOCKING_TYPE_SHOOT);
                  if blocking == new_tar then begin
                     is_blocked = 0;
                     break;
                  end
               end
            end
            if is_blocked then continue;
         end
         //BLOCKING_TYPE_SHOOT check if hit Scenery
         if tar_is_critter <= 0 then begin
            blocking = obj_blocking_line(new_tar, test_tile, BLOCKING_TYPE_SHOOT);
            if blocking then begin
               is_blocked = 1;
               if (ShootThru(blocking)) then begin
                  for (count := 0; count <= (blast_radius + 2); count++) begin
                     last_block = blocking;
                     blocking = obj_blocking_line(last_block, test_tile, BLOCKING_TYPE_SHOOT);
                     if blocking == last_block or blocking <= 0 then begin
                        is_blocked = 0;
                        break;
                     end
                  end
               end
               if is_blocked then continue;
            end
         end
         if new_tar <= 0 then
            continue;
         new_tar_dmg_mult = PlasmaDamagePercentage + 0.1;
         distance = 0;
         //new_tar_pid = obj_pid(new_tar);
         target_dt = get_critter_stat(new_tar,STAT_dmg_thresh_plasma);
         target_dr = get_critter_stat(new_tar,STAT_dmg_resist_plasma);
         if weapon_perk == PERK_weapon_penetrate then begin
            target_dt = target_dt * 0.2;
            //target_dr = target_dr * 0.8;
         end
         critter_team = has_trait(TRAIT_OBJECT, new_tar, OBJECT_TEAM_NUM);
         //Increase target_dr if it attacker has TRAIT_finesse
         if finesse then begin
            target_dr = target_dr + 30;
         end
         if target_dr > 90 then target_dr = 90;
         crit_roll = random(1, 100);
         flags = animate;
         //add ini setting to engable|disable crit dmg and finess trait
         if allow_critical > 0 andAlso(crit_roll <= critical_chance or (sniper andAlso random(1,10) <= attacker_lu)) then begin
            crit_power_roll = random(1, (100 + bonus_crit_power_roll));
            crit_mult = get_crit_mult(crit_power_roll,new_tar);

            flags = animate bwor DAM_CRITICAL;
            if crit_mult < 2 then begin
               target_dt = target_dt * 0.75;
               target_dr = target_dr * 0.75;
            end
            else begin
               //KO check
               if random(0,1) then begin
                  flags = animate bwor DAM_KNOCKED_DOWN;
               end
               target_dt = target_dt * 0.4;
               target_dr = target_dr * 0.4;
            end
         end
         if crit_mult > 2 then crit_mult = 2;
         if new_tar_dmg_mult andAlso new_tar_dmg_mult < 1 then begin
            distance_objs(distance, orig_target, new_tar);
            if distance > 1 then new_tar_dmg_mult = (new_tar_dmg_mult ^ (distance));
            if new_tar_dmg_mult < 0 then new_tar_dmg_mult = 0;
         end
         dmg = living_anatomy_bonus * living_anatomy + round((((random(weapon_min_dmg, weapon_max_dmg) - target_dt) * (100 - target_dr) / 100.0)) * new_tar_dmg_mult * crit_mult);
         if dmg < 0 then dmg = 0;
         //on a successful hit, the target becomes hostile
         if critter_team == TEAM_PLAYER then begin
            //on a successful damaging hit, a friendly(non-campanion) target with low health has a 25% chance to become hostile
            if dmg > 5 andAlso new_tar_cur_hp > dmg andAlso new_tar_cur_hp / 2 < dmg andAlso not(random(0,3)) andAlso not(is_in_array(new_tar, party)) then attack_setup(new_tar, attacker);
         end
         else begin
            //on a successful hit, a non-friendly target has a 66% chance to become hostile
            if random(0,2) then attack_setup(new_tar, attacker);
         end
         if new_tar == attacker andAlso dmg >= 0 then begin
            dmg_to_attacker = dmg;
         end
         if new_tar != attacker andAlso new_tar != orig_target then begin
            call critter_inflict_dmg(new_tar, attacker, dmg, DMG_plasma, flags, tar_tile);
            //critter_dmg(new_tar, dmg, (DMG_plasma bwor DMG_BYPASS_ARMOR));
            new_tar_count += 1;
         end
         if show_float_dmg > 0 andAlso new_tar != orig_target andAlso new_tar > 0 then begin
            if dmg > 0 then begin
               float_msg(new_tar,"-"+dmg, 2);
            end
            else begin
               float_msg(new_tar,"0", 2);
            end
         end
         new_tar = 0;
      end
   end
   if dmg_to_attacker >= 0 then begin
      if get_critter_stat(attacker, STAT_current_hp) > dmg_to_attacker then begin
         critter_heal(attacker, - dmg_to_attacker);
      end
      else begin
         set_obj_visibility(attacker, 1);
         dead_attacker = create_object_sid(obj_pid(attacker), tile_num(attacker), target_elevation, -1);
         anim(dead_attacker, ANIMATE_ROTATION, has_trait(TRAIT_OBJECT, attacker, OBJECT_CUR_ROT));
         set_object_data(dead_attacker, OBJ_DATA_FID, obj_art_fid(attacker));
         critter_heal(dead_attacker, -(get_critter_stat(dead_attacker, STAT_current_hp)-1));
         //critter_dmg(dead_attacker, dmg_to_attacker, (DMG_plasma bwor DMG_BYPASS_ARMOR));
         call critter_inflict_dmg(dead_attacker, attacker, dmg_to_attacker, DMG_plasma, 1, tar_tile);
         if attacker == dude_obj then begin
            call kill_dude in 1;
         end
         else begin
            critter_heal(attacker, - dmg_to_attacker);
            move_obj_inven_to_obj(attacker, dead_attacker);
         end
      end
   end
end

procedure plasma_aoe_dmg(variable attacker,variable target) begin
   variable attacker_tile = tile_num(attacker);
   variable attacker_elev = elevation(attacker);
   variable target_tile = tile_num(target);
   variable rot_atk_to_tar = rotation_to_tile(attacker_tile, target_tile);
   variable start_tile = tile_num_in_direction(attacker_tile, rot_atk_to_tar, 1);
   variable projectile;
   variable timer;
   variable placeholder;
   orig_target = target;
   placeholder = create_object_sid(pid_laser_projectile, 0, attacker_elev, -1);
   set_obj_visibility(placeholder, 1);
   set_object_data(placeholder, OBJ_DATA_FID, obj_art_fid(attacker));


   projectile = create_object_sid(pid_plasma_big_projectile, 0, attacker_elev, -1);
   anim(projectile, ANIMATE_ROTATION, rot_atk_to_tar);
   set_obj_visibility(projectile, 1);
   move_to(projectile, start_tile, attacker_elev);


   timer = create_object_sid(pid_plasma_big_projectile, 0, attacker_elev, -1);
   set_obj_visibility(timer, 1);

   reg_anim_combat_check(0);
   reg_anim_func(REG_ANIM_BEGIN, RB_UNRESERVED);
   reg_anim_turn_towards(placeholder, target_tile, -1);
   reg_anim_animate(placeholder, ANIM_point, -1);
   reg_anim_animate(placeholder, ANIM_fire_single, -1);
   reg_anim_animate(timer, ANIM_stand, 0);
   reg_anim_animate_and_move(projectile, target_tile, ANIMATE_RUN, 0);
   reg_anim_callback(plasma_alt_explosion);
   if placeholder then reg_anim_destroy(placeholder);
   if projectile then reg_anim_destroy(projectile);
   if timer then reg_anim_destroy(timer);
   reg_anim_callback(restore_weapon_proj_pid);
   reg_anim_callback(STDPROCEDURE);
   reg_anim_callback(lvar_full_reset);
   reg_anim_end();
end

procedure callback_refresh_outline begin
   variable critter;
   variable cursor = get_cursor_mode;
   variable not_cursor = cursor - 1;
   foreach critter in targets_array begin
      if get_outline(critter) > 0 then begin
         set_outline(critter, OUTLINE_NONE);
      end
   end
   set_outline(orig_target, OUTLINE_NONE);
   if orig_attacker == dude_obj then begin
      set_outline(orig_attacker, OUTLINE_NONE);
      if not_cursor < 0 then not_cursor = 2;
      set_cursor_mode(not_cursor);
      set_cursor_mode(cursor);
   end
   else begin
      if has_trait(TRAIT_OBJECT, orig_attacker, OBJECT_TEAM_NUM) == TEAM_PLAYER then begin
         set_outline(orig_attacker, OUTLINE_GREEN_GLOW);
      end
      else begin
         set_outline(orig_attacker, OUTLINE_RED_GLOW);
      end
   end
   tile_refresh_display;
end

procedure callback_make_obj_visible begin
   if obj_make_visible > 0 then begin
      set_obj_visibility(obj_make_visible, 0);
      obj_make_visible = 0;
   end
end

procedure callback_electrical_chain_show_orig_target_dmg begin
   variable target = orig_target;
   variable target_cur_hp;
   variable target_team;
   variable emp_expl;
   if target > 0 andAlso obj_type(target) == OBJ_TYPE_CRITTER then begin
      combat_dmg = get_object_data(combat_data, C_ATTACK_DAMAGE_TARGET);
      if show_float_dmg > 0 then begin
         if combat_dmg > 0 then begin
            float_msg(target, "-"+combat_dmg, 2);
         end
         else begin
            float_msg(target, "0", 2);
         end
      end
      set_outline(target, OUTLINE_BLINKING_CYAN);
      if old_emp_expl > 0 then begin
         emp_expl = create_object_sid(pid_emp_expl, tile_num(target), elevation(target), -1);
         set_outline(emp_expl, OUTLINE_BLINKING_CYAN);
         reg_anim_combat_check(0);
         reg_anim_begin();
         reg_anim_animate_and_hide(emp_expl, ANIM_stand, -1);
         reg_anim_destroy(emp_expl);
         reg_anim_end();
      end
   end
end

procedure callback_electrical_chain_dmg begin
   variable target = get_array(targets_array,elec_tar_num);
   variable target_cur_hp;
   variable target_team;
   variable attacker_team;
   variable dmg;
   variable dead_attacker;
   variable emp_expl;
   variable flags;
   if target > 0 andAlso obj_type(target) == OBJ_TYPE_CRITTER then begin
      target_cur_hp = get_critter_stat(target, STAT_current_hp);
      target_team = has_trait(TRAIT_OBJECT, target, OBJECT_TEAM_NUM);
      attacker_team = has_trait(TRAIT_OBJECT, orig_attacker, OBJECT_TEAM_NUM);
      dmg = get_array(dmg_array,elec_tar_num);
      flags = dmg / DAM_FLAGS_MULT;
      dmg = dmg % DAM_FLAGS_MULT;
      set_outline(target, OUTLINE_BLINKING_CYAN);
      if orig_attacker != dude_obj andAlso attacker_team == target_team then begin
         dmg = random((dmg / 3), ((2 * dmg) / 3));
      end
         if living_anatomy > 0 andAlso dmg < living_anatomy * living_anatomy_bonus then begin
            dmg = living_anatomy * living_anatomy_bonus;
         end
      if target != orig_attacker orElse target_cur_hp > dmg then begin
         if random(0,1) then begin
            call critter_inflict_dmg(target, orig_attacker, dmg, DMG_emp, flags, tile_num(target));
         end
         else begin
            call critter_inflict_dmg(target, orig_attacker, dmg, DMG_electrical, flags, tile_num(target));
         end
      end
      //deadly dmg
      else begin
         set_obj_visibility(target, 1);
         dead_attacker = create_object_sid(obj_pid(target), tile_num(target), elevation(target), -1);
         anim(dead_attacker, ANIMATE_ROTATION, has_trait(TRAIT_OBJECT, target, OBJECT_CUR_ROT));
         set_object_data(dead_attacker, OBJ_DATA_FID, obj_art_fid(target));
         critter_heal(dead_attacker, -(get_critter_stat(dead_attacker, STAT_current_hp)-1));
         call critter_inflict_dmg(dead_attacker, target, dmg, DMG_electrical, 1, tile_num(orig_target));
         if target == dude_obj then begin
            call kill_dude in 2;
         end
         else begin
            critter_heal(target, -dmg);
            move_obj_inven_to_obj(target, dead_attacker);
         end
      end
      if show_float_dmg > 0 then begin
         if dmg > 0 then begin
            float_msg(target, "-"+dmg, 2);
         end
         else begin
            float_msg(target, "0", 2);
         end
      end
      if old_emp_expl > 0 then begin
         emp_expl = create_object_sid(pid_emp_expl, tile_num(target), elevation(target), -1);
         set_outline(emp_expl, OUTLINE_BLINKING_CYAN);
         reg_anim_combat_check(0);
         reg_anim_begin();
         reg_anim_animate_and_hide(emp_expl, ANIM_stand, -1);
         reg_anim_destroy(emp_expl);
         reg_anim_end();
      end
   end
   elec_tar_num += 1;
end

procedure electrical_chain_dmg(variable attacker,variable target) begin
   variable attacker_tile;
   variable target_tile;
   variable attacker_elev;
   variable rot_atk_to_tar;
   variable start_tile;
   variable distance;
   variable distance_closest;
   variable new_tar;
   variable new_tar_array;
   variable new_tar_array_len;
   variable projectile;
   variable timer;
   variable last_tar;
   variable last_tar_tile;
   variable rnd_tar;
   variable rnd_tar_dmg;
   variable targets_array_key = -1;
   variable i;
   variable placeholder;
   if target <= 0 orElse obj_type(target) != OBJ_TYPE_CRITTER then begin
      call restore_weapon_proj_pid();
      call lvar_full_reset();
      return;
   end
   attacker_tile = tile_num(attacker);
   target_tile = tile_num(target);
   attacker_elev = elevation(attacker);
   rot_atk_to_tar = rotation_to_tile(attacker_tile, target_tile);
   start_tile = tile_num_in_direction(attacker_tile, rot_atk_to_tar, 1);
   new_tar_array = create_array_map;
   targets_array = create_array_map;
   dmg_array = create_array_map;
   crit_roll_array = create_array_map;
   orig_target = target;
   last_tar = target;
   last_tar_tile = target_tile;

   for (i = 0; i < ElecMaxTargets; i++) begin
      distance_closest = ElecRadius;
      // get next rnd target
      foreach new_tar in objects_in_radius(last_tar_tile,ElecRadius,attacker_elev,OBJ_TYPE_CRITTER) begin
         if new_tar != target then begin
            distance_objs(distance,last_tar,new_tar);
            if distance <= distance_closest then begin
               if get_critter_stat(new_tar, STAT_current_hp) > 0 andAlso not(is_in_array(new_tar,targets_array)) andAlso obj_is_visible_flag(new_tar) then begin
                  if not(check_block_shoot(new_tar, last_tar)) then begin
                     continue;
                  end
                  else begin
                     if distance == distance_closest then begin
                        set_array(new_tar_array, len_array(new_tar_array),new_tar);
                     end
                     else if distance < distance_closest then begin
                        clear_array(new_tar_array);
                        distance_closest = distance;
                        set_array(new_tar_array, len_array(new_tar_array),new_tar);
                     end
                  end
               end
            end
            else begin
               continue;
            end
         end
      end

      new_tar_array_len = len_array(new_tar_array) - 1;
      //get random target
      if new_tar_array_len >= 0 then begin
         rnd_tar = get_array(new_tar_array, random(0, new_tar_array_len));
         last_tar = rnd_tar;
         last_tar_tile = tile_num(rnd_tar);
         clear_array(new_tar_array);
         targets_array_key = len_array(targets_array);
         set_array(targets_array, targets_array_key, rnd_tar);
         rnd_tar_dmg = calc_dmg_electric(attacker, rnd_tar);
         //rnd_tar_dmg = round(rnd_tar_dmg * get_crit_mult(crit_power_roll,rnd_tar));
         set_array(dmg_array, targets_array_key, rnd_tar_dmg);
         if rnd_tar_dmg <= 0 then break;
      end
      //exit the loop if there are no more suitable targets
      else begin
         break;
      end
   end
   free_array(new_tar_array);

   elec_tar_num = 0;
   placeholder = create_object_sid(pid_laser_projectile, 0, attacker_elev, -1);
   set_obj_visibility(placeholder, 1);
   set_object_data(placeholder, OBJ_DATA_FID, obj_art_fid(attacker));


   projectile = create_object_sid(pid_electric_projectile, 0, attacker_elev, -1);
   anim(projectile, ANIMATE_ROTATION, rot_atk_to_tar);
   set_obj_visibility(projectile, 1);
   obj_make_visible = projectile;
   //set_object_data(projectile, OBJ_DATA_FID, get_proto_data(PID_BLOCKING_HEX, PROTO_FID));
   set_outline(projectile, OUTLINE_BLINKING_CYAN);


   timer = create_object_sid(pid_plasma_big_projectile, 0, attacker_elev, -1);
   set_obj_visibility(timer, 1);

   reg_anim_combat_check(0);
   reg_anim_func(REG_ANIM_BEGIN, RB_UNRESERVED);
   reg_anim_turn_towards(placeholder, target_tile, -1);
   reg_anim_animate(placeholder, ANIM_point, -1);
   reg_anim_callback(callback_make_obj_visible);
   reg_anim_animate(placeholder, ANIM_fire_single, -1);
   //reg_anim_change_fid(projectile, get_proto_data(pid_electric_projectile, PROTO_FID), 0);
   reg_anim_animate(timer, ANIM_stand, 0);
   reg_anim_animate_and_move(projectile, target_tile, ANIMATE_RUN, 0);
   reg_anim_callback(callback_electrical_chain_show_orig_target_dmg);
   if targets_array_key >= 0 then begin
      foreach new_tar in targets_array begin
         reg_anim_turn_towards(projectile, tile_num(new_tar),-1);
         reg_anim_animate_and_move(projectile, tile_num(new_tar), ANIMATE_WALK, -1);
         reg_anim_callback(callback_electrical_chain_dmg);
      end
   end
   reg_anim_callback(restore_weapon_proj_pid);
   reg_anim_animate_reverse(timer, ANIM_stand, -1);
   reg_anim_animate(timer, ANIM_stand, -1);
   reg_anim_callback(callback_refresh_outline);
   if placeholder then reg_anim_destroy(placeholder);
   if projectile then reg_anim_destroy(projectile);
   reg_anim_callback(lvar_full_reset);
   reg_anim_end();
   move_to(projectile, start_tile, attacker_elev);
end

procedure get_dude_worn_armor_perk begin
   variable dude_armor = critter_inven_obj(dude_obj, INVEN_TYPE_WORN);
   variable armor_perk;
   if dude_armor > 0 then armor_perk = get_proto_data(obj_pid(dude_armor), PROTO_AR_PERK);
   return armor_perk;
end

procedure player_wearing_power_armor begin
   variable armor_perk = get_dude_worn_armor_perk;
   if armor_perk == PERK_armor_powered or armor_perk == PERK_armor_advanced_1 or armor_perk == PERK_armor_advanced_2 then begin
      return true;
   end
   else begin
      return false;
   end
end

procedure MOVECOST begin
   if pistol_double_tap_activated andAlso pistol_double_tap_attacker_tile != tile_num(dude_obj) then begin
      if kamikaze <= 0 then begin
         pistol_double_tap_activated = 0;
         pistol_double_tap_in_process = 0;
         pistol_double_tap_visual = 0;
         pistol_double_tap_taps = 0;
         pistol_double_tap_target_selected = 0;
         pistol_double_tap_target = -1;
         pistol_double_tap_weapon_last_ammo = 0;
         pistol_double_tap_in_process_missed = 0;
         intface_redraw;
      end
      else begin
         pistol_double_tap_attacker_tile = tile_num(dude_obj);
      end
   end
end

procedure DEATHANIM2 begin
   variable dying_critter = get_sfall_arg_at(2);
   if (pistol_double_tap_visual or pistol_double_tap_activated) andAlso dying_critter == pistol_double_tap_target then begin
      pistol_double_tap_activated = 0;
      pistol_double_tap_in_process = 0;
      pistol_double_tap_visual = 0;
      pistol_double_tap_taps = 0;
      pistol_double_tap_target_selected = 0;
      pistol_double_tap_target = -1;
      pistol_double_tap_weapon_last_ammo = 0;
      pistol_double_tap_in_process_missed = 0;
      intface_redraw;
   end
end

//Changes AP
procedure CALCAPCOST begin
   variable user = get_sfall_arg;
   variable atk_type = get_sfall_arg;
   variable is_aimed = get_sfall_arg;
   variable default_ap_cost = get_sfall_arg;
   variable item = get_sfall_arg;
   variable cur_ammo;
   if pistol_double_tap_activated andAlso pistol_double_tap_weapon then begin
      cur_ammo = get_object_data(pistol_double_tap_weapon, OBJ_DATA_CUR_CHARGES);
      if pistol_double_tap_weapon_last_ammo <= 0 then pistol_double_tap_weapon_last_ammo = cur_ammo;
      if pistol_double_tap_weapon_last_ammo < cur_ammo then begin
         pistol_double_tap_activated = 0;
         pistol_double_tap_in_process = 0;
         pistol_double_tap_visual = 0;
         pistol_double_tap_taps = 0;
         pistol_double_tap_target_selected = 0;
         pistol_double_tap_target = -1;
         pistol_double_tap_weapon_last_ammo = 0;
         pistol_double_tap_in_process_missed = 0;
         intface_redraw;
      end
      if pistol_double_tap_weapon_last_ammo > cur_ammo then pistol_double_tap_weapon_last_ammo = cur_ammo;
   end
   if pistol_double_tap_target_selected andAlso (atk_type == ATKTYPE_LWEP1 or atk_type == ATKTYPE_RWEP1)  then begin
      if pistol_double_tap_in_process andAlso pistol_double_tap_target_selected andAlso not(is_aimed) then begin
         if critter_inven_obj(dude_obj, 2 - active_hand) == pistol_double_tap_weapon then begin
            set_sfall_return(pistol_double_tap_ap_cost);
            set_sfall_arg(3, pistol_double_tap_ap_cost);
         end
      end
      if pistol_double_tap_visual andAlso pistol_double_tap_target_selected andAlso pistol_double_tap_taps < pistol_double_tap_max_taps andAlso not(is_aimed) then begin
         if critter_inven_obj(dude_obj, 2 - active_hand) == pistol_double_tap_weapon then begin
            if pistol_double_tap_miss == 1 then begin
               set_critter_current_ap(dude_obj, get_critter_current_ap(dude_obj) - default_ap_cost + 1);
               pistol_double_tap_miss = 0;
            end
            set_sfall_return(pistol_double_tap_ap_cost);
            set_sfall_arg(3, pistol_double_tap_ap_cost);
         end
         else begin
            pistol_double_tap_in_process = 0;
            pistol_double_tap_visual = 0;
            pistol_double_tap_target_selected = 0;
         end
      end
      if pistol_double_tap_taps + 1 > pistol_double_tap_max_taps then begin
         pistol_double_tap_activated = 0;
         pistol_double_tap_in_process = 0;
         pistol_double_tap_visual = 0;
         pistol_double_tap_taps = 0;
         pistol_double_tap_target_selected = 0;
         pistol_double_tap_target = -1;
         intface_redraw;
      end
   end
   if pistol_double_tap_visual andAlso pistol_double_tap_target_selected == 0 andAlso critter_inven_obj(dude_obj, 2 - active_hand) != pistol_double_tap_weapon then begin
      pistol_double_tap_activated = 0;
      pistol_double_tap_in_process = 0;
      pistol_double_tap_visual = 0;
      pistol_double_tap_taps = 0;
      pistol_double_tap_target_selected = 0;
      pistol_double_tap_target = -1;
      pistol_double_tap_weapon_last_ammo = 0;
      pistol_double_tap_in_process_missed = 0;
   end
end

procedure AFTERHITROLL begin
   variable attack_result = get_sfall_arg;
   variable attacker = get_sfall_arg;
   variable target = get_sfall_arg;
   variable bodypart = get_sfall_arg;
   variable hit_chance = get_sfall_arg;
   variable attacker_iq;
   variable attacker_lu;
   variable critical_chance;
   variable target_pid;
   variable rnd;
   variable Atktype;
   variable ammo_cost = 1;
   variable same_target;
   variable line_length;
   variable attacker_team;
   variable new_target;
   variable new_tar_team;
   variable new_tar_arr;
   variable distance;
   variable last_distance;
   variable wrong;
   variable game_diff;
   variable nearest_target_is_friend;
   attacker_frm = anim_busy(attacker);
   if attacker > 0 andAlso attacker_frm == 0 then begin
      is_single_shot = 0;
      npc_orig_tar = 0;
      enemy_team = has_trait(TRAIT_OBJECT, orig_target, OBJECT_TEAM_NUM);
      orig_attacker = attacker;
      game_diff = difficulty_level;
      attacker_lu = get_critter_stat(attacker, STAT_lu);
      critical_chance = get_critter_stat(attacker, STAT_crit_chance);
      if target then target_pid = obj_pid(target);
      Atktype = get_object_data(combat_data, C_ATTACK_HIT_MODE);
      if target == orig_target then same_target = 1;
      new_main_target = 0;
      new_targets_count = 0;
      proj_pid_changed = 0;
      atk_rslt = attack_result;
      if atk_rslt < HIT then begin
         missed_shot = 1;
      end
      else begin
         missed_shot = 0;
      end
      if attacker == dude_obj then begin
         if active_hand == LEFT_HAND then begin
            weapon = critter_inven_obj(attacker, INVEN_TYPE_LEFT_HAND);
         end
         else begin
            weapon = critter_inven_obj(attacker, INVEN_TYPE_RIGHT_HAND);
         end
         finesse = has_trait(TRAIT_TRAIT, attacker, TRAIT_finesse);
         if traits_plus > 0 andAlso allow_critical <= 1 then begin
            if attacker == dude_obj andAlso (finesse > 0 orElse finesse_plus > 1) then begin
               allow_critical = 1;
            end
            else begin
               allow_critical = 0;
            end
         end
         bloody_mess = has_trait(TRAIT_TRAIT, attacker, TRAIT_bloody_mess);
         one_hander = has_trait(TRAIT_TRAIT, attacker, TRAIT_one_hander);
         weapon_handling = has_trait(TRAIT_PERK, attacker, PERK_weapon_handling_perk);
         sharpshooter = has_trait(TRAIT_PERK, attacker, PERK_sharpshooter);
         bonus_crit_power_roll = get_critter_stat(attacker, STAT_better_crit);
         bonus_ranged_damage = has_trait(TRAIT_PERK, attacker, PERK_bonus_ranged_damage);
         living_anatomy = has_trait(TRAIT_PERK, attacker, PERK_living_anatomy_perk);
         night_vision = has_trait(TRAIT_PERK, attacker, PERK_night_vision);
         if AllowSniperPerk then begin
            sniper = has_trait(TRAIT_PERK, attacker, PERK_sniper);
         end
      end
      else begin
         weapon = critter_inven_obj(attacker, INVEN_TYPE_RIGHT_HAND);
      end
      if weapon > 0 then begin
         weapon_pid = obj_pid(weapon);
         weapon_flags = get_proto_data(weapon_pid, PROTO_FLAG_EXT);
         weapon_ammo_pid = get_proto_data(weapon_pid, PROTO_WP_AMMO_PID);
         weapon_caliber = get_proto_data(weapon_pid, PROTO_WP_CALIBER);
         weapon_damage_type = get_proto_data(weapon_pid, PROTO_WP_DMG_TYPE);
         weapon_min_st = get_proto_data(weapon_pid, PROTO_WP_MIN_ST);
         weapon_min_dmg = get_proto_data(weapon_pid, PROTO_WP_DMG_MIN) + 2 * bonus_ranged_damage;
         weapon_max_dmg = get_proto_data(weapon_pid, PROTO_WP_DMG_MAX) + 2 * bonus_ranged_damage;
         weapon_perk = get_proto_data(weapon_pid, PROTO_WP_PERK);
         weapon_cur_ammo = get_object_data(weapon, OBJ_DATA_CUR_CHARGES);
         weapon_anim = get_proto_data(weapon_pid, PROTO_WP_ANIM);
         weapon_proj_pid = get_proto_data(weapon_pid, PROTO_WP_PROJ_PID);
         if weapon_ammo_pid > 0 then begin
            //ammo_caliber = get_proto_data(weapon_ammo_pid, PROTO_AM_CALIBER);
            ammo_mult = get_proto_data(weapon_ammo_pid, PROTO_AM_DMG_MULT);
            ammo_div = get_proto_data(weapon_ammo_pid, PROTO_AM_DMG_DIV);
            ammo_dr_mod = get_proto_data(weapon_ammo_pid, PROTO_AM_DR_MOD);
            ammo_ac_mod = get_proto_data(weapon_ammo_pid, PROTO_AM_AC_MOD);
         end
         //get range of the first attack mode for weapons in the right/left hand
         if Atktype == ATKTYPE_LWEP1 or Atktype ==  ATKTYPE_RWEP1 then begin
            weapon_range = get_proto_data(weapon_pid, PROTO_WP_RANGE_1);
            if (weapon_flags bwand ATKMODE_PRI_SINGLE) == ATKMODE_PRI_SINGLE andAlso ((weapon_flags bwand ATKMODE_PRI_BURST) != ATKMODE_PRI_BURST) then is_single_shot = 1;
         end
         //get range of the second attack mode for weapons in the right/left hand
         else if Atktype ==  ATKTYPE_LWEP2 or Atktype ==  ATKTYPE_RWEP2 then begin
            weapon_range = get_proto_data(weapon_pid, PROTO_WP_RANGE_2);
            if (weapon_flags bwand ATKMODE_SEC_SINGLE) == ATKMODE_SEC_SINGLE andAlso ((weapon_flags bwand ATKMODE_SEC_BURST) != ATKMODE_SEC_BURST) then is_single_shot = 1;
         end
         if (ammo_mult - ammo_div) >= 0 andAlso ammo_div > 0 then begin
            weapon_min_dmg = round(1.0 * weapon_min_dmg * ammo_mult / ammo_div);
            weapon_max_dmg = round(1.0 * weapon_max_dmg * ammo_mult / ammo_div);
         end
         if one_hander then begin
            one_hander_bonus = get_one_hander_bonus(weapon_flags);
         end
      end
      // electrical and EMP set new proj_pid and weapon_cur_ammo
      if ElecSecondaryAttackMod > 0 andAlso is_single_shot andAlso (attacker == dude_obj or ElecSecondaryAttackMod > 1) andAlso (target_bodypart == BODY_HIT_TORSO or ElecForced > 0 or (attacker != dude_obj andAlso target_bodypart == BODY_UNCALLED))  andAlso weapon andAlso (weapon_damage_type == DMG_electrical or weapon_damage_type == DMG_emp) andAlso weapon_cur_ammo >= ElecAmmoCost andAlso weapon_range > 1 then begin
         if attack_result <= MISS then begin
            if weapon_proj_pid > 0 andAlso ((attacker != dude_obj andAlso ElecForced > 0) or attacker == dude_obj) then begin
               proj_pid_changed = 1;
               set_proto_data(weapon_pid, PROTO_WP_PROJ_PID, 0);
               call restore_weapon_proj_pid in 1;
            end
            if attacker == dude_obj andAlso ElecAmmoCost > 1 andAlso weapon_cur_ammo >= ElecAmmoCost then set_object_data(weapon,OBJ_DATA_CUR_CHARGES, weapon_cur_ammo - (ElecAmmoCost - base_ammo_cost));
            return;
         end
         if ElecForced <= 0 andAlso attacker != dude_obj then begin
            rnd = random(0, 100);
            attacker_iq = get_critter_stat(attacker, STAT_iq);
            if rnd >= (5 - attacker_iq) then begin
               attacker_iq += 2 * game_diff;
               new_tar_arr = objects_in_radius(tile_num(orig_target),ElecRadius, elevation(orig_target), OBJ_TYPE_CRITTER);
               last_distance = ElecRadius;
               attacker_team = has_trait(TRAIT_OBJECT, attacker, OBJECT_TEAM_NUM);
               foreach new_target in new_tar_arr begin
                  if new_target == orig_target or get_critter_stat(new_target, STAT_current_hp) <= 0 then continue;
                  distance_objs(distance,target,new_target);
                  if distance == last_distance then begin
                     new_tar_team = has_trait(TRAIT_OBJECT, new_target, OBJECT_TEAM_NUM);
                     //Party members targets
                     if attacker_team == TEAM_PLAYER then begin
                        if new_tar_team == enemy_team then begin
                           enemy_targets_count += 1;
                        end
                        else if attacker_team == new_tar_team then begin
                           friendly_targets_count += 1;
                           nearest_target_is_friend = 1;
                           if new_target == attacker then friendly_targets_count += 1;
                        end
                     end
                     //Critter targets
                     else begin
                        if new_tar_team != attacker_team then begin
                           enemy_targets_count += 1;
                           nearest_target_is_friend = 0;
                        end
                        else if attacker_team == new_tar_team then begin
                           friendly_targets_count += 1;
                           nearest_target_is_friend = 1;
                           if new_target == attacker then friendly_targets_count += 1;
                        end
                     end
                  end
                  else if distance < last_distance then begin
                     //friendly_targets_count = 0;
                     //enemy_targets_count = 0;
                     nearest_target_is_friend = 0;
                     new_tar_team = has_trait(TRAIT_OBJECT, new_target, OBJECT_TEAM_NUM);
                     //Party members targets
                     if attacker_team == TEAM_PLAYER then begin
                        if new_tar_team == enemy_team then begin
                           enemy_targets_count += 1;
                        end
                        else if attacker_team == new_tar_team then begin
                           friendly_targets_count += 1;
                           nearest_target_is_friend = 1;
                           if new_target == attacker then friendly_targets_count += 1;
                        end
                     end
                     //Critter targets
                     else begin
                        if new_tar_team != attacker_team then begin
                           enemy_targets_count += 1;
                        end
                        else if attacker_team == new_tar_team then begin
                           friendly_targets_count += 1;
                           nearest_target_is_friend = 1;
                           if new_target == attacker then friendly_targets_count += 1;
                        end
                     end
                     last_distance = distance;
                  end
               end
               if attacker_team == TEAM_PLAYER then begin
                  rnd -= 15;
               end
               if rnd > attacker_iq * 5 then begin
                  wrong = 1;
               end
               if wrong > 0 or (enemy_targets_count < 1) or (nearest_target_is_friend > 0 andAlso (enemy_targets_count / friendly_targets_count) < 2) then begin
                  call restore_weapon_proj_pid;
                  call lvar_full_reset;
                  return;
               end
            end
            else begin
            //nothing
            end
         end


         alt_fire_used = 1;
         if weapon_proj_pid <= 0 then begin
            proj_pid_changed = 1;
            set_proto_data(weapon_pid, PROTO_WP_PROJ_PID, pid_electric_projectile);
            if missed_shot then call restore_weapon_proj_pid in 1;
         end
         if ElecAmmoCost > 1 andAlso weapon_cur_ammo >= ElecAmmoCost then set_object_data(weapon,OBJ_DATA_CUR_CHARGES, weapon_cur_ammo - (ElecAmmoCost - base_ammo_cost));
      end
      // electrical and EMP set new proj_pid and weapon_cur_ammo

      // plasma set new proj_pid and weapon_cur_ammo
      if PlasmaSecondaryAttackMod > 0 andAlso is_single_shot andAlso (attacker == dude_obj or PlasmaSecondaryAttackMod > 1) andAlso (target_bodypart == BODY_HIT_TORSO or (attack_is_aimed andAlso obj_type(target) != OBJ_TYPE_CRITTER andAlso attacker == dude_obj) or PlasmaForced > 0 or (attacker != dude_obj andAlso target_bodypart == BODY_UNCALLED)) andAlso weapon andAlso weapon_damage_type == DMG_plasma andAlso weapon_cur_ammo >= PlasmaAmmoCost andAlso weapon_range > 1 then begin
         //ai plasma_alt use
         if PlasmaForced <= 0 andAlso attacker != dude_obj then begin
            rnd = random(0, 100);
            attacker_iq = get_critter_stat(attacker, STAT_iq);
            if rnd > (12 - attacker_iq) then begin
               attacker_iq += 2 * game_diff;
               new_tar_arr = objects_in_radius(tile_num(orig_target),PlasmaBlastRadius, elevation(orig_target), OBJ_TYPE_CRITTER);
               attacker_team = has_trait(TRAIT_OBJECT, attacker, OBJECT_TEAM_NUM);
               friendly_targets_count = 0;
               enemy_targets_count = 0;
               foreach new_target in new_tar_arr begin
                  if get_critter_stat(new_target, STAT_current_hp) <= 0 then continue;
                  new_tar_team = has_trait(TRAIT_OBJECT, new_target, OBJECT_TEAM_NUM);
                  //Party members targets
                  if attacker_team == TEAM_PLAYER then begin
                     if new_tar_team == enemy_team then begin
                        enemy_targets_count += 1;
                     end
                     else if attacker_team == new_tar_team then begin
                        friendly_targets_count += 1;
                        if new_target == attacker then friendly_targets_count += 1;
                     end
                  end
                  //Critter targets
                  else begin
                     if new_tar_team != attacker_team then begin
                        enemy_targets_count += 1;
                     end
                     else if attacker_team == new_tar_team then begin
                        friendly_targets_count += 1;
                        if new_target == attacker then friendly_targets_count += 1;
                     end
                  end
               end
               if attacker_team == TEAM_PLAYER then begin
                  rnd -= 13;
               end
               if rnd > attacker_iq * 5 then begin
                  wrong = 1;
               end
               if wrong > 0 or (enemy_targets_count < 2 andAlso random(0,6)) or (friendly_targets_count > 0 andAlso (enemy_targets_count - 2) < friendly_targets_count) then begin
                  call restore_weapon_proj_pid;
                  call lvar_full_reset;
                  return;
               end
            end
            else begin
            //nothing
            end
         end


         alt_fire_used = 1;
         if weapon_proj_pid <= 0 orElse weapon_proj_pid != pid_plasma_big_projectile then begin
            proj_pid_changed = 1;
            set_proto_data(weapon_pid, PROTO_WP_PROJ_PID, pid_plasma_big_projectile);
            if missed_shot then call restore_weapon_proj_pid in 1;
         end

         if PlasmaAmmoCost > 1 andAlso weapon_cur_ammo >= PlasmaAmmoCost then set_object_data(weapon,OBJ_DATA_CUR_CHARGES, weapon_cur_ammo - (PlasmaAmmoCost - base_ammo_cost));
      end
      // plasma set new proj_pid and weapon_cur_ammo end

      // pistols double tap
      if PistolSecondaryAttackMod andAlso attacker == dude_obj andAlso weapon andAlso (weapon_anim == WPN_ANIM_PISTOL or weapon_anim == WPN_ANIM_SMG) andAlso weapon_damage_type == DMG_normal_dam andAlso weapon_ammo_pid != PID_2MM_EC_AMMO then begin
         alt_fire_used = 1;
         if traits_plus > 0 andAlso kamikaze_plus > 0 andAlso kamikaze_plus <= 1 then begin
            kamikaze = has_trait(TRAIT_TRAIT, dude_obj, TRAIT_kamikaze);
         end
         pistol_double_tap_target = real_orig_target;
         if pistol_double_tap_activated == 1 andAlso target_bodypart != BODY_HIT_TORSO andAlso attack_result <= 1 then begin
            pistol_double_tap_in_process_missed = 1;
            pistol_double_tap_current_target = real_orig_target;
            pistol_double_tap_taps += 1;
            if target_bodypart == BODY_UNCALLED then pistol_double_tap_in_process = 1;
            if pistol_double_tap_taps > pistol_double_tap_max_taps then begin
               pistol_double_tap_activated = 0;
               pistol_double_tap_target = -1;
            end
         end
         if (attack_result == 1 or target != real_orig_target) andAlso weapon_cur_ammo <= 1 andAlso target_bodypart == BODY_HIT_TORSO  then begin
            set_critter_current_ap(attacker, get_critter_current_ap(attacker) + 1);
         end
         if target_bodypart == BODY_HIT_TORSO andAlso (attack_result == 1 or target != real_orig_target) andAlso weapon_cur_ammo >= 2 then begin
            pistol_double_tap_in_process = 0;
            pistol_double_tap_taps = 0;
            pistol_double_tap_weapon_last_ammo = 0;
            pistol_double_tap_miss = 1;
            pistol_double_tap_attacker_tile = tile_num(dude_obj);
            pistol_double_tap_weapon = weapon;
            pistol_double_tap_activated = 1;
            pistol_double_tap_target_selected = 1;
            if pistol_double_tap_activated == 1 andAlso weapon_cur_ammo >=2 then begin
               unwield_slot(dude_obj, (2 - active_hand));
               wield_obj_critter(dude_obj, weapon);
               pistol_double_tap_visual = 1;
               intface_redraw;
            end
         end
      end
      // pistols double tap end

      // laser get new targets
      if is_single_shot andAlso LaserSecondaryAttackMod > 0 andAlso (attacker == dude_obj or LaserSecondaryAttackMod > 1) andAlso weapon andAlso (target_bodypart == BODY_HIT_TORSO or (attack_is_aimed andAlso obj_type(target) != OBJ_TYPE_CRITTER andAlso attacker == dude_obj) or LaserForced > 0 or attacker != dude_obj) andAlso weapon_cur_ammo >= 1 andAlso weapon_range > 1 andAlso weapon_damage_type == DMG_laser then begin
         if attack_result < MISS then begin
            set_sfall_return(CRITICAL_MISS);
            set_sfall_arg(0, CRITICAL_MISS);
            return;
         end
         alt_fire_used = 1;
         laser_curr_ammo = 1 + weapon_cur_ammo * 2;
         if Sonora > 0 then begin
            if (weapon_anim == WPN_ANIM_RIFLE or weapon_anim == WPN_ANIM_BIG_GUN) andAlso weapon_ammo_pid == PID_SONORA_MICRO_FUSION_CELL andAlso laser_curr_ammo > laser_max_targets_two_handed_micro_fusion + 2  then begin
               laser_curr_ammo = laser_max_targets_two_handed_micro_fusion + 2; // max additional targets for two_handed high power laser weapon
            end
            else if (weapon_anim == WPN_ANIM_PISTOL or weapon_anim == WPN_ANIM_SMG) andAlso weapon_ammo_pid == PID_SONORA_MICRO_FUSION_CELL andAlso laser_curr_ammo > laser_max_targets_one_handed_micro_fusion + 2 then begin
               laser_curr_ammo = laser_max_targets_one_handed_micro_fusion + 2;// max additional targets for two_handed high power laser weapon
            end
            else if (weapon_anim == WPN_ANIM_RIFLE or weapon_anim == WPN_ANIM_BIG_GUN) andAlso weapon_ammo_pid == PID_SONORA_SMALL_ENERGY_CELL andAlso laser_curr_ammo > laser_max_targets_two_handed_small_cell + 2 then begin
               laser_curr_ammo = laser_max_targets_two_handed_small_cell + 2;// max additional targets for two_handed high power laser weapon
            end
            else if (weapon_anim == WPN_ANIM_PISTOL or weapon_anim == WPN_ANIM_SMG) andAlso weapon_ammo_pid == PID_SONORA_SMALL_ENERGY_CELL andAlso laser_curr_ammo > laser_max_targets_one_handed_small_cell + 2 then begin
               laser_curr_ammo = laser_max_targets_one_handed_small_cell + 2;// max additional targets for two_handed high power laser weapon
            end
         end
         else begin
            if (weapon_anim == WPN_ANIM_RIFLE or weapon_anim == WPN_ANIM_BIG_GUN) andAlso weapon_ammo_pid == PID_MICRO_FUSION_CELL andAlso laser_curr_ammo > laser_max_targets_two_handed_micro_fusion + 2  then begin
               laser_curr_ammo = laser_max_targets_two_handed_micro_fusion + 2; // max additional targets for two_handed high power laser weapon
            end
            else if (weapon_anim == WPN_ANIM_PISTOL or weapon_anim == WPN_ANIM_SMG) andAlso weapon_ammo_pid == PID_MICRO_FUSION_CELL andAlso laser_curr_ammo > laser_max_targets_one_handed_micro_fusion + 2 then begin
               laser_curr_ammo = laser_max_targets_one_handed_micro_fusion + 2;// max additional targets for two_handed high power laser weapon
            end
            else if (weapon_anim == WPN_ANIM_RIFLE or weapon_anim == WPN_ANIM_BIG_GUN) andAlso weapon_ammo_pid == PID_SMALL_ENERGY_CELL andAlso laser_curr_ammo > laser_max_targets_two_handed_small_cell + 2 then begin
               laser_curr_ammo = laser_max_targets_two_handed_small_cell + 2;// max additional targets for two_handed high power laser weapon
            end
            else if (weapon_anim == WPN_ANIM_PISTOL or weapon_anim == WPN_ANIM_SMG) andAlso weapon_ammo_pid == PID_SMALL_ENERGY_CELL andAlso laser_curr_ammo > laser_max_targets_one_handed_small_cell + 2 then begin
               laser_curr_ammo = laser_max_targets_one_handed_small_cell + 2;// max additional targets for two_handed high power laser weapon
            end
         end
         rnd = random(1, 96);
         if rnd > hit_chance then begin
            missed_shot = 1;
         end
         if LaserLineWidth then begin
            call get_targets_on_wide_line_laser(attacker, orig_target);
            if LaserForced <= 0 then begin
               ammo_cost = (new_targets_count - friendly_targets_count) / 2;
            end
            else begin
               ammo_cost = 0;
            end
            //ammo_cost = base_ammo_cost;
            if ammo_cost < 0 then ammo_cost = 0;
            if ammo_cost > 0 andAlso weapon_cur_ammo + 1 >= ammo_cost then set_object_data(weapon,OBJ_DATA_CUR_CHARGES, weapon_cur_ammo - ammo_cost);
            if not(same_target) then begin
               laser_curr_ammo = random(1, (new_targets_count + base_alt_ammo_cost + base_ammo_cost));
               targets_array = 0;
               call get_targets_on_wide_line_laser(attacker, target);
            end
         end
         else begin
            call get_targets_on_thin_line_laser(attacker, orig_target);
            if LaserForced <= 0 then begin
               ammo_cost = (new_targets_count - friendly_targets_count) / 2;
            end
            else begin
               ammo_cost = 0;
            end
            //ammo_cost = base_ammo_cost;
            if ammo_cost < 0 then ammo_cost = 0;
            if ammo_cost > 0 andAlso weapon_cur_ammo + 1 >= ammo_cost then set_object_data(weapon,OBJ_DATA_CUR_CHARGES, weapon_cur_ammo - ammo_cost);
            if not(same_target) then begin
               laser_curr_ammo = random(1, (new_targets_count + base_alt_ammo_cost + base_ammo_cost));
               targets_array = 0;
               call get_targets_on_thin_line_laser(attacker, target);
            end
         end
         new_targets_count = 0;
         if not(new_main_target) andAlso atk_rslt == MISS then begin
         //if not(new_main_target) then begin
            new_main_target = last_target_on_a_line;
            missed_shot = 1;
         end
         if weapon_proj_pid <= 0 then begin
            proj_pid_changed = 1;
            set_proto_data(weapon_pid, PROTO_WP_PROJ_PID, pid_laser_projectile);
            if missed_shot then call restore_weapon_proj_pid in 1;
         end
      end
      // gauss get new targets
      if GaussSecondaryAttackMod > 0 andAlso is_single_shot andAlso (attacker == dude_obj or GaussSecondaryAttackMod > 1) andAlso (target_bodypart == BODY_HIT_TORSO or (attack_is_aimed andAlso obj_type(target) != OBJ_TYPE_CRITTER andAlso attacker == dude_obj) or GaussForced > 0 or attacker != dude_obj) andAlso weapon andAlso weapon_range > 1 andAlso (weapon_ammo_pid == PID_2MM_EC_AMMO or (Sonora > 0 andAlso weapon_pid == pid_sonora_railgun)) then begin
         if attack_result < MISS then begin
            set_sfall_return(CRITICAL_MISS);
            set_sfall_arg(0, CRITICAL_MISS);
            return;
         end
         alt_fire_used = 1;
         rnd = random(1, 96);
         if rnd > hit_chance then begin
            missed_shot = 1;
         end
         if weapon_proj_pid > 0 then begin
            proj_pid_changed = 1;
            set_proto_data(weapon_pid, PROTO_WP_PROJ_PID, 0);
            if missed_shot then call restore_weapon_proj_pid in 1;
         end

         new_main_target = 0;
         line_length = 50;
         if GaussLineWidth then begin
            call get_targets_on_wide_line_gauss(attacker, orig_target);
            if not(same_target) andAlso atk_rslt != MISS then begin
               targets_array = 0;
               call get_targets_on_wide_line_gauss(attacker, target);
            end
         end
         else begin
            call get_targets_on_thin_line_gauss(attacker, orig_target,line_length);
               while not(is_in_array(orig_target,targets_array)) andAlso line_length > 45 do begin
                  line_length -= 1;
                  call get_targets_on_thin_line_gauss(attacker, orig_target,line_length);
               end
            if not(same_target) andAlso atk_rslt != MISS then begin
               targets_array = 0;
               call get_targets_on_thin_line_gauss(attacker, target,line_length);
               while not(is_in_array(target,targets_array)) andAlso line_length > 45 do begin
                  line_length -= 1;
                  call get_targets_on_thin_line_gauss(attacker, target,line_length);
               end
            end
         end
      end
      if new_main_target then begin
         rnd = random(1, 100);
         if rnd <= critical_chance or (sniper andAlso random(1,10) <= attacker_lu) then begin
            set_sfall_return(CRITICAL_HIT);
            set_sfall_arg(0, CRITICAL_HIT);
            set_sfall_return(bodypart);
            set_sfall_arg(3, bodypart);
            set_sfall_return(new_main_target);
            set_sfall_arg(2, new_main_target);
         end
         else begin
            set_sfall_return(HIT);
            set_sfall_arg(0, HIT);
            set_sfall_return(bodypart);
            set_sfall_arg(3, bodypart);
            set_sfall_return(new_main_target);
            set_sfall_arg(2, new_main_target);
         end
      end
   end
end

procedure COMBATDAMAGE begin
   variable target = get_sfall_arg;
   variable attacker = get_sfall_arg;
   variable dmgtotar = get_sfall_arg;
   variable dmgtoatk = get_sfall_arg;
   variable tar_flags = get_sfall_arg;
   variable atk_flags = get_sfall_arg;
   variable weapon = get_sfall_arg;
   variable dmg_mult = get_sfall_arg_at(8);
   variable atktype = get_sfall_arg_at(11);
   variable atk_data = get_sfall_arg_at(12);
   variable target_kill_type;
   variable knockback_distance;
   variable attacker_target_distance;
   variable rnd;
   variable line_length;
   variable target_is_wearing_power_armor;
   variable stonewall_perk;
   variable actual_target = get_object_data(combat_data, C_ATTACK_TARGET);
   variable actual_attack;
   variable dmgtotar_was_return;
   if (attacker != dude_obj andAlso actual_target > 0) orElse (attacker == dude_obj) then begin
      actual_attack = 1;
   end
   if actual_attack > 0 then begin
      orig_attacker = attacker;
      combat_dmg = dmgtotar;
      first_combat_dmg = -1;
      attacker_frm = anim_busy(attacker);
      if ShotgunForced > 0 andAlso weapon > 0 then begin
         weapon_pid = obj_pid(weapon);
         weapon_caliber = get_proto_data(weapon_pid, PROTO_WP_CALIBER);
      end
      if missed_shot andAlso target != real_orig_target andAlso target != attacker andAlso weapon_caliber != shotgun_caliber then begin
         if alt_fire_used > 0 then begin
            if weapon_damage_type == DMG_plasma then begin
               combat_dmg = random(5,8) + ceil(combat_dmg * 1.15);
            end
            else if weapon_damage_type == DMG_normal_dam then begin
               combat_dmg = calc_dmg_gauss(attacker,target,random(weapon_min_dmg, weapon_max_dmg));
            end
            else if weapon_damage_type == DMG_laser then begin
               combat_dmg = calc_dmg_laser(attacker,target);
            end
            if combat_dmg < 0 then combat_dmg = 0;
            first_combat_dmg = combat_dmg;
            set_sfall_return(combat_dmg);
            set_sfall_arg(2, combat_dmg);
            dmgtotar_was_return = 1;
         end
         //return;
      end
      if attacker andAlso attacker_frm == 0 andAlso one_time_call <= 0 then begin
         combat_dmg = dmgtotar;
         COMBATDAMAGE_target = target;

         // electric chain dmg
         if ElecSecondaryAttackMod > 0 andAlso is_single_shot andAlso (attacker == dude_obj or ElecSecondaryAttackMod > 1) andAlso (target_bodypart == BODY_HIT_TORSO or ElecForced > 0 or (attacker != dude_obj andAlso target_bodypart == BODY_UNCALLED)) andAlso weapon andAlso (weapon_damage_type == DMG_electrical or weapon_damage_type == DMG_emp) andAlso weapon_cur_ammo >= ElecAmmoCost andAlso weapon_range > 1 then begin
            //if target == attacker orElse (atk_flags bwand DAM_BACKWASH) orElse (ElecForced <= 0 andALso attacker != dude_obj andAlso friendly_targets_count > enemy_targets_count) then begin
            if target == attacker orElse (atk_flags bwand DAM_BACKWASH) or obj_type(target) != OBJ_TYPE_CRITTER then begin
               call restore_weapon_proj_pid;
               call lvar_full_reset;
               return;
            end
            if get_proto_data(weapon_pid, PROTO_WP_PROJ_PID) <= 0 then begin
               proj_pid_changed = 1;
               set_proto_data(weapon_pid, PROTO_WP_PROJ_PID, pid_electric_projectile);
            end
            orig_target = target;
            one_time_call = 1;
            call electrical_chain_dmg(attacker,target);
         end
         // electric chain dmg end

         // plasma aoe dmg
         if PlasmaSecondaryAttackMod > 0 andAlso is_single_shot andAlso (attacker == dude_obj or PlasmaSecondaryAttackMod > 1) andAlso (target_bodypart == BODY_HIT_TORSO or (attack_is_aimed andAlso target == orig_target andAlso obj_type(target) != OBJ_TYPE_CRITTER andAlso attacker == dude_obj) or PlasmaForced > 0 or (attacker != dude_obj andAlso target_bodypart == BODY_UNCALLED)) andAlso weapon andAlso weapon_damage_type == DMG_plasma andAlso weapon_cur_ammo >= PlasmaAmmoCost andAlso weapon_range > 1 then begin
            //if target == attacker orElse (atk_flags bwand DAM_BACKWASH) orElse (PlasmaForced <= 0 andALso attacker != dude_obj andAlso friendly_targets_count >= enemy_targets_count) then begin
            if target == attacker orElse (atk_flags bwand DAM_BACKWASH) then begin
               call restore_weapon_proj_pid;
               call lvar_full_reset;
               return;
            end
            orig_target = target;
            one_time_call = 1;
            if combat_dmg > 0 andAlso has_trait(TRAIT_OBJECT, target, OBJECT_TEAM_NUM) != TEAM_PLAYER then begin
               combat_dmg = random(5,8) + ceil(combat_dmg * 1.15);
               if dmgtotar_was_return <= 0 then begin
                  set_sfall_return(combat_dmg);
                  set_sfall_arg(2, combat_dmg);
               end
            end
            call plasma_aoe_dmg(attacker,target);
         end
         // plasma aoe dmg end

         //shotgun alt fire(knockback)
         if ShotgunSecondaryAttackMod > 0 andAlso (attacker == dude_obj or ShotgunSecondaryAttackMod > 1) andAlso weapon andAlso weapon_caliber == shotgun_caliber andAlso (target_bodypart == BODY_HIT_TORSO or ShotgunForced > 0 or ((attacker != dude_obj andAlso target_bodypart == BODY_UNCALLED) andAlso is_single_shot andAlso not(random(0,2)))) then begin
            if target == attacker orElse (atk_flags bwand DAM_BACKWASH) then begin
               call restore_weapon_proj_pid;
               call lvar_full_reset;
               return;
            end
            distance_objs(attacker_target_distance, attacker, target);
            knockback_distance = random(ShotgunKnockbackMin, ShotgunKnockbackMax);
            if has_trait(TRAIT_OBJECT, target, OBJECT_TEAM_NUM) == TEAM_PLAYER then begin
               if target == dude_obj then begin
                  target_is_wearing_power_armor = player_wearing_power_armor;
                  stonewall_perk = has_trait(TRAIT_PERK, dude_obj, PERK_stonewall_perk);
               end
               if target_is_wearing_power_armor then begin
                  knockback_distance = 1;
                  rnd = 5;
               end
               else if stonewall_perk then begin
                  if random(0, 1) then begin
                     knockback_distance = 0;
                     rnd = 10;
                  end
                  else begin
                     knockback_distance = knockback_distance / 2;
                     rnd = random(0, 20 + 10 * ShotgunForced);
                  end
               end
               else begin
                  rnd = random(0, 10 + 10 * ShotgunForced);
               end
            end
            else begin
               target_kill_type = metarule(METARULE_CRITTER_KILL_TYPE, target);
               if power_armor_fid(critter_art_fid(target)) then target_is_wearing_power_armor = 1;
               if attacker_target_distance > 10 or is_multihex(target) or target_kill_type == KILL_TYPE_super_mutant_kills or target_kill_type == KILL_TYPE_deathclaw_kills or target_kill_type == KILL_TYPE_robot_kills or target_is_wearing_power_armor then begin
                  if knockback_distance > 1 then knockback_distance = random(1, knockback_distance / 2);
                  rnd = random(0, 4 + (6 * ShotgunForced));
               end
               else begin
                  knockback_distance = random(ShotgunKnockbackMin, ShotgunKnockbackMax);
                  rnd = random(0, 2 + (3 * ShotgunForced));
               end
            end
            if knockback_distance < 1 then knockback_distance = 1;
            if (attacker_target_distance < 10 or attacker_target_distance <= weapon_range / 2) then begin
               if dmgtotar_was_return <= 0 then begin
                  set_sfall_return(dmgtotar);
                  set_sfall_arg(2, dmgtotar);
               end
               set_sfall_return(dmgtoatk);
               set_sfall_arg(3, dmgtoatk);
               if rnd <= 0 then begin
                  set_sfall_return(tar_flags bwor DAM_KNOCKED_DOWN);
                  set_sfall_arg(4, tar_flags bwor DAM_KNOCKED_DOWN);
               end
               else begin
                  set_sfall_return(tar_flags);
                  set_sfall_arg(4, tar_flags);
               end
               set_sfall_return(atk_flags);
               set_sfall_arg(5, atk_flags);
               set_sfall_return(knockback_distance);
               set_sfall_arg(10, knockback_distance);
            end
         end
         //shotgun alt fire(knockback) end

         // pistols double tap
         if PistolSecondaryAttackMod andAlso attacker == dude_obj andAlso weapon andAlso (weapon_anim == WPN_ANIM_PISTOL or weapon_anim == WPN_ANIM_SMG) andAlso weapon_damage_type == DMG_normal_dam andAlso weapon_ammo_pid != PID_2MM_EC_AMMO then begin
            alt_fire_used = 1;
            if pistol_double_tap_activated == 1 andAlso target_bodypart != BODY_HIT_TORSO then begin
               pistol_double_tap_current_target = real_orig_target;
               if pistol_double_tap_in_process_missed == 0 then begin
                  if pistol_double_tap_taps <= 0 then pistol_double_tap_taps = 0;
                  pistol_double_tap_taps += 1;
               end
               pistol_double_tap_in_process_missed = 0;
               if target_bodypart == BODY_UNCALLED then pistol_double_tap_in_process = 1;
               if pistol_double_tap_taps > pistol_double_tap_max_taps then begin
                  pistol_double_tap_activated = 0;
                  pistol_double_tap_target = -1;
               end
            end
            if target_bodypart == BODY_HIT_TORSO then begin
               pistol_double_tap_taps = 0;
               pistol_double_tap_in_process = 0;
               if target == real_orig_target then begin
                  set_critter_current_ap(attacker, get_critter_current_ap(attacker) + 1);
               end
               if is_critter(target) andAlso target == real_orig_target andAlso dmgtotar < get_critter_stat(target,STAT_current_hp) andAlso weapon_cur_ammo >= 2  then begin
                  pistol_double_tap_weapon_last_ammo = 0;
                  pistol_double_tap_attacker_tile = tile_num(dude_obj);
                  pistol_double_tap_weapon = weapon;
                  pistol_double_tap_activated = 1;
                  pistol_double_tap_target_selected = 1;
                  if pistol_double_tap_activated == 1 andAlso weapon_cur_ammo >= 2 then begin
                     unwield_slot(dude_obj, (2 - active_hand));
                     wield_obj_critter(dude_obj, weapon);
                     pistol_double_tap_visual = 1;
                     intface_redraw;
                  end
               end
            end
         end
         // pistols double tap end

         // laser alt dmg
         if LaserSecondaryAttackMod > 0 andAlso (attacker == dude_obj orElse LaserSecondaryAttackMod > 1) andAlso weapon andAlso (target_bodypart == BODY_HIT_TORSO or (attack_is_aimed andAlso target == orig_target andAlso obj_type(target) != OBJ_TYPE_CRITTER andAlso attacker == dude_obj) or LaserForced > 0 or attacker != dude_obj) andAlso weapon_cur_ammo >= 1 andAlso weapon_range > 1 andAlso weapon_damage_type == DMG_laser then begin
            if target == attacker orElse (atk_flags bwand DAM_BACKWASH) orElse (LaserForced <= 0 andALso attacker != dude_obj andAlso friendly_targets_count >= enemy_targets_count) then begin
               call restore_weapon_proj_pid;
               call lvar_full_reset;
               return;
            end
            one_time_call = 1;
            // get new targets if missed;
            //if missed_shot > 0 then begin
               if LaserLineWidth then begin
                  targets_array = 0;
                  laser_curr_ammo = 999;
                  call get_targets_on_wide_line_laser(attacker, target);
               end
               else begin
                  targets_array = 0;
                  laser_curr_ammo = 999;
                  call get_targets_on_thin_line_laser(attacker, target);
               end
            //end
            // dmg new targets
            call laser_line_dmg(attacker, target);
            if (new_dmg_to_orig_target <= 0 or (target == orig_target andAlso missed_shot)) andAlso ShootThru(target) then begin
               if dmgtotar_was_return <= 0 then begin
                  set_sfall_return(0);
                  set_sfall_arg(2, 0);
               end
               set_sfall_return(0);
               set_sfall_arg(3, 0);
               set_sfall_return(0);
               set_sfall_arg(4, 0);
               if missed_shot then begin
                  set_sfall_return(0);
                  set_sfall_arg(5, 0);
               end
               else begin
                  set_sfall_return(DAM_HIT);
                  set_sfall_arg(5, DAM_HIT);
               end
               combat_dmg = 0;
            end
            else begin
               if dmgtotar_was_return <= 0 then begin
                  set_sfall_return(new_dmg_to_orig_target);
                  set_sfall_arg(2, new_dmg_to_orig_target);
                  combat_dmg = new_dmg_to_orig_target;
               end
            end
         end
         // laser alt dmg end

         //gauss alt dmg
         if GaussSecondaryAttackMod > 0 andAlso (attacker == dude_obj or GaussSecondaryAttackMod > 1) andAlso (target_bodypart == BODY_HIT_TORSO or (attack_is_aimed andAlso target == orig_target andAlso obj_type(target) != OBJ_TYPE_CRITTER andAlso attacker == dude_obj) or GaussForced > 0 or attacker != dude_obj) andAlso weapon andAlso weapon_range > 1  andAlso (weapon_ammo_pid == PID_2MM_EC_AMMO or (Sonora > 0 andAlso weapon_pid == pid_sonora_railgun)) then begin
            if target == attacker orElse (atk_flags bwand DAM_BACKWASH) orElse (GaussForced <= 0 andALso attacker != dude_obj andAlso friendly_targets_count >= enemy_targets_count) then begin
               call restore_weapon_proj_pid;
               call lvar_full_reset;
               return;
            end
            one_time_call = 1;
            // get new targets if missed;
            if atk_rslt == MISS then begin
               line_length = 50;
               if GaussLineWidth then begin
                  call get_targets_on_wide_line_gauss(attacker, target);
               end
               else begin
                  call get_targets_on_thin_line_gauss(attacker, target,line_length);
                  while not(is_in_array(target,targets_array)) andAlso line_length > 40 do begin
                     line_length -= 1;
                     call get_targets_on_thin_line_gauss(attacker, target,line_length);
                  end
               end
            end

               call gauss_line_dmg(attacker, target);
               if (new_dmg_to_orig_target <= 0 or (missed_shot)) andAlso ShootThru(target) then begin
                  if dmgtotar_was_return <= 0 then begin
                     set_sfall_return(0);
                     set_sfall_arg(2, 0);
                  end
                  set_sfall_return(0);
                  set_sfall_arg(3, 0);
                  set_sfall_return(0);
                  set_sfall_arg(4, 0);
                  if missed_shot then begin
                     set_sfall_return(0);
                     set_sfall_arg(5, 0);
                  end
                  else begin
                     set_sfall_return(DAM_HIT);
                     set_sfall_arg(5, DAM_HIT);
                  end
                  combat_dmg = 0;
               end
               else begin
                  if dmgtotar_was_return <= 0 then begin
                     set_sfall_return(new_dmg_to_orig_target);
                     set_sfall_arg(2, new_dmg_to_orig_target);
                     combat_dmg = new_dmg_to_orig_target;
                  end
               end
         end
         //gauss alt dmg end
      end
      orig_target = target;
   end
end


procedure TOHIT begin
   variable attacker = get_sfall_arg_at(1);
   variable target = get_sfall_arg_at(2);
   variable hit_chance = get_sfall_arg_at(7);
   variable attacked_body_part = get_sfall_arg_at(3);
   variable new_hit_chance;
   if attacker != dude_obj andAlso npc_orig_tar <= 0 then begin
      if lvar_cleared <= 0 then begin
         call restore_weapon_proj_pid();
         call lvar_full_reset();
      end
      lvar_cleared = 0;
      npc_orig_tar = target;
      real_orig_target = target;
      orig_target = target;
   end
   if is_critter(target) andAlso (target == real_orig_target or target == npc_orig_tar) then begin
      target_bodypart = attacked_body_part;
   end
   if pistol_double_tap_activated andAlso target == pistol_double_tap_target andAlso attacked_body_part == BODY_UNCALLED then begin
      new_hit_chance = hit_chance - ((pistol_double_tap_to_hit_penalty + weapon_min_st * 3) * (1 + pistol_double_tap_taps));
      if hit_chance > 0 andAlso new_hit_chance < hit_chance / 3 then new_hit_chance = (hit_chance / 3) + 2;
      if new_hit_chance > 95 then new_hit_chance = 95;
      set_sfall_return(new_hit_chance);
      set_sfall_arg(0, new_hit_chance);
   end
end


procedure TARGETOBJECT begin
   variable is_attacking = get_sfall_arg;
   variable can_be_attacked = get_sfall_arg;
   variable target = get_sfall_arg;
   if is_attacking andAlso can_be_attacked then begin
      if lvar_cleared <= 0 then begin
         call restore_weapon_proj_pid();
         if pistol_double_tap_activated <= 0 then call lvar_full_reset();
      end
      if pistol_double_tap_activated <= 0 then lvar_cleared = 0;
      orig_target = target;
      if is_critter(target) then real_orig_target = target;
   end
   if can_be_attacked andAlso pistol_double_tap_activated andAlso pistol_double_tap_taps < pistol_double_tap_max_taps then begin
      if target == pistol_double_tap_target then begin
         if pistol_double_tap_attacker_tile == tile_num(dude_obj) then begin
            pistol_double_tap_target_selected = 1;
         end
         else begin
            pistol_double_tap_target_selected = 0;
         end
      end
      else begin
         pistol_double_tap_target_selected = 0;
      end
      intface_redraw;
   end
end

//get combat speed
procedure GAMEMODECHANGE begin
   variable game_mode;
   if pistol_double_tap_target_selected then begin
      game_mode = get_game_mode;
      if (game_mode bwand INVENTORY) or not(game_mode) then begin
         pistol_double_tap_activated = 0;
         pistol_double_tap_in_process = 0;
         pistol_double_tap_visual = 0;
         pistol_double_tap_taps = 0;
         pistol_double_tap_target_selected = 0;
         pistol_double_tap_target = -1;
         pistol_double_tap_weapon_last_ammo = 0;
         intface_redraw;
      end
   end
end

procedure COMBATTURN begin
   if get_sfall_arg_at(1) == dude_obj then begin
      if pistol_double_tap_visual or pistol_double_tap_activated then begin
         pistol_double_tap_activated = 0;
         pistol_double_tap_in_process = 0;
         pistol_double_tap_visual = 0;
         pistol_double_tap_taps = 0;
         pistol_double_tap_target_selected = 0;
         pistol_double_tap_target = -1;
         pistol_double_tap_weapon_last_ammo = 0;
         pistol_double_tap_in_process_missed = 0;
         intface_redraw;
      end
   end
   if alt_fire_used or one_time_call or get_sfall_arg_at(0) <= 0 then begin
      call restore_weapon_proj_pid;
      call lvar_full_reset();
   end
end

procedure USEOBJON begin
   if get_sfall_arg_at(1) == dude_obj then begin
      if pistol_double_tap_visual or pistol_double_tap_activated then begin
         pistol_double_tap_activated = 0;
         pistol_double_tap_in_process = 0;
         pistol_double_tap_visual = 0;
         pistol_double_tap_taps = 0;
         pistol_double_tap_target_selected = 0;
         pistol_double_tap_target = -1;
         pistol_double_tap_weapon_last_ammo = 0;
         pistol_double_tap_in_process_missed = 0;
         intface_redraw;
      end
   end
end

procedure start begin
variable test;
variable item;
variable i;
   if game_loaded then begin
      variable SecondaryAttackMod = get_ini_setting("mods\\F2MechanicsMiniRework.ini|MAIN|SecondaryAttackMod");
      if SecondaryAttackMod > 0 then begin
         living_anatomy_bonus = get_ini_setting("sfall\\Perks.ini|PerksTweak|LivingAnatomyBonus");

         if living_anatomy_bonus < 0 then living_anatomy_bonus = 5;

         allow_critical = get_ini_setting("mods\\F2MechanicsMiniRework.ini|SecondaryAttack|AllowCriticalHits");
         if allow_critical > 0 then begin
            allow_critical = 10;
         end
         traits_plus = get_ini_setting("mods\\F2MechanicsMiniRework.ini|Main|TraitsPlus");
         if traits_plus > 0 then begin
            kamikaze_plus = get_ini_setting("mods\\F2MechanicsMiniRework.ini|TraitsPlus|Kamikaze");
            if kamikaze_plus <= 0 then begin
               kamikaze_plus = -1;
            end
            else if kamikaze_plus > 1 then begin
               kamikaze_plus = 10;
            end
            if allow_critical <= 0 then begin
               finesse_plus = get_ini_setting("mods\\F2MechanicsMiniRework.ini|TraitsPlus|Finesse");
               if finesse_plus <= 0 then begin
                  finesse_plus = -1;
               end
            end
         end

         Sonora = get_ini_setting("mods\\F2MechanicsMiniRework.ini|Main|Sonora");
         if Sonora > 0 then set_proto_data(pid_sonora_railgun, PROTO_WP_PROJ_PID, 0);
         show_float_dmg = get_ini_setting("mods\\F2MechanicsMiniRework.ini|SecondaryAttack|SecondaryAttackShowFloatMSG");
         AllowSniperPerk = get_ini_setting("mods\\F2MechanicsMiniRework.ini|SecondaryAttack|AllowSniperPerk");
         LaserSecondaryAttackMod = get_ini_setting("mods\\F2MechanicsMiniRework.ini|SecondaryAttack|LaserSecondaryAttackMod");
         if LaserSecondaryAttackMod > 0 then begin
            LaserLineWidth = get_ini_setting("mods\\F2MechanicsMiniRework.ini|SecondaryAttack|LaserLineWidth");
            if LaserLineWidth < 0 then LaserLineWidth = 0;
            if LaserLineWidth > 1 then LaserLineWidth = 1;
            //LaserHitChance = get_ini_setting("mods\\F2MechanicsMiniRework.ini|SecondaryAttack|LaserHitChance");
            LaserHitChance = 1;
            LaserForced = get_ini_setting("mods\\F2MechanicsMiniRework.ini|SecondaryAttack|LaserForcedActivation");
            laser_max_targets_two_handed_micro_fusion = get_ini_setting("mods\\F2MechanicsMiniRework.ini|SecondaryAttack|MaxAddTargets_TWMFC");
            if laser_max_targets_two_handed_micro_fusion < 1 then laser_max_targets_two_handed_micro_fusion = 1;
            laser_max_targets_one_handed_micro_fusion = get_ini_setting("mods\\F2MechanicsMiniRework.ini|SecondaryAttack|MaxAddTargets_OWMFC");
            if laser_max_targets_one_handed_micro_fusion < 1 then laser_max_targets_one_handed_micro_fusion = 1;
            laser_max_targets_two_handed_small_cell = get_ini_setting("mods\\F2MechanicsMiniRework.ini|SecondaryAttack|MaxAddTargets_TWSEC");
            if laser_max_targets_two_handed_small_cell < 1 then laser_max_targets_two_handed_small_cell = 1;
            laser_max_targets_one_handed_small_cell = get_ini_setting("mods\\F2MechanicsMiniRework.ini|SecondaryAttack|MaxAddTargets_OWSEC");
            if laser_max_targets_one_handed_small_cell < 1 then laser_max_targets_one_handed_small_cell = 1;
         end

         ElecSecondaryAttackMod = get_ini_setting("mods\\F2MechanicsMiniRework.ini|SecondaryAttack|PulseSecondaryAttackMod");
         if ElecSecondaryAttackMod > 0 then begin
            ElecRadius = get_ini_setting("mods\\F2MechanicsMiniRework.ini|SecondaryAttack|PulseMaxRadius");
            if ElecRadius <= 0 then ElecRadius = 5;
            ElecMaxTargets = get_ini_setting("mods\\F2MechanicsMiniRework.ini|SecondaryAttack|PulseMaxTargets");
            if ElecMaxTargets <= 0 then ElecMaxTargets = 2;
            ElecForced = get_ini_setting("mods\\F2MechanicsMiniRework.ini|SecondaryAttack|PulseForcedActivation");
            test = create_object_sid(pid_emp_expl, 0, 0, -1);
            anim(test, ANIMATE_SET_FRAME, 5);
            if get_object_data(test, OBJ_DATA_CUR_FRM) == 0 then old_emp_expl = 1;
            if test > 0 then destroy_object(test);
            ElecHitChance = 1;
            if ElecForced > 0 then ElecAmmoCost = 1;
         end

         GaussSecondaryAttackMod = get_ini_setting ("mods\\F2MechanicsMiniRework.ini|SecondaryAttack|GaussSecondaryAttackMod");
         if GaussSecondaryAttackMod > 0 then begin
            GaussLineWidth = get_ini_setting ("mods\\F2MechanicsMiniRework.ini|SecondaryAttack|GaussLineWidth");
            if GaussLineWidth < 0 then GaussLineWidth = 0;
            if GaussLineWidth > 1 then GaussLineWidth = 1;
            //GaussHitChance = get_ini_setting ("mods\\F2MechanicsMiniRework.ini|SecondaryAttack|GaussHitChance");
            GaussHitChance = 1;
            GaussDamageReductionPerTarget = atof(get_ini_string("mods\\F2MechanicsMiniRework.ini|SecondaryAttack|GaussDamageReductionPerTarget"));
            if GaussDamageReductionPerTarget <= 0 then GaussDamageReductionPerTarget = 0.17;
            GaussForced = get_ini_setting("mods\\F2MechanicsMiniRework.ini|SecondaryAttack|GaussForcedActivation");
         end

         PlasmaSecondaryAttackMod = get_ini_setting("mods\\F2MechanicsMiniRework.ini|SecondaryAttack|PlasmaSecondaryAttackMod");
         if PlasmaSecondaryAttackMod > 0 then begin
            PlasmaBlastRadius = get_ini_setting("mods\\F2MechanicsMiniRework.ini|SecondaryAttack|PlasmaBlastRadius");
            if PlasmaBlastRadius < 1 then PlasmaBlastRadius = 2;
            PlasmaDamagePercentage = atof(get_ini_string("mods\\F2MechanicsMiniRework.ini|SecondaryAttack|PlasmaDamagePercentage"));
            if PlasmaDamagePercentage > 1 then PlasmaDamagePercentage = 1;
            if PlasmaDamagePercentage <= 0 then PlasmaDamagePercentage = 0.65;
            PlasmaForced = get_ini_setting("mods\\F2MechanicsMiniRework.ini|SecondaryAttack|PlasmaForcedActivation");
            if PlasmaForced > 0 then PlasmaAmmoCost = 1;
         end

         ShotgunSecondaryAttackMod = get_ini_setting("mods\\F2MechanicsMiniRework.ini|SecondaryAttack|ShotgunSecondaryAttackMod");
         if ShotgunSecondaryAttackMod > 0 then begin
            shotgun_caliber = CALIBER_12_GAUGE;
            if Sonora > 0 then shotgun_caliber = 5;
            ShotgunKnockbackMin = get_ini_setting("mods\\F2MechanicsMiniRework.ini|SecondaryAttack|ShotgunKnockbackMin");
            if ShotgunKnockbackMin < 1 then ShotgunKnockbackMin = 1;
            ShotgunKnockbackMax = get_ini_setting("mods\\F2MechanicsMiniRework.ini|SecondaryAttack|ShotgunKnockbackMax");
            if ShotgunKnockbackMax < 1 then ShotgunKnockbackMax = 5;
            ShotgunForced = get_ini_setting("mods\\F2MechanicsMiniRework.ini|SecondaryAttack|ShotgunForcedActivation");
         end

         PistolSecondaryAttackMod = get_ini_setting("mods\\F2MechanicsMiniRework.ini|SecondaryAttack|PistolSecondaryAttackMod");
         if PistolSecondaryAttackMod > 0 then begin
            pistol_double_tap_max_taps = get_ini_setting("mods\\F2MechanicsMiniRework.ini|SecondaryAttack|PistolMaxBonusShots");
            if pistol_double_tap_max_taps <= 0 then pistol_double_tap_max_taps = 1;
            pistol_double_tap_ap_cost = get_ini_setting("mods\\F2MechanicsMiniRework.ini|SecondaryAttack|PistolSecondShotApCost");
            if pistol_double_tap_ap_cost < 1 then pistol_double_tap_ap_cost = 1;
            pistol_double_tap_to_hit_penalty = get_ini_setting("mods\\F2MechanicsMiniRework.ini|SecondaryAttack|PistolDoubleTapToHitPenalty");
            if pistol_double_tap_to_hit_penalty < 0 then pistol_double_tap_to_hit_penalty = 15;
         end





         SecondaryAttackMod_msg = add_extra_msg_file(msg_file);

         register_hook_proc_spec(HOOK_AFTERHITROLL, AFTERHITROLL);
         register_hook_proc_spec(HOOK_COMBATDAMAGE, COMBATDAMAGE);
         register_hook_proc_spec(HOOK_TARGETOBJECT, TARGETOBJECT);
         register_hook_proc_spec(HOOK_GAMEMODECHANGE, GAMEMODECHANGE);
         register_hook_proc_spec(HOOK_TOHIT, TOHIT);
         if PistolSecondaryAttackMod > 0 then begin
            register_hook_proc_spec(HOOK_MOVECOST, MOVECOST);
            register_hook_proc_spec(HOOK_DEATHANIM2, DEATHANIM2);
            register_hook_proc_spec(HOOK_CALCAPCOST, CALCAPCOST);
            register_hook_proc_spec(HOOK_USEOBJON, USEOBJON);
         end
         register_hook_proc_spec(HOOK_COMBATTURN, COMBATTURN);
         set_global_script_type(0);
         set_global_script_repeat(0);
      end
   end
end