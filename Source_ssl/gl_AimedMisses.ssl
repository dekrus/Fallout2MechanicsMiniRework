#define SFALL_SC_EVALUATION   (true)  // short - circuit evaluation
#define crit_fid(critter_obj)    (obj_art_fid(critter_obj) bwand 0xFFFF0FFF)
#define short_crit(critter_obj)  (crit_fid(critter_obj) == 16777313 or crit_fid(critter_obj) == 16777275 or crit_fid(critter_obj) == 16777271 or crit_fid(critter_obj) == 16777240 or crit_fid(critter_obj) == 16777268)
#define medium_crit(critter_obj) (crit_fid(critter_obj) == 16777276 or crit_fid(critter_obj) == 16777232 or crit_fid(critter_obj) == 16777283 or crit_fid(critter_obj) == 16777291 or crit_fid(critter_obj) == 16777243 or crit_fid(critter_obj) == 16777336 or crit_fid(critter_obj) == 16777270)
#define ShootThru(obj)   ((get_flags(obj) bwand FLAG_SHOOTTHRU) orElse (obj_type(obj) == OBJ_TYPE_CRITTER))
#define CRITICAL_MISS          0
#define MISS                   1
#define HIT                    2
#define CRITICAL_HIT           3
#define weapon_attack_mode1(pid)                        (get_proto_data(pid, PROTO_FLAG_EXT) bwand 0x0000000F)
#define weapon_attack_mode2(pid)                        ((get_proto_data(pid, PROTO_FLAG_EXT) bwand 0x000000F0) / 0x10)
#define weapon_attack_mode(pid, attackType)             (weapon_attack_mode1(pid) if (attackType == ATKTYPE_LWEP1 or attackType == ATKTYPE_RWEP1) else weapon_attack_mode2(pid))

#define critter_art_fid(critter_obj)   (obj_art_fid(critter_obj) bwand 0xFFFF0FFF)
#define is_multihex(critter_obj)  (get_flags(critter_obj) bwand FLAG_MULTIHEX)
#define power_armor_fid(critter_fid)   (critter_fid == FID_HAPOWR or \
                                       critter_fid == FID_NAPOWR or \
                                       critter_fid == FID_HANPWR or \
                                       critter_fid == FID_MABOSS)

#define is_dead(critter_obj) (critter_state(critter_obj) == CRITTER_IS_DEAD orElse get_critter_stat(critter_obj, STAT_current_hp) <= 0)
#define tile_num_beyond(start_tile, next_tile, range) call_offset_r3(0x4B1B84, start_tile, next_tile, range)
#define Is_Crippled_hands(Who)                    (critter_state(Who) BWAND (DAM_CRIP_ARM_LEFT BWOR DAM_CRIP_ARM_RIGHT))

#define get_active_weapon(critter)  critter_inven_obj(critter, (2 - active_hand) if critter == dude_obj else INVEN_TYPE_RIGHT_HAND)

#define pid_scroll_block (0x500000C)
#define FLAGS_GHOST_OBJECT (0xA000101D) //OBJECT_NO_SAVE, FLAG_NOBLOCK, FLAG_SHOOTTHRU,OBJECT_HIDDEN, FLAG_FLAT, FLAG_LIGHTTHRU, FLAG_NOHIGHLIGHT
#define FLAGS_OBJECT_INERT (0x80000014) //OBJECT_NO_SAVE, FLAG_NOBLOCK, FLAG_SHOOTTHRU


#define BODY_HIT_HEAD_NEW_MOD (-60)
#define BODY_HIT_EYES_NEW_MOD (-90)

#include "define_extra.h"
#include "DEFINE.H"
#include "sfall.h"
#include "ARTFID.H"
#include "F2MMR.H"


procedure start;

variable MissMod;
variable BodyRndHit;
variable SwingThrustTweak;
variable dt_mod;
variable dr_mod;
variable dmg_type;
variable thrusthit;
variable missed;
variable newtarget;
variable burst;
variable grenade;
variable pyro_bonus;
variable new_random_target_array;
variable remainder;
variable shootthru_obj_array;
variable shootthru_was_set;
variable target_dummy;
variable one_tme_call;
variable sfall_510;
variable gEyeHitMod;
variable gHeadHitMod;
//variable gDifficultAiming;

inline procedure destroy_pseudo_target begin
   if target_dummy > 0 then begin
      destroy_object(target_dummy);
      target_dummy = 0;
   end
end

procedure CALCAPCOST begin
   variable critter = get_sfall_arg;
   variable Atktype = get_sfall_arg;
   variable is_aimed = get_sfall_arg;
   variable default_ap_cost = get_sfall_arg;
   variable wpn = get_sfall_arg;
   variable wpn_atk_mode;
   variable thrust;
   variable wpnanim;
   variable wpnpid;
   //if shootthru_was_set > 0 then
      //call restore_flags_for_critters;

   if SwingThrustTweak <= 0 orElse wpn <= 0 then
      return;

   wpnpid = obj_pid(wpn);
   wpn_atk_mode = weapon_attack_mode(wpnpid, Atktype);
   if (wpn_atk_mode == ATKMODE_PRI_THRUST andAlso wpn_atk_mode != ATKMODE_PRI_SWING) orElse (wpn_atk_mode == ATKMODE_SEC_THRUST andAlso wpn_atk_mode != ATKMODE_SEC_SWING) then begin
      thrust = 1;
   end

   if thrust > 0 then begin
      wpnanim = get_proto_data(wpnpid, PROTO_WP_ANIM);
      if Atktype % 2 then begin
         if wpnanim == WPN_ANIM_SLEDGEHAMMER then begin
            if get_proto_data(wpnpid, PROTO_WP_RANGE_2) < 3 then
               set_proto_data(wpnpid, PROTO_WP_RANGE_2, 3);
         end
         else if wpnanim == WPN_ANIM_CLUB then begin
            if get_proto_data(wpnpid, PROTO_WP_RANGE_2) < 2 then
               set_proto_data(wpnpid, PROTO_WP_RANGE_2, 2);
         end
      end
      else begin
         if wpnanim == WPN_ANIM_SLEDGEHAMMER then begin
            if get_proto_data(wpnpid, PROTO_WP_RANGE_1) < 3 then
               set_proto_data(wpnpid, PROTO_WP_RANGE_1, 3);
         end
         else if wpnanim == WPN_ANIM_CLUB then begin
            if get_proto_data(wpnpid, PROTO_WP_RANGE_1) < 2 then
               set_proto_data(wpnpid, PROTO_WP_RANGE_1, 2);
         end
      end
   end
end

procedure remove_added_flag_for_objs begin
   variable obj;
   variable mask;

   if shootthru_was_set > 0 then begin
      foreach (obj:mask in shootthru_obj_array) begin
         if mask == 0 then
            continue;

         if mask != 0 then begin
            set_flags(obj, get_flags(obj) bwand mask);
         end
      end
      shootthru_was_set = 0;
      clear_array(shootthru_obj_array);
   end
end

procedure set_shootthru_flag_for_obj(variable obj) begin
   variable obj_flags;
   if not(array_exists(shootthru_obj_array)) then
      shootthru_obj_array = create_array_map;

   obj_flags = get_flags(obj);
   if (obj_flags bwand FLAG_SHOOTTHRU) == 0 then begin
      set_array(shootthru_obj_array, obj, MASK_NO_SHOOTTHRU);
      set_flags(obj, obj_flags bwor FLAG_SHOOTTHRU);
   end
   shootthru_was_set = 1;
end


//Checking Line of fire is(not) blocked
procedure get_first_non_critter_block_shoot(variable obj, variable target_tile) begin
   variable source_tile = tile_num(obj);
   variable current_obj = obj;
   variable iterations;
   variable max_iterations = 20;
   variable obstacle;
   variable obstacle_tile;
   variable last_obstacle;
   variable last_obstacle_tile;

   if obj <= 0 orElse target_tile <= 0 then
      return -1;

   if (source_tile == target_tile) then
      return 0;


   while (iterations < max_iterations) do begin
      iterations += 1;

      obstacle = obj_blocking_line(current_obj, target_tile, BLOCKING_TYPE_SHOOT);

      if (obstacle == 0) then
         return 0;

      obstacle_tile = tile_num(obstacle);

      if (obstacle_tile == target_tile) then
         return 0;

      if (obstacle == last_obstacle orElse obstacle_tile == last_obstacle_tile) then
         return obstacle;

      if (obj_type(obstacle) != OBJ_TYPE_CRITTER) then
         return obstacle;

      last_obstacle_tile = obstacle_tile;
      last_obstacle = obstacle;
      current_obj = obstacle;
   end

   return 0;
end

//Checking Line of fire is(not) blocked
procedure get_first_non_critter_block_shoot_old(variable obj, variable target_tile) begin
   variable source_tile = tile_num(obj);
   variable current_obj = obj;
   variable iterations;
   variable max_iterations = 20;
   variable obstacle;
   variable obstacle_tile;
   variable last_obstacle;
   variable last_obstacle_tile;

   if obj <= 0 orElse target_tile <= 0 then
      return -1;

   if (source_tile == target_tile) then
      return 0;


   while (iterations < max_iterations) do begin
      iterations += 1;

      obstacle = obj_blocking_line(obj, target_tile, BLOCKING_TYPE_SHOOT);

      if (obstacle == 0) then
         break;

      obstacle_tile = tile_num(obstacle);

      if (obstacle_tile == target_tile) then begin
         obstacle = 0;
         break;
      end

      if (obstacle == last_obstacle) then
         break;


      if (obj_type(obstacle) != OBJ_TYPE_CRITTER) then
         break;

      if obstacle > 0 then
         call set_shootthru_flag_for_obj(obstacle);

      last_obstacle_tile = obstacle_tile;
      last_obstacle = obstacle;
      current_obj = obstacle;
   end

   call remove_added_flag_for_objs;
   return obstacle;
end

//by JimTheDinosaur https://nma-fallout.com/threads/stuff-for-define_extra-h.202989/page-2
procedure real_rotation_to_tile(variable begin_tile, variable dest_tile) begin
  	variable temp_dist = tile_distance(begin_tile, dest_tile);
  	variable temp_rot = rotation_to_tile(begin_tile, dest_tile);
  	if temp_rot == 4 then begin
  	   if tile_distance(tile_num_in_direction(begin_tile, temp_rot, temp_dist), dest_tile) > tile_distance(tile_num_in_direction(begin_tile, 5, temp_dist), dest_tile) then
  	      temp_rot = 5;
  	   else if tile_distance(tile_num_in_direction(begin_tile, temp_rot, temp_dist), dest_tile) > tile_distance(tile_num_in_direction(begin_tile, 3, temp_dist), dest_tile) then
  	      temp_rot = 3;
  	   end
  	   else if temp_rot == 1 then begin
  	   if tile_distance(tile_num_in_direction(begin_tile, temp_rot, temp_dist), dest_tile) > tile_distance(tile_num_in_direction(begin_tile, 0, temp_dist), dest_tile) then
  	      temp_rot = 0;
  	   else if tile_distance(tile_num_in_direction(begin_tile, temp_rot, temp_dist), dest_tile) > tile_distance(tile_num_in_direction(begin_tile, 2, temp_dist), dest_tile) then
  	      temp_rot = 2;
  	end
  	return temp_rot;
end

procedure GAMEMODECHANGE begin
   variable lastgamemode = get_sfall_arg_at(1);
   variable cur_HeadHitMod;
   variable cur_EyeHitMod;
   if lastgamemode bwand OPTIONS then begin
      if combat_difficulty >= 2 then begin
         cur_HeadHitMod = get_bodypart_hit_modifier(BODY_HIT_HEAD);
         cur_EyeHitMod = get_bodypart_hit_modifier(BODY_HIT_EYES);
         if cur_HeadHitMod > BODY_HIT_HEAD_NEW_MOD then begin
            gHeadHitMod = cur_HeadHitMod;
            set_bodypart_hit_modifier(BODY_HIT_HEAD, BODY_HIT_HEAD_NEW_MOD);
         end
         if cur_EyeHitMod > BODY_HIT_EYES_NEW_MOD then begin
            gEyeHitMod = cur_EyeHitMod;
            set_bodypart_hit_modifier(BODY_HIT_EYES, BODY_HIT_EYES_NEW_MOD);
         end
      end
      else begin
         if get_bodypart_hit_modifier(BODY_HIT_HEAD) == BODY_HIT_HEAD_NEW_MOD then
            set_bodypart_hit_modifier(BODY_HIT_HEAD, gHeadHitMod);
         if get_bodypart_hit_modifier(BODY_HIT_EYES) == BODY_HIT_EYES_NEW_MOD then
            set_bodypart_hit_modifier(BODY_HIT_EYES, gEyeHitMod);
      end
   end
end

procedure COMBATTURN begin
   if get_sfall_arg_at(0) <= 0 then begin
      call destroy_pseudo_target;
   end
end

procedure get_attack_anim(variable weapon,variable attack_type) begin
   variable attack_anim;
   variable attack_anim_arr;
   variable index;
   if attack_type >= ATKTYPE_LWEP_RELOAD andAlso attack_type <= ATKTYPE_RWEP_RELOAD then begin
      return -1;
   end
   //kick
   if attack_type == ATKTYPE_KICK orElse (attack_type >= ATKTYPE_STRONGKICK andAlso attack_type <= ATKTYPE_PIERCINGKICK) then begin
      return ANIM_kick_leg;
   end
   //punch
   if weapon <= 0 then begin
      return ANIM_throw_punch;
   end
   attack_anim_arr = [ANIM_stand, ANIM_throw_punch, ANIM_kick_leg, ANIM_swing_anim, ANIM_thrust_anim, ANIM_throw_anim, ANIM_fire_single, ANIM_fire_burst, ANIM_fire_continuous];
   if attack_type == ATKTYPE_LWEP1 OrElse attack_type == ATKTYPE_RWEP1 then begin
      index = get_proto_data(obj_pid(weapon), PROTO_FLAG_EXT) bwand 0x0000000F;
   end
   else begin
      index = (get_proto_data(obj_pid(weapon), PROTO_FLAG_EXT) bwand 0x000000F0) / 16;
   end
   attack_anim = attack_anim_arr[index];
   return attack_anim;
end

procedure get_weapon_skill_lvl(variable attacker, variable weapon, variable attack_anim) begin
   variable wpn_flags;
   variable wpn_dmg_type;
   variable weapon_skill;
   if weapon <= 0 orElse attack_anim == ANIM_kick_leg orElse attack_anim == ANIM_throw_punch then
      return has_skill(attacker, SKILL_UNARMED_COMBAT);
   else if attack_anim == ANIM_throw_anim then
      return has_skill(attacker, SKILL_THROWING);
   else if attack_anim == ANIM_swing_anim orElse attack_anim == ANIM_thrust_anim then
      return has_skill(attacker, SKILL_MELEE);


   wpn_flags = get_proto_data(obj_pid(weapon), PROTO_FLAG_EXT);
   wpn_dmg_type = get_proto_data(obj_pid(weapon), PROTO_WP_DMG_TYPE);

   if ((wpn_flags bwand WEAPON_ENERGY) == WEAPON_ENERGY) or wpn_dmg_type == DMG_laser or wpn_dmg_type == DMG_plasma or wpn_dmg_type == DMG_electrical then begin
      weapon_skill = has_skill(attacker, SKILL_ENERGY_WEAPONS);
   end
   else begin
      if (wpn_flags bwand WEAPON_BIGGUN ) == WEAPON_BIGGUN then begin
         weapon_skill = has_skill(attacker, SKILL_BIG_GUNS);
      end
      else begin
         weapon_skill = has_skill(attacker, SKILL_SMALL_GUNS);
      end
   end
   return weapon_skill;
end

procedure TOHIT begin
   variable hit_capped = get_sfall_arg;
   variable attacker = get_sfall_arg;
   variable target = get_sfall_arg;
   variable body_part = get_sfall_arg;
   variable Atktype = get_sfall_arg_at(5);
   variable hit_uncapped = get_sfall_arg_at(7);
   variable wpn_flags;
   variable leftHand_obj;
   variable rightHand_obj;
   variable leftHand;
   variable rightHand;
   variable wpn;
   variable wpnanim;
   variable swing;
   variable atkrskill;
   variable tarAg;
   variable Newhitch = -100;
   variable max_hit_cap;
   //variable new_hit_cap;
   //variable attack_anim;
   //variable weapon_skill;
   //variable body_part_penalty;
   //variable distance;
   //variable skill_Mod;
   //variable attacker_pe_check;
   //variable weapon_perk;
   if hit_capped > 95 orElse hit_capped < hit_uncapped then begin
      max_hit_cap = hit_capped;
   end else
      max_hit_cap = 95;

   //if body_part != BODY_UNCALLED andAlso body_part != BODY_HIT_TORSO andAlso ((gDifficultAiming > 0 andAlso combat_difficulty >= 2) orElse gDifficultAiming >= 2) then begin
//
      //wpn = get_active_weapon(attacker);
      //attack_anim = get_attack_anim(wpn, Atktype);
      //weapon_skill = get_weapon_skill_lvl(attacker, wpn, attack_anim);
      //body_part_penalty = get_bodypart_hit_modifier(body_part);
      //if weapon_skill >= SKILL_UNARMED_COMBAT then
         //body_part_penalty = body_part_penalty / 2;
      //if body_part == BODY_HIT_EYES orElse body_part == BODY_HIT_HEAD then
         //body_part_penalty = body_part_penalty  * 3 / 2;
      //else
         //new_hit_cap = 5;
//
      //distance_objs(distance, attacker, target);
      //attacker_pe_check = get_critter_stat(attacker, STAT_pe) * 5;
      //if distance > attacker_pe_check then
         //distance += distance - attacker_pe_check;
      //weapon_perk = get_proto_data(obj_pid(wpn), PROTO_WP_PERK);
      //if weapon_perk == PERK_weapon_long_range orElse weapon_perk == PERK_weapon_scope_range then
         //distance = distance / 2;
//
      //skill_mod = 1.0 - (weapon_skill / 200.0);
      //new_hit_cap += max_hit_cap + (body_part_penalty - distance * 2) * skill_mod;
      //new_hit_cap = ceil(new_hit_cap);
//
      //if new_hit_cap > max_hit_cap then
         //new_hit_cap = max_hit_cap;
      //else if new_hit_cap < -99 then
         //new_hit_cap = -99;
//
      //if hit_capped > new_hit_cap then begin
         //Newhitch = new_hit_cap;
      //end
   //end

   one_tme_call = 0;
   if SwingThrustTweak > 0 andAlso attacker != target then begin
      // player attacker
      if attacker == dude_obj then begin
         if active_hand then begin
            rightHand_obj = critter_inven_obj(attacker, INVEN_TYPE_RIGHT_HAND);
            if rightHand_obj then begin
               rightHand = obj_pid(rightHand_obj);
            end
         end
         else begin
            leftHand_obj = critter_inven_obj(attacker, INVEN_TYPE_LEFT_HAND);
            if leftHand_obj then begin
               leftHand = obj_pid(leftHand_obj);
            end
         end
      end
      // non player attacker
      else begin
         rightHand_obj = critter_inven_obj(attacker, INVEN_TYPE_RIGHT_HAND);
         if rightHand_obj then begin
            rightHand = obj_pid(rightHand_obj);
         end
      end
      // left hand attack
      if leftHand_obj then begin
         //if left hand first attack mode
         if Atktype == ATKTYPE_LWEP1 then begin
            wpn = leftHand;
            if wpn > 0 then wpnanim = get_proto_data(wpn, 36);
            wpn_flags = get_proto_data(wpn, PROTO_FLAG_EXT);
            if wpnanim == WPN_ANIM_KNIFE or wpnanim == 14 then begin
               if (wpn_flags bwand ATKMODE_PRI_SWING) == 3 then begin
                  swing = 1;
               end
               //if (wpn_flags bwand ATKMODE_PRI_THRUST) == 4 then begin
                  //thrust = 1;
               //end
            end
         end
         //if left hand second attack mode
         else if Atktype == ATKTYPE_LWEP2 then begin
            wpn = leftHand;
            if wpn > 0 then wpnanim = get_proto_data(wpn, 36);
            wpn_flags = get_proto_data(wpn, PROTO_FLAG_EXT);
            if wpnanim == WPN_ANIM_KNIFE or wpnanim == 14 then begin
               if (wpn_flags bwand ATKMODE_SEC_SWING) == 48 then begin
                  swing = 1;
               end
               //if (wpn_flags bwand ATKMODE_SEC_THRUST) == 64 then begin
                  //thrust = 1;
               //end
            end
         end
      end
      // right hand attack
      if rightHand_obj then begin
          //if right hand first attack mode
         if Atktype ==  ATKTYPE_RWEP1 then begin
            wpn = rightHand;
            if wpn > 0 then wpnanim = get_proto_data(wpn, 36);
            wpn_flags = get_proto_data(wpn, PROTO_FLAG_EXT);
            if wpnanim == WPN_ANIM_KNIFE or wpnanim == 14 then begin
               if (wpn_flags bwand ATKMODE_PRI_SWING) == 3 then begin
                  swing = 1;
               end
               //if (wpn_flags bwand ATKMODE_PRI_THRUST) == 4 then begin
                  //thrust = 1;
               //end
            end
         end
         //if right hand second attack mode
         else if Atktype ==  ATKTYPE_RWEP2 then begin
            wpn = rightHand;
            if wpn > 0 then wpnanim = get_proto_data(wpn, 36);
            wpn_flags = get_proto_data(wpn, PROTO_FLAG_EXT);
            if wpnanim == WPN_ANIM_KNIFE or wpnanim == 14 then begin
               if (wpn_flags bwand ATKMODE_SEC_SWING) == 48 then begin
                  swing = 1;
               end
               //if (wpn_flags bwand ATKMODE_SEC_THRUST) == 64 then begin
                  //thrust = 1;
               //end
            end
         end
      end

      //New effect for swing and thust attacks
      if hit_uncapped < max_hit_cap andAlso target andAlso swing == 1 andAlso (wpnanim == WPN_ANIM_KNIFE or wpnanim == 14)  then begin // Wakizashi use unique animation so 14
         atkrskill = has_skill(attacker, SKILL_MELEE);
         tarAg = get_critter_stat(target, STAT_ag);
         Newhitch = hit_uncapped + 5 + tarAg + (atkrskill / 15); // increas hit chance
         hit_uncapped = Newhitch;
         //set_sfall_arg(7, Newhitch);
         if Newhitch > max_hit_cap then begin
            Newhitch = max_hit_cap;
         end
         //set_sfall_return(Newhitch);
         //set_sfall_arg(0, Newhitch);
      end
   end

   if Newhitch != -100 then begin
      set_sfall_arg(7, hit_uncapped);
      if Newhitch > max_hit_cap then begin
         Newhitch = max_hit_cap;
      end
      set_sfall_return(Newhitch);
      set_sfall_arg(0, Newhitch);
   end
end

procedure COMBATDAMAGE begin
   variable target = get_sfall_arg;
   variable attacker = get_sfall_arg;
   variable dmgtotar = get_sfall_arg;
   variable dmgtoatk = get_sfall_arg;
   variable tar_flags = get_sfall_arg;
   variable atk_flags = get_sfall_arg;
   variable weapon = get_sfall_arg;
   variable knockback_distance = get_sfall_arg_at(10);
   variable atktype = get_sfall_arg_at(11);
   variable wpn_flags;
   variable attacker_melee_dmg;
   variable target_type;
   variable target_kill_type;
   variable rnd;
   variable wpnpid;
   variable wpnanim;
   variable wpnmindmg;
   variable wpnmaxdmg;
   variable newdmg;
   variable swing;
   variable thrust;
   variable wpn_dmg_type;
   variable new_target_dist = -2;
   variable tar_max_hp;
   variable tar_dt;
   variable tardt_extra;
   variable tardr_extra;
   variable knockback_bonus_dmg;
   variable knockback_tile;
   variable knockback_tile_block;
   variable knockback_tile_block_distance;
   variable actual_target = get_object_data(combat_data, C_ATTACK_TARGET);
   variable actual_attack;
   if (attacker != dude_obj andAlso actual_target > 0) orElse (attacker == dude_obj) then begin
      actual_attack = 1;
   end
   if actual_attack > 0 andAlso target > 0 then begin
      if weapon > 0 then begin
         wpn_dmg_type = metarule(METARULE_W_DAMAGE_TYPE, weapon);
         wpnpid = obj_pid(weapon);
      end
      target_type = obj_type(target);
      //swingThrust
      if SwingThrustTweak > 0 andAlso wpnpid > 0 andAlso target_type == OBJ_TYPE_CRITTER then begin
         wpn_flags = get_proto_data(wpnpid, PROTO_FLAG_EXT);
         wpnanim = get_proto_data(wpnpid, PROTO_WP_ANIM);
         if Atktype == ATKTYPE_LWEP1 then begin // left first attack mode
            if (wpn_flags bwand ATKMODE_PRI_SWING) == 3 then begin
               swing = 1;
            end
            if (wpn_flags bwand ATKMODE_PRI_THRUST) == 4 then begin
               thrust = 1;
            end
         end
         if Atktype ==  ATKTYPE_LWEP2 then begin // left second attack mode
            if (wpn_flags bwand ATKMODE_SEC_SWING) == 48 then begin
               swing = 1;
            end
            if (wpn_flags bwand ATKMODE_SEC_THRUST) == 64 then begin
               thrust = 1;
            end
         end
         if Atktype ==  ATKTYPE_RWEP1 then begin // right 1 attack
            if (wpn_flags bwand ATKMODE_PRI_SWING) == 3 then begin
               swing = 1;
            end
            if (wpn_flags bwand ATKMODE_PRI_THRUST) == 4 then begin
               thrust = 1;
            end
         end
         if Atktype ==  ATKTYPE_RWEP2 then begin // right 2 attack
            if (wpn_flags bwand ATKMODE_SEC_SWING) == 48 then begin
               swing = 1;
            end
            if (wpn_flags bwand ATKMODE_SEC_THRUST) == 64 then begin
               thrust = 1;
            end
         end

         //New effect for swing and thust attacks
         if swing == 1 andAlso target_type == OBJ_TYPE_CRITTER then begin
            // knifes
            if (wpnanim == WPN_ANIM_KNIFE or wpnanim == 14) then begin
               tardt_extra = get_critter_extra_stat(target, (STAT_dmg_thresh + dmg_type));
               tar_dt = get_critter_stat(target, (STAT_dmg_thresh + dmg_type));
               if tar_dt <= 3 then begin // more likely to deal maximum damage when attacking low armored target
                  wpnmaxdmg = get_proto_data(wpnpid, PROTO_WP_DMG_MAX);
                  wpnmindmg = 1 + get_proto_data(wpnpid, PROTO_WP_DMG_MIN);
                  attacker_melee_dmg = get_critter_stat(attacker, STAT_melee_dmg);
                  //inc min wpn dmg by half of diff max-min dmg
                  wpnmindmg += random(1,attacker_melee_dmg);
                  wpnmaxdmg += attacker_melee_dmg;
                  newdmg = random(wpnmindmg, wpnmaxdmg);
                  if tar_dt > 0 then begin
                     newdmg -= tar_dt;
                  end
                  newdmg -= get_critter_stat(target, (STAT_dmg_resist + dmg_type)) * newdmg / 100;
                  newdmg += has_trait(TRAIT_PERK, attacker, PERK_living_anatomy_perk) * 5;
                  if wpn_dmg_type == DMG_fire andAlso has_trait(TRAIT_PERK, attacker, PERK_pyromaniac_perk) then begin
                     newdmg += pyro_bonus;
                  end
                  if dmgtotar < newdmg then begin
                     set_sfall_return(newdmg);
                     set_sfall_arg(2, newdmg);
                     return;
                  end
               end
            end
            //
            else if wpnanim == WPN_ANIM_CLUB or wpnanim == WPN_ANIM_SLEDGEHAMMER then begin
               if not(tar_flags bwand DAM_KNOCKED_DOWN) andAlso not(tar_flags bwand DAM_KNOCKED_OUT) then begin
                  rnd = random(0, 90);
                  target_kill_type = metarule(METARULE_CRITTER_KILL_TYPE, target);
                  tar_max_hp = get_critter_stat(target, STAT_max_hp);
                  if target_kill_type == KILL_TYPE_super_mutant_kills or target_kill_type == KILL_TYPE_deathclaw_kills or target_kill_type == KILL_TYPE_robot_kills or power_armor_fid(obj_art_fid(target)) then begin
                     knockback_distance *= 4;
                  end
                  else begin
                     knockback_distance *= 7;
                  end
                  if dmgtotar > (tar_max_hp / 3) then begin
                     rnd -= 20;
                  end
                  if knockback_distance > 40 then
                     knockback_distance = 40;
                  set_sfall_return(dmgtotar);
                  set_sfall_arg(2, dmgtotar);
                  set_sfall_return(dmgtoatk);
                  set_sfall_arg(3, dmgtoatk);
                  if rnd < knockback_distance then begin
                     set_sfall_return(tar_flags bwor DAM_KNOCKED_DOWN);
                     set_sfall_arg(4, tar_flags bwor DAM_KNOCKED_DOWN);
                  end
                  else begin
                     set_sfall_return(tar_flags);
                     set_sfall_arg(4, tar_flags);
                  end
                  set_sfall_return(atk_flags);
                  set_sfall_arg(5, atk_flags);
                  set_sfall_return(0);
                  set_sfall_arg(10, 0);
               end
               else begin
                  set_sfall_return(dmgtotar);
                  set_sfall_arg(2, dmgtotar);
                  set_sfall_return(dmgtoatk);
                  set_sfall_arg(3, dmgtoatk);
                  set_sfall_return(tar_flags);
                  set_sfall_arg(4, tar_flags);
                  set_sfall_return(atk_flags);
                  set_sfall_arg(5, atk_flags);
                  set_sfall_return(0);
                  set_sfall_arg(10, 0);
               end
               return;
            end
         end
         if thrusthit == 1 andAlso thrust == 1 then begin
            if (wpnanim == WPN_ANIM_KNIFE or wpnanim == 14) then begin
               if dt_mod > 0 then begin
                  tardt_extra = get_critter_extra_stat(target, (STAT_dmg_thresh + dmg_type));
                  set_critter_extra_stat(target, (STAT_dmg_thresh + dmg_type), (tardt_extra + dt_mod));
               end
               tardr_extra = get_critter_extra_stat(target, (STAT_dmg_resist + dmg_type));
               set_critter_extra_stat(target, (STAT_dmg_resist + dmg_type), (tardr_extra + dr_mod));
            end
            else if wpnanim == WPN_ANIM_SLEDGEHAMMER or wpnanim == WPN_ANIM_CLUB then begin
               if knockback_distance <= 0 then begin
                  return;
               end
               knockback_tile = tile_num_in_direction(tile_num(target),(rotation_to_tile(tile_num(target),tile_num(attacker)) + 3) % 6,knockback_distance);
               knockback_tile_block = obj_blocking_line(target,knockback_tile,BLOCKING_TYPE_BLOCK);
               if knockback_tile_block > 0 then begin
                  distance_objs(knockback_tile_block_distance, target, knockback_tile_block);
                  if dmgtotar > 0 then begin
                     knockback_bonus_dmg = 2 * (knockback_distance - knockback_tile_block_distance);
                     if knockback_bonus_dmg > dmgtotar / 2 then
                        knockback_bonus_dmg = dmgtotar / 2;

                     if knockback_bonus_dmg > 0 then begin
                        dmgtotar += knockback_bonus_dmg;
                        set_sfall_return(dmgtotar);
                        set_sfall_arg(2, dmgtotar);
                        return;
                     end
                  end
               end
            end
         end
      end
   end
end

procedure is_tile_in_cone_coord(variable check_tile, variable attacker_tile, variable attacker_x, variable attacker_y, variable target_x, variable target_y, variable direction_x, variable direction_y, variable direction_length, variable cone_width_mod, variable weapon_skill) begin
   variable check_x, check_y;
   variable check_vector_x, check_vector_y;
   variable dot_product, projection_length, projection_x, projection_y, distance_to_projection_sq, cone_radius_sq;
   variable max_cone_width = 3.5;
   variable min_cone_width = 0.1;
   variable width_range;
   variable width_factor;
  	variable temp_dist;
  	variable temp_rot;
  	variable new_temp_dist;
   max_cone_width += cone_width_mod;
   if max_cone_width < 0.5 then begin
      max_cone_width = 0.5;
   end
   else if max_cone_width > 7.5 then begin
      max_cone_width = 7.5;
   end

   width_range = max_cone_width - min_cone_width;


   check_x = (check_tile % 200);
   check_y = check_tile / 200;

   check_vector_x = check_x - attacker_x;
   check_vector_y = check_y - attacker_y;

   dot_product = check_vector_x * direction_x + check_vector_y * direction_y;
   if dot_product < 0 then
     return false;

   projection_length = dot_product;
   projection_x = attacker_x + projection_length * direction_x;
   projection_y = attacker_y + projection_length * direction_y;

   distance_to_projection_sq = (check_x - projection_x)^2 + (check_y - projection_y)^2;

   width_factor = min_cone_width + width_range * (1 - exponent(-projection_length / 20.0)); // Для менее привилегированных направлений
   cone_radius_sq = width_factor^2;

   temp_rot = rotation_to_tile(attacker_tile, check_tile);
   if temp_rot == 1 orElse temp_rot == 4 then begin
      temp_dist = tile_distance(attacker_tile, check_tile);
  	   new_temp_dist = tile_distance(tile_num_in_direction(attacker_tile, temp_rot, temp_dist), check_tile);
     	if temp_rot == 4 then begin
     	   if new_temp_dist > tile_distance(tile_num_in_direction(attacker_tile, 5, temp_dist), check_tile) then
     	      cone_radius_sq *= 0.5;
     	   else if new_temp_dist > tile_distance(tile_num_in_direction(attacker_tile, 3, temp_dist), check_tile) then
     	      cone_radius_sq *= 0.5;
     	   end
     	   else if temp_rot == 1 then begin
     	   if new_temp_dist > tile_distance(tile_num_in_direction(attacker_tile, 0, temp_dist), check_tile) then
     	      cone_radius_sq *= 0.5;
     	   else if new_temp_dist > tile_distance(tile_num_in_direction(attacker_tile, 2, temp_dist), check_tile) then
     	      cone_radius_sq *= 0.5;
     	end
   end

   if (distance_to_projection_sq <= cone_radius_sq) then
    return 1;
end

procedure re_count(variable counter) begin
   variable counter_floor = floor(counter);
   if (floor(remainder + counter) > counter_floor) then begin
      remainder = remainder + counter - floor(remainder + counter);
      return floor(counter + 1);
   end
   else begin
      remainder = remainder + (counter - counter_floor);
      return counter_floor;
   end
end

procedure get_last_tile_on_line(variable begin_tile, variable dest_tile, variable range) begin
   variable attacker_rotation_to_target = rotation_to_tile(begin_tile, dest_tile);
   variable temp_dist = tile_distance(begin_tile, dest_tile);
   variable temp_rot = rotation_to_tile(begin_tile, dest_tile);
   variable check_tile;
   variable temp_tile_in_dir;
   variable temp_dist_in_dir;
   variable temp_rot_in_dir;
   variable side,counter,tile_count;

   if temp_rot == 4 then begin
      if tile_distance(tile_num_in_direction(begin_tile, temp_rot, temp_dist), dest_tile) > tile_distance(tile_num_in_direction(begin_tile, 5, temp_dist), dest_tile) then
         temp_rot = 5;
      else if tile_distance(tile_num_in_direction(begin_tile, temp_rot, temp_dist), dest_tile) > tile_distance(tile_num_in_direction(begin_tile, 3, temp_dist), dest_tile) then
         temp_rot = 3;
   end
   else if temp_rot == 1 then begin
      if tile_distance(tile_num_in_direction(begin_tile, temp_rot, temp_dist), dest_tile) > tile_distance(tile_num_in_direction(begin_tile, 0, temp_dist), dest_tile) then
         temp_rot = 0;
      else if tile_distance(tile_num_in_direction(begin_tile, temp_rot, temp_dist), dest_tile) > tile_distance(tile_num_in_direction(begin_tile, 2, temp_dist), dest_tile) then
         temp_rot = 2;
   end

   temp_tile_in_dir = tile_num_in_direction(begin_tile, temp_rot, temp_dist);
   temp_dist_in_dir = tile_distance(temp_tile_in_dir, dest_tile);
   temp_rot_in_dir = rotation_to_tile(temp_tile_in_dir, dest_tile);

   remainder = 0;
   tile_count = 0;
   temp_dist *= 1.0;

   if temp_dist_in_dir == 0 then begin
      side = 0;
   end
   else begin
      if temp_rot_in_dir == (temp_rot + 2) % 6 then begin
         side = 1;
      end
      else begin
         if temp_rot_in_dir == (temp_rot + 4) % 6 then begin
            side = 5;
         end
      end
   end
   if side != 0 then begin
      counter = temp_dist / temp_dist_in_dir / 1.5;
   end
   else begin
      counter = 50.0;
   end

   while tile_count < range do begin
      if counter >= 1.0 then begin
         if check_tile == 0 then
            check_tile = begin_tile;
         else
            check_tile = tile_num_in_direction(check_tile, temp_rot, 1);
         counter -= 1.0;
         //create_object(33555753, check_tile, line_elevation);
      end
      else begin
         check_tile = tile_num_in_direction(check_tile, ((temp_rot+side) % 6), 1);
         counter = temp_dist / temp_dist_in_dir + re_count(counter) - 1.0;
         //create_object(205, check_tile, line_elevation);
      end
      tile_count += 1;


   end
   return check_tile;
end

procedure max(variable a, variable b) begin
   if (a > b) then
      return a;

   return b;
end

procedure min(variable a, variable b) begin
   if (a < b) then
      return a;

   return b;
end

procedure get_critters_in_cone(variable attacker, variable target, variable wpn_range, variable weapon_skill, variable rnd) begin
   variable end_tile;
   variable attacker_tile = tile_num(attacker);
   variable target_tile = tile_num(target);
   variable attacker_x, attacker_y, target_x, target_y;
   variable direction_x, direction_y, direction_length;
   variable new_target;
   variable new_target_tile;
   variable new_targets_in_radius;
   variable attacker_rot_to_target = rotation_to_tile(attacker_tile,target_tile);
   variable new_target_count;
   variable cone_width_mod;
   variable distance = tile_distance(attacker_tile, target_tile);
   variable base_skill_factor;
   variable distance_influence;
   variable attempts;
   variable start_dir = random(0, 5);
   variable current_dir = start_dir;
   variable new_range;

   if weapon_skill < 1 then
      weapon_skill = 1;
   end_tile = get_last_tile_on_line(attacker_tile, target_tile, wpn_range);

   if rnd > 14 then begin

      clear_array(new_random_target_array);
      base_skill_factor = 4.0 - (weapon_skill * 8.0 / 300.0);

      distance_influence = 0.01 + (weapon_skill * 0.06 / 300.0);

      cone_width_mod = base_skill_factor - distance * distance_influence;




      attacker_x = (attacker_tile % 200);
      attacker_y = attacker_tile / 200;
      target_x = (target_tile % 200);
      target_y = target_tile / 200;
      direction_x = target_x - attacker_x;
      direction_y = target_y - attacker_y;

      direction_length = (1.0 * sqrt(direction_x^2 + direction_y^2));
      if (direction_length == 0) then
        return -1;

      direction_x = direction_x / direction_length;
      direction_y = direction_y / direction_length;

      new_targets_in_radius = objects_in_radius(attacker_tile, wpn_range, elevation(attacker), OBJ_TYPE_CRITTER);
      foreach new_target in new_targets_in_radius begin
         if new_target <= 0 orElse new_target == attacker orElse new_target == target then
            continue;

         new_target_tile = tile_num(new_target);
         if new_target_tile == attacker_tile orElse new_target_tile == target_tile orElse rotation_to_tile(attacker_tile, new_target_tile) != attacker_rot_to_target then
            continue;

         if not(is_dead(new_target)) andAlso obj_is_visible_flag(new_target) then begin
            if not(is_in_array(new_target,new_random_target_array)) andAlso (is_tile_in_cone_coord(new_target_tile,attacker_tile,attacker_x,attacker_y,target_x,target_y,direction_x,direction_y,direction_length, cone_width_mod, weapon_skill)) then begin
               if get_first_non_critter_block_shoot(attacker, new_target_tile) <= 0 then begin
                  set_array(new_random_target_array, new_target_count, new_target);
                  new_target_count += 1;
               end
            end
         end
      end
   end
   while attempts < 6 do begin
      new_range = wpn_range * (0.15 - (weapon_skill * 0.18 / 270.0));
      new_range = ceil(new_range);
      if new_range < 1 then
         new_range = 1;
      new_range = random(1, new_range);
      end_tile = tile_num_in_direction(end_tile, current_dir, new_range);

      if rotation_to_tile(attacker_tile, end_tile) == attacker_rot_to_target then
         return end_tile;

      current_dir = (current_dir + 1) % 6;

      attempts += 1;
   end

   return end_tile;
end

procedure get_miss_tile(variable attacker, variable target, variable range, variable weapon, variable weapon_attack_anim) begin
   variable shot_deviation = 6;
   variable min_shot_deviation = 1;
   variable start_tile = tile_num(attacker);
   variable next_tile = tile_num(target);
   variable distance = tile_distance(start_tile, next_tile);
   variable rot_to_target = rotation_to_tile(start_tile, next_tile);
   variable miss_tile = tile_num_beyond(start_tile, next_tile, 50);
   variable tmp_rot;
   variable rnd_rot = random(0, 5);
   variable cur_rot;
   variable tmp_dist;
   variable rnd_dist;
   variable cur_dist;
   variable cur_tile;
   variable attacker_pe = ((get_critter_stat(attacker, STAT_pe) + has_trait(TRAIT_PERK, attacker, PERK_sharpshooter) * 2) / 2.0);
   variable attacker_st = (get_critter_stat(attacker, STAT_st) + has_trait(TRAIT_PERK, attacker, PERK_weapon_handling_perk) * 3);
   variable weapon_pid = obj_pid(weapon);
   variable weapon_perk = get_proto_data(weapon_pid, PROTO_WP_PERK);
   variable weapon_min_st  = get_proto_data(weapon_pid, PROTO_WP_MIN_ST);
   variable st_diff = attacker_st - weapon_min_st;
   variable weapon_is_two_handed = ((get_proto_data(weapon_pid, PROTO_FLAG_EXT) bwand WEAPON_2HAND) == WEAPON_2HAND);
   variable weapon_skill = get_weapon_skill_lvl(attacker, weapon, weapon_attack_anim);
   variable attacker_state = critter_state(attacker);
   variable attacker_is_blind = (attacker_state bwand DAM_BLIND);
   variable attacker_has_crippled_hand_left = (attacker_state bwand DAM_CRIP_ARM_LEFT);
   variable attacker_has_crippled_hand_right = (attacker_state bwand DAM_CRIP_ARM_RIGHT);

   if attacker_is_blind then
      shot_deviation += 3;
   if attacker_has_crippled_hand_left then begin
      if weapon_is_two_handed orElse weapon == critter_inven_obj2(attacker, INVEN_TYPE_LEFT_HAND) then
         shot_deviation += 1;
   end
   if attacker_has_crippled_hand_right then begin
      if weapon_is_two_handed orElse weapon == critter_inven_obj2(attacker, INVEN_TYPE_RIGHT_HAND) then
         shot_deviation += 1;
   end

   if weapon_perk == PERK_weapon_accurate then
      shot_deviation -= 1;
   else if weapon_perk == PERK_weapon_scope_range then begin
      if tile_distance(start_tile, next_tile) <= 8 then
         shot_deviation += 1;
      else
         shot_deviation -= 2;
   end
   else if weapon_perk == PERK_weapon_long_range then begin
      attacker_pe *= 1.1;
   end

   shot_deviation -= weapon_skill * (0.002593 * attacker_pe + 0.007407);


   if st_diff < 0 then
      shot_deviation -= st_diff / 1.5;

   if distance > (attacker_pe * 2) then
      shot_deviation += (distance - (attacker_pe * 2)) * 0.1;


   if shot_deviation >= 5 then begin
      min_shot_deviation = shot_deviation / 3;
      min_shot_deviation = round(min_shot_deviation);
   end

   if shot_deviation <= min_shot_deviation then begin
      shot_deviation = min_shot_deviation;
   end
   else if shot_deviation > 14 then begin
      shot_deviation = 14;
   end
   else
      shot_deviation = round(shot_deviation);


   rnd_dist = random(min_shot_deviation, shot_deviation);

   for (tmp_rot := 0; tmp_rot < 6; tmp_rot++) begin
      cur_rot = (tmp_rot + rnd_rot) % 6;
      if cur_rot != rot_to_target andAlso cur_rot != (rot_to_target + 3) % 6 then begin
         cur_tile = 0;
         for (tmp_dist := 0; tmp_dist < shot_deviation; tmp_dist++) begin
            cur_dist = ((tmp_dist + rnd_dist) % shot_deviation);
            cur_tile = tile_num_in_direction(miss_tile, cur_rot, cur_dist);
            if rotation_to_tile(start_tile, cur_tile) == rot_to_target then begin
               break;
            end else begin
               cur_tile = tile_num_in_direction(miss_tile, (cur_rot+3)%6, (cur_dist / 2) + 1);
               if rotation_to_tile(start_tile, cur_tile) == rot_to_target then begin
                  break;
               end
            end

         end
         if cur_tile != 0 then
            break;
      end
   end
   if cur_tile <= 0 then
      miss_tile = next_tile;
   else
      miss_tile = get_last_tile_on_line(start_tile, cur_tile, range);
   return miss_tile;
end

///get targets on "WIDE" line using obj_blocking_line
procedure get_targets_on_a_line(variable attacker, variable target, variable end_tile, variable max_distance) begin
   variable source_tile = tile_num(attacker);
   variable current_obj = attacker;
   variable rot_to_tar = rotation_to_tile(source_tile, end_tile);
   variable start_tile = tile_num_in_direction(source_tile, rot_to_tar, 1);
   variable last_obstacle;
   variable iterations;
   variable max_iterations = 15;
   variable new_target_count;
   variable obstacle;
   variable obstacle_tile;

   if attacker <= 0 orElse end_tile <= 0 then
      return -1;

   if (source_tile == end_tile) then
      return 0;

   if array_exists(new_random_target_array) then
      clear_array(new_random_target_array);
   else
      new_random_target_array = create_array_map;

   obstacle = obj_blocking_tile(start_tile, elevation(attacker), BLOCKING_TYPE_SHOOT);
   while (iterations < max_iterations) do begin
      iterations += 1;

      if obstacle <= 0 then
         obstacle = obj_blocking_line(attacker, end_tile, BLOCKING_TYPE_SHOOT);



      if (obstacle == 0) then
         break;

      if (obj_type(obstacle) == OBJ_TYPE_CRITTER) then begin
         if obstacle != attacker andALso obstacle != target andAlso not(is_in_array(obstacle, new_random_target_array)) andAlso not(is_really_dead(obstacle, critter_state(obstacle), get_critter_stat(obstacle, STAT_current_hp))) then begin
            obstacle_tile = tile_num(obstacle);
            if obstacle_tile != source_tile andAlso rotation_to_tile(source_tile, obstacle_tile) == rot_to_tar andAlso tile_distance(obstacle_tile, source_tile) <= max_distance then begin
               set_array(new_random_target_array, new_target_count, obstacle);
               new_target_count += 1;
            end
         end
      end else
            break;

      if (tile_num(obstacle) == end_tile) then begin
         obstacle = 0;
         break;
      end

      if (obstacle == last_obstacle) then
         break;

      if obstacle > 0 then
         call set_shootthru_flag_for_obj(obstacle);

      last_obstacle = obstacle;
      current_obj = obstacle;
   end
   call remove_added_flag_for_objs;

   if (obstacle > 0 andAlso obj_type(obstacle) == OBJ_TYPE_CRITTER) then
      return 0;

   return obstacle;
end


procedure AFTERHITROLL begin
   variable hitmiss = 0;
   variable attacker = 0;
   variable target = 0;
   variable bpart = 0;
   variable hitch = 0;
   variable rnd = 0;
   variable rnd2 = 0;
   variable rnd3 = 0;
   variable rotationatkr = -1;
   variable oldrotationatkr = -1;
   variable rotationtar = -1;
   variable rotationnewtar = -1;
   variable new_target;
   variable new_target_2;
   variable weapon;
   variable weapon_pid;
   variable weapon_attack_anim;
   variable distance_to_tar;
   variable wpnanim;
   variable wpn_dmg_type;
   variable wpn_range;
   variable swing;
   variable thrust;
   variable shortcritfrm;
   variable rndarm;
   variable rndleg;
   variable critter_type;
   variable tar_cur_frm;
   variable attacker_meleedmg;
   variable wpn_maxdmg;
   variable wpn_mindmg;
   variable wpn_perk;
   variable tar_fid;
   variable atk_mode;
   variable combat_diff;
   variable tar_tile;
   variable atk_tile;
   variable critter_tile;
   variable tardt_extra;
   variable tardr_extra;
   variable new_random_target_array_len;
   variable miss_tile;
   variable weapon_skill;
   variable new_result;
   if one_tme_call > 0 then
      return;

   one_tme_call = 1;
   burst = 0;
   grenade = 0;
   if MissMod > 0 orElse SwingThrustTweak > 0 then begin
      dmg_type = 0;
      newtarget = 0;
      missed = -1;
      hitmiss = get_sfall_arg;
      attacker = get_sfall_arg;
      target = get_sfall_arg;
      bpart = get_sfall_arg;
      hitch = get_sfall_arg;


      combat_diff = combat_difficulty;
      weapon = get_object_data(combat_data, C_ATTACK_WEAPON);
      tar_tile = tile_num(target);
      atk_tile = tile_num(attacker);
      rotationatkr = real_rotation_to_tile(atk_tile, tar_tile);
      oldrotationatkr = rotation_to_tile(atk_tile, tar_tile);
      rotationtar = has_trait(TRAIT_OBJECT, target, OBJECT_CUR_ROT);
      rndarm = random(BODY_HIT_LEFT_ARM, BODY_HIT_RIGHT_ARM);
      rndleg = random(BODY_HIT_RIGHT_LEG, BODY_HIT_LEFT_LEG);
      distance_objs(distance_to_tar, target, attacker);
      critter_type = metarule(METARULE_CRITTER_KILL_TYPE, target);
      tar_cur_frm = get_object_data(target, OBJ_DATA_CUR_FRM);
      tar_fid = crit_fid(target);
      atk_mode = get_object_data(combat_data, C_ATTACK_HIT_MODE);
   //determining the type of attack
      if weapon > 0 then begin
         weapon_pid = obj_pid(weapon);
         wpn_dmg_type = weapon_dmg_type(weapon);
         dmg_type = wpn_dmg_type;
         wpnanim = get_proto_data(weapon_pid, PROTO_WP_ANIM);
         weapon_attack_anim = get_attack_anim(weapon, atk_mode);
         if atk_mode == ATKTYPE_LWEP1 orElse atk_mode == ATKTYPE_RWEP1 then begin
            wpn_range = get_proto_data(weapon_pid, PROTO_WP_RANGE_1);
         end
         else if atk_mode == ATKTYPE_LWEP2 orElse atk_mode == ATKTYPE_RWEP2 then begin
            wpn_range = get_proto_data(weapon_pid, PROTO_WP_RANGE_2);
         end

         if weapon_attack_anim == ANIM_swing_anim then begin
            swing = 1;
         end
         else if weapon_attack_anim == ANIM_thrust_anim then begin
            thrust = 1;
         end
         else if weapon_attack_anim == ANIM_fire_burst orElse weapon_attack_anim == ANIM_fire_continuous then begin
            burst = 1;
         end
         else if  weapon_attack_anim == ANIM_throw_anim andAlso wpn_dmg_type != DMG_normal_dam then begin
            grenade = 1;
         end
      end
      else begin
         if (get_proto_data(obj_pid(attacker), PROTO_CR_FLAGS) bwand CFLG_RANGED) == CFLG_RANGED then
            wpn_range = 2;

      end
   end
      //New effect for swing and thust attacks
   if SwingThrustTweak > 0 andAlso weapon_pid > 0 then begin
      //if swing == 1 andAlso (wpnanim == WPN_ANIM_KNIFE or wpnanim == 14) then begin
      //end
      if thrust == 1 then begin
         thrusthit = 0;
         if hitmiss > MISS then begin
            //armor pen for knife
            thrusthit = 1;
            if (wpnanim == WPN_ANIM_KNIFE or wpnanim == 14) then begin
               wpn_maxdmg = get_proto_data(weapon_pid, PROTO_WP_DMG_MAX);
               wpn_mindmg = get_proto_data(weapon_pid, PROTO_WP_DMG_MIN);
               wpn_perk = get_proto_data(weapon_pid, PROTO_WP_PERK);
               attacker_meleedmg = get_critter_stat(attacker, STAT_melee_dmg);
               if wpn_perk == PERK_weapon_penetrate then begin
                  dt_mod = 2;
                  dr_mod = 25;
               end
               else begin
                  dt_mod = 1 + ((wpn_maxdmg + wpn_mindmg + attacker_meleedmg) / 7);
                  dr_mod = 10 + ((wpn_maxdmg + wpn_mindmg + attacker_meleedmg) / 3);
               end
               if dt_mod > 0 then begin
                  tardt_extra = get_critter_extra_stat(target, (STAT_dmg_thresh + wpn_dmg_type));
                  set_critter_extra_stat(target, (STAT_dmg_thresh + wpn_dmg_type), (tardt_extra - dt_mod));
               end
               tardr_extra = get_critter_extra_stat(target, (STAT_dmg_resist + wpn_dmg_type));
               set_critter_extra_stat(target, (STAT_dmg_resist + wpn_dmg_type), (tardr_extra - dr_mod));
            end
            if hitmiss == HIT andAlso ((random (0, 98)) < ((get_critter_stat(attacker, STAT_crit_chance) + 1) / 2)) then begin
               set_sfall_return(CRITICAL_HIT); //  critical hit
               set_sfall_arg(0, CRITICAL_HIT);
               return;
            end
         end
      end
   end

   if MissMod > 0 then begin
      // new targets for missed attacks
      if hitmiss == MISS andAlso wpn_range > 1 andAlso attacker != target then begin
         new_target = 0;
         rnd = random(1, 100);
         if wpn_range > 3 then begin
            miss_tile = get_miss_tile(attacker, target, wpn_range, weapon, weapon_attack_anim);
         end
         else begin
            miss_tile = tile_num_beyond(atk_tile, tar_tile, wpn_range);
         end
         if rnd > 60 then begin
            call get_targets_on_a_line(attacker, target, miss_tile, wpn_range);
            new_random_target_array_len = len_array(new_random_target_array);
            if new_random_target_array_len > 0 then begin
               new_target = get_array(new_random_target_array, random(0, new_random_target_array_len-1));
                  tile_refresh_display;
               if new_target > 0 then begin
                  if obj_type(new_target) == OBJ_TYPE_CRITTER andAlso random(1,100) < (get_critter_stat(attacker, STAT_crit_chance) / 3) then
                     new_result = CRITICAL_HIT;
                  else
                     new_result = HIT;
               end
            end
         end
         //call set_shootthru_flag_for_all_critters;
         if wpn_range > 3 andAlso new_target <= 0 andAlso miss_tile > 0 andAlso miss_tile != atk_tile andAlso miss_tile != tar_tile then begin
            if rotation_to_tile(atk_tile,miss_tile) != rotation_to_tile(atk_tile,tar_tile) then begin
               miss_tile = tar_tile;
            end
            else begin
               new_target = get_first_non_critter_block_shoot(attacker, miss_tile);
               if new_target then begin
                  new_target_2 = get_first_non_critter_block_shoot(attacker, tile_num(new_target));
                  if new_target_2 > 0 then
                     new_target = new_target_2;
               end

               if new_target == 0 then begin
                  if target_dummy <= 0 then begin
                     target_dummy = create_object_sid(pid_scroll_block, 0, 0, -1);
                  end
                  set_flags(target_dummy, FLAGS_GHOST_OBJECT);
                  move_to(target_dummy, miss_tile, elevation(target));
                  new_target = target_dummy;
               end
            end
            new_result = HIT;
         end
         if new_target > 0 then begin
            set_sfall_return(new_result);
            set_sfall_arg(0, new_result);
            set_sfall_return(BODY_UNCALLED);
            set_sfall_arg(3, BODY_UNCALLED);
            set_sfall_return(new_target);
            set_sfall_arg(2, new_target);
            newtarget = 1;
            return;
         end
      end

// humans,ghouls,supermutants/radscop/ Horrigan  conversion of aimed hits in eye/groin in critter's back into head/ torso+legs hits
      if critter_type < 5 or critter_type == 6 or critter_type > 17 then begin // (kill type 0 - 4) = humans, ghouls, supermutants / 6=radscop / > 18= Horrigan and maybe player(38 or 38)
            if hitmiss > MISS andAlso tile_distance_objs(target, attacker) > 0 andAlso ((tar_cur_frm == 4 andAlso tar_fid == FID_NMBOXX)  or  tar_cur_frm == 6  or  rotationatkr == rotationtar or rotationatkr == ((rotationtar + 5) % 6) or rotationatkr == ((rotationtar + 1) % 6) ) then begin
                 if bpart == BODY_HIT_EYES andAlso (tar_cur_frm != 10 or (tar_cur_frm != 4 andAlso tar_fid == FID_NMMEXI)) then begin
                     set_sfall_return(hitmiss); // hit or miss
                     set_sfall_arg(0, hitmiss);
                     set_sfall_return(BODY_HIT_HEAD); // new bodypart
                     set_sfall_arg(3, BODY_HIT_HEAD);
                     return;
                  end

         // groin from back and rears convertion to torso or random leg
              if (bpart == BODY_HIT_GROIN  andAlso tar_cur_frm != 10 andAlso tar_cur_frm != 6 or (tar_cur_frm != 4 andAlso tar_fid == FID_NMMEXI) )  or (bpart == BODY_HIT_GROIN andAlso (tar_cur_frm == 6 or (tar_cur_frm == 4 andAlso tar_fid == FID_NMBOXX)) andAlso not( rotationatkr == rotationtar))  then begin
                     rnd = random(1, 100);
                     if rnd <= 60 then begin
                        set_sfall_return(hitmiss); // hit or miss
                        set_sfall_arg(0, hitmiss);
                        set_sfall_return(BODY_HIT_TORSO); // new bodypart
                        set_sfall_arg(3, BODY_HIT_TORSO);
                        return;
                     end
                     if rnd > 60 then begin
                        set_sfall_return(hitmiss); // hit or miss
                        set_sfall_arg(0, hitmiss);
                        set_sfall_return(rndleg); //  new bodypart
                        set_sfall_arg(3, rndleg);
                        return;
                     end
               end
            end
      end

   //deathclaw conversion of aimed hits in eye/groin in critter's back into head/ torso+legs hits
      if critter_type == KILL_TYPE_deathclaw_kills andAlso hitmiss > MISS then begin // 13 = deathclaw
         if ( ((tar_cur_frm != 6 andAlso tar_cur_frm != 5) andAlso (rotationatkr == rotationtar or rotationatkr == ((rotationtar + 5) % 6) or rotationatkr == ((rotationtar + 1) % 6) )) or ( tar_cur_frm == 6 andAlso ( rotationatkr == ((rotationtar + 3) % 6)  or rotationatkr == ((rotationtar + 4) % 6)  or rotationatkr == ((rotationtar + 5) % 6) )) or ( tar_cur_frm == 5 andAlso ( rotationatkr == ((rotationtar + 1) % 6)  or rotationatkr == ((rotationtar + 2) % 6)  or rotationatkr == ((rotationtar + 3) % 6) )) ) then begin
              if bpart == BODY_HIT_EYES then begin
                  set_sfall_return(hitmiss); // hit or miss
                  set_sfall_arg(0, hitmiss);
                  set_sfall_return(BODY_HIT_HEAD); // new bodypart
                  set_sfall_arg(3, BODY_HIT_HEAD);
                  return;
               end
         end
      // groin from back and rears convertion to torso or random leg
      if (bpart == BODY_HIT_GROIN andAlso tar_cur_frm == 5 andAlso (((rotationatkr == rotationtar + 1) % 6) or ((rotationatkr == rotationtar + 2) % 6) or ((rotationatkr == rotationtar + 3) % 6)) ) or (bpart == 7 andAlso tar_cur_frm == 6 andAlso ( ((rotationatkr == rotationtar + 1) % 6) or rotationatkr == rotationtar or rotationatkr == ((rotationtar + 5) % 6) ) )  then begin
            rnd = random(1, 100);
            if rnd <= 60 then begin
               set_sfall_return(hitmiss); // hit or miss
               set_sfall_arg(0, hitmiss);
               set_sfall_return(BODY_HIT_TORSO); // new bodypart torso
               set_sfall_arg(3, BODY_HIT_TORSO);
               return;
            end
            if rnd > 60 then begin
               set_sfall_return(hitmiss); // hit or miss
               set_sfall_arg(0, hitmiss);
               set_sfall_return(rndleg); //  new bodypart = rnd leg
               set_sfall_arg(3, rndleg);
               return;
            end
      end
   end
   // brahmins/centaurs/robots/dogs conversion of aimed hits in eye/sensors in critter's back into head/cpu hits // regulator from face into /torso+legs hits
   if critter_type == 5  or critter_type == 7 or critter_type == 9 or critter_type == 10 or critter_type == 11  then begin // 5 = brahmin, 7=rats, 9 == centaurs 10= robots 11= dogs
            if hitmiss > MISS andAlso tile_distance_objs(target, attacker) > 0   andAlso ( tar_cur_frm == 6  or  rotationatkr == rotationtar or rotationatkr == ((rotationtar + 1) % 6)  or rotationatkr == ((rotationtar + 5) % 6) ) then begin
                 // eye(sensor) to head(cpu)
                 if bpart == 6 andAlso tar_cur_frm != 10  then begin
                     set_sfall_return(hitmiss); // hit or miss
                     set_sfall_arg(0, hitmiss);
                     set_sfall_return(BODY_HIT_HEAD); // new bodypart
                     set_sfall_arg(3, BODY_HIT_HEAD);
                     return;
                  end
             end
         // groin(regulator) from face and anterior rears convertion to torso or random leg(motivators)
         if hitmiss > MISS andAlso tile_distance_objs(target, attacker) > 0   andAlso  ( rotationatkr == ((rotationtar + 2) % 6) or rotationatkr == ((rotationtar + 3) % 6) or rotationatkr == ((rotationtar + 4) % 6) )  then begin
              if bpart == 7  andAlso tar_cur_frm != 10 andAlso tar_cur_frm != 6  or (bpart == 7 andAlso tar_cur_frm == 6 andAlso not( rotationatkr == rotationtar))  then begin
                        rnd = random(1, 100);
                        if rnd <= 60 then begin
                           set_sfall_return(hitmiss); // hit or miss
                           set_sfall_arg(0, hitmiss);
                           set_sfall_return(BODY_HIT_TORSO); // new bodypart torso
                           set_sfall_arg(3, BODY_HIT_TORSO);
                           return;
                        end

                        if rnd > 60 then begin
                           set_sfall_return(hitmiss); // hit or miss
                           set_sfall_arg(0, hitmiss);
                           set_sfall_return(rndleg); //  new bodypart  rnd leg
                           set_sfall_arg(3, rndleg);
                           return;
                        end
               end
            end
      end

   // Aliens conversion of aimed hits in eyes(?) in critter's back into head hits
   if critter_type == 16 then begin // 16 == aliens
            // aliens' eyes(?) to head
            if hitmiss > MISS andAlso tile_distance_objs(target, attacker) > 0   andAlso ( tar_cur_frm == 6  or  rotationatkr == rotationtar ) then begin
                if bpart == BODY_HIT_EYES andAlso tar_cur_frm != 10  then begin
                        rnd = random(1, 100);
                        if rnd <= 60 then begin
                           set_sfall_return(hitmiss); // hit or miss
                           set_sfall_arg(0, hitmiss);
                           set_sfall_return(BODY_HIT_HEAD); // new bodypart
                           set_sfall_arg(3, BODY_HIT_HEAD);
                           return;
                        end
                        if rnd > 60 then begin
                           set_sfall_return(hitmiss); // hit or miss
                           set_sfall_arg(0, hitmiss);
                           set_sfall_return(BODY_HIT_TORSO); //  new bodypart
                           set_sfall_arg(3, BODY_HIT_TORSO);
                           return;
                        end
                  end
             end

         // aliens' groin hit if facing the attacker to head or torso hit
         if hitmiss > MISS andAlso tile_distance_objs(target, attacker) > 0   andAlso  rotationatkr == ((rotationtar + 3) % 6)  then begin
              if bpart == BODY_HIT_GROIN  andAlso tar_cur_frm != 10 then begin
                  rnd = random(1, 100);
                  if rnd <= 60 then begin
                     set_sfall_return(hitmiss); // hit or miss
                     set_sfall_arg(0, hitmiss);
                     set_sfall_return(BODY_HIT_TORSO); // new bodypart
                     set_sfall_arg(3, BODY_HIT_TORSO);
                     return;
                  end
                  if rnd > 60 then begin
                     set_sfall_return(hitmiss); // hit or miss
                     set_sfall_arg(0, hitmiss);
                     set_sfall_return(BODY_HIT_HEAD); //  new bodypart
                     set_sfall_arg(3, BODY_HIT_HEAD);
                     return;
                  end
               end
            end
      end

// All critters types
       // chance to convert uncalled_body hit to random aimed hit for all critters if mod is activated
      if (BodyRndHit == 1 or (attacker != dude_obj andAlso BodyRndHit == 2)) andAlso wpn_dmg_type != DMG_explosion andAlso bpart == BODY_UNCALLED andAlso burst == 0 andAlso grenade == 0 andAlso hitmiss > MISS then begin
         //for attackers with small FRM (ant,mantis,small radscorp e.t.) lower chance to hit head/eyes, more chance to hit legs
         if short_crit(attacker) then begin
            rnd = random(0, (700 - 280 * combat_diff));
            rnd2 = random(0,100);
            if attacker == dude_obj then rnd = random(0, 100);
            if rnd > 55 then begin // old bodypart 8 - torso uncalled
               set_sfall_return(hitmiss); // hit or miss not changed
               set_sfall_arg(0, hitmiss);
               return;
            end
            // ~1% can hit head/eyes only if target is lying on the floor
            if (rnd <= 10 andAlso tar_cur_frm == 10 andAlso ( rotationatkr == rotationtar or rotationatkr == ((rotationtar + 5) % 6) or rotationatkr == ((rotationtar + 1) % 6)) )
               or (rnd <= 10 andAlso tar_cur_frm == 6 andAlso not( rotationatkr == rotationtar or rotationatkr == ((rotationtar + 5) % 6) or rotationatkr == ((rotationtar + 1) % 6)) ) then begin // ~1 % can hit head / eyes only if target is lying on the floor
                  if rnd2 <= 94 then begin // ~9, 5 % to hit head
                     rnd3 = random(2, 3);
                     set_sfall_return(rnd3); // 50 % critical hit chance
                     set_sfall_arg(0, rnd3);
                     set_sfall_return(BODY_HIT_HEAD); // new bodypart 0 - head
                     set_sfall_arg(3, BODY_HIT_HEAD);
                     set_critter_current_ap(attacker, (get_critter_current_ap(attacker) + 1)); // return 1 action point because a new attack costs 1 more
                     return;
                  end
                  if rnd2 > 94 andAlso tar_cur_frm == 10 then begin // ~0, 5 % to critical hit eyes
                     set_sfall_return(CRITICAL_HIT); // always critical hit chance
                     set_sfall_arg(0, CRITICAL_HIT);
                     set_sfall_return(BODY_HIT_EYES); // new bodypart 6 - eyes
                     set_sfall_arg(3, BODY_HIT_EYES);
                     set_critter_current_ap(attacker, (get_critter_current_ap(attacker) + 1));
                     return;
                  end
            end
            if rnd > 10 andAlso rnd <= 15 then begin // 9 %
                  if rnd2 <= 3 + 3 * combat_diff then begin // 1 -  %
                  set_sfall_return(CRITICAL_HIT); // critical hit
                  set_sfall_arg(0, CRITICAL_HIT);
                  end
                  if rnd2 > 3 + 3 * combat_diff then begin
                  set_sfall_return(hitmiss); // hit or miss not changed
                  set_sfall_arg(0, hitmiss);
                  end
               set_sfall_return(rndarm); // new bodypart 1, 2 - arms
               set_sfall_arg(3, rndarm);
               set_critter_current_ap(attacker, (get_critter_current_ap(attacker) + 1));
               return;
            end
            if rnd > 15 andAlso rnd <= 45 then begin // 25 %
                  if rnd2 <= 1 + 3 * combat_diff then begin // 10 %
                  set_sfall_return(CRITICAL_HIT); // crit hit
                  set_sfall_arg(0, CRITICAL_HIT);
                  end
                  if rnd2 > 1 + 3 * combat_diff then begin
                  set_sfall_return(hitmiss); // hit or miss not changed
                  set_sfall_arg(0, hitmiss);
                  end
               set_sfall_return(rndleg); // new bodypart 4, 5 - legs
               set_sfall_arg(3, rndleg);
               set_critter_current_ap(attacker, (get_critter_current_ap(attacker) + 1));
               return;
            end
            if rnd > 45 andAlso rnd <= 55 then begin // 14 %
                  if rnd2 <= 3 + 3 * combat_diff then begin // 10 %
                  set_sfall_return(CRITICAL_HIT); // crit hit
                  set_sfall_arg(0, CRITICAL_HIT);
                  end
                  if rnd2 > 3 + 3 * combat_diff then begin
                  set_sfall_return(hitmiss); // hit or miss not changed
                  set_sfall_arg(0, hitmiss);
                  end
               set_sfall_return(BODY_HIT_GROIN); // new bodypart 7 - groin
               set_sfall_arg(3, BODY_HIT_GROIN);
               set_critter_current_ap(attacker, (get_critter_current_ap(attacker) + 1));
               return;
            end
         end

         // for attackers with medium FRM or normal human FRM or big FRM
         if not(short_crit(attacker)) then begin
            rnd = random(0, (400 - 150 * combat_diff));
            rnd2 = random(0, 100);
            if attacker == dude_obj then rnd = random(0, 100);
            if rnd > 29 then begin // old bodypart 8 - torso uncalled or 10% right arm
               if rnd <= 40 then begin
                  set_sfall_return(hitmiss); // hit or miss not changed
                  set_sfall_arg(0, hitmiss);
                  set_sfall_return(BODY_HIT_RIGHT_ARM); // new bodypart - right arm
                  set_sfall_arg(3, BODY_HIT_RIGHT_ARM);
                  set_critter_current_ap(attacker, (get_critter_current_ap(attacker) + 1));
                  return;
               end
               else begin
                  set_sfall_return(hitmiss); // hit or miss not changed
                  set_sfall_arg(0, hitmiss);
                  return;
               end
            end
            if rnd <= 3 then begin // 3 %
               rnd3 = random(2, 3);
               if rnd2 <= 95 then begin // ~2, 85 % to hit head
                  set_sfall_return(rnd3); // 50 % critical hit chance
                  set_sfall_arg(0, rnd3);
                  set_sfall_return(BODY_HIT_HEAD); // new bodypart 0 - head
                  set_sfall_arg(3, BODY_HIT_HEAD);
                  set_critter_current_ap(attacker, (get_critter_current_ap(attacker) + 1)); // return 1 action point because a new attack costs 1 more
                  return;
               end
               if (rnd2 > 95 andAlso tar_cur_frm == 10) or
               (rnd2 > 95 andAlso not( rotationatkr == rotationtar or rotationatkr == ((rotationtar + 1) % 6)  or rotationatkr == ((rotationtar + 5) % 6) )) then begin // ~0,15 % to hit eyes
                  set_sfall_return(CRITICAL_HIT); // always critical hit chance
                  set_sfall_arg(0, CRITICAL_HIT);
                  set_sfall_return(BODY_HIT_EYES); // new bodypart 6 - eyes
                  set_sfall_arg(3, BODY_HIT_EYES);
                  set_critter_current_ap(attacker, (get_critter_current_ap(attacker) + 1));
                  return;
               end
            end
            if rnd > 3 andAlso rnd <= 12 then begin // 9 %
               if rnd2 <= 3 + 4 * combat_diff then begin // 10 % bonus crit chance
                  set_sfall_return(CRITICAL_HIT); // crit hit
                  set_sfall_arg(0, CRITICAL_HIT);
               end
               else begin
                  set_sfall_return(hitmiss); // hit or miss not changed
                  set_sfall_arg(0, hitmiss);
               end
               set_sfall_return(rndarm); // new bodypart 1, 2 - arms
               set_sfall_arg(3, rndarm);
               set_critter_current_ap(attacker, (get_critter_current_ap(attacker) + 1));
               return;
            end
            if rnd > 12 andAlso rnd <= 23 then begin // 11 %
               if rnd2 <= 3 + 4 * combat_diff then begin // 10 % bonus crit chance
                  set_sfall_return(CRITICAL_HIT); // crit hit
                  set_sfall_arg(0, CRITICAL_HIT);
               end
               else begin
                  set_sfall_return(hitmiss); // hit or miss not changed
                  set_sfall_arg(0, hitmiss);
               end
               set_sfall_return(rndleg); // new bodypart 4, 5 - legs
               set_sfall_arg(3, rndleg);
               set_critter_current_ap(attacker, (get_critter_current_ap(attacker) + 1));
               return;
            end
            if rnd > 23 andAlso rnd <= 30 andAlso (tar_cur_frm == 10 or (not( rotationatkr == rotationtar or rotationatkr == ((rotationtar + 1) % 6)  or rotationatkr == ((rotationtar + 5) % 6)) ) or (tar_cur_frm == 6 andAlso (rotationatkr == rotationtar or rotationatkr == ((rotationtar + 1) % 6)  or rotationatkr == ((rotationtar + 5) % 6)))) then begin // 7 %
               if rnd2 <= 3 + 4 * combat_diff then begin // 15 % bonus crit chance
                  set_sfall_return(CRITICAL_HIT); // crit hit
                  set_sfall_arg(0, CRITICAL_HIT);
               end
               else begin
                  set_sfall_return(hitmiss); // hit or miss not changed
                  set_sfall_arg(0, hitmiss);
               end
               set_sfall_return(BODY_HIT_GROIN); // new bodypart 7 - groin
               set_sfall_arg(3, BODY_HIT_GROIN);
               set_critter_current_ap(attacker, (get_critter_current_ap(attacker) + 1));
               return;
            end
         end
      end

      // chance to convert aimed body miss to random hit for all critters
      if bpart == BODY_HIT_TORSO andAlso hitch > 19 andAlso hitmiss == MISS then begin
         rnd = random(0, 100);
         if rnd < 9 then begin // old bodypart 8 - torso uncalled
            rnd = random(1, 5);
            if rnd != BODY_HIT_TORSO then begin // not a body hit
            set_sfall_return(HIT); // hit instead of miss
            set_sfall_arg(0, HIT);
            set_sfall_return(rnd); // new bodypart
            set_sfall_arg(3, rnd);
            return;
            end
            else begin
            set_sfall_return(hitmiss); // hit instead of miss
            set_sfall_arg(0, hitmiss);
            return;
            end
         end
         if rnd > 98 then begin // 1 - 3 %
            set_sfall_return(HIT); // hit instead of miss
            set_sfall_arg(0, HIT);
            set_sfall_return(BODY_HIT_HEAD); // new bodypart
            set_sfall_arg(3, BODY_HIT_HEAD);
            return;
         end
      end

   // chance to convert head hit to eye hit for all critters
      if bpart == BODY_HIT_HEAD andAlso hitmiss > MISS then begin
         rnd = random(0, 100);
         if rnd < 5 then begin
            if rnd == 4 then begin
            set_sfall_return(hitmiss); // hit or crit
            set_sfall_arg(0, hitmiss);
            end
            if rnd < 4 then begin
            set_sfall_return(CRITICAL_HIT); // hit or crit
            set_sfall_arg(0, CRITICAL_HIT);
            end
            set_sfall_return(BODY_HIT_EYES); // new bodypart 6 - eye
            set_sfall_arg(3, BODY_HIT_EYES);
            return;
         end
      end

   // miss to random hit for all critters

      //eye miss to 1% + (1-5)% head or 3% body hit
      if bpart == BODY_HIT_EYES andAlso hitch > 19 andAlso hitmiss == MISS then begin
         rnd = random(0, 100);
         rnd2 = random(2, 3);
         if rnd < (2 + hitch / 19) then begin
            set_sfall_return(rnd2); // hit or miss
            set_sfall_arg(0, rnd2);
            set_sfall_return(BODY_HIT_HEAD); // new bodypart
            set_sfall_arg(3, BODY_HIT_HEAD);
            return;
         end
         if rnd > 98 then begin
            set_sfall_return(HIT); // hit or miss
            set_sfall_arg(0, HIT);
            set_sfall_return(BODY_HIT_TORSO); //  new bodypart 3 - aimed_body
            set_sfall_arg(3, BODY_HIT_TORSO);
            return;
         end
      end
      //groin miss to (1-5)% legs or (1-5) body hit
      if bpart == BODY_HIT_GROIN andAlso hitch > 19 andAlso hitmiss == MISS then begin
         rnd = random(0, 100);
         if rnd < (hitch / 19) then begin
            set_sfall_return(HIT); // hit or miss
            set_sfall_arg(0, HIT);
            set_sfall_return(BODY_HIT_TORSO); //  new bodypart 3 - aimed_body
            set_sfall_arg(3, BODY_HIT_TORSO);
            return;
         end
         if rnd > (100 - hitch / 19)  then begin
            set_sfall_return(HIT); // hit or miss
            set_sfall_arg(0, HIT);
            set_sfall_return(rndleg); //  new bodypart 4 - left leg, 5 - right leg
            set_sfall_arg(3, rndleg);
            return;
         end
      end
      // legs&arms miss to body hit (1-5)%
      if (bpart < 6 ) andAlso bpart != BODY_HIT_TORSO  andAlso hitch > 19 andAlso hitmiss == MISS then begin
         rnd = random(0, 100);
         if rnd < (hitch / 19) then begin
            set_sfall_return(HIT); // hit
            set_sfall_arg(0, HIT);
            set_sfall_return(BODY_HIT_TORSO); //  new bodypart
            set_sfall_arg(3, BODY_HIT_TORSO);
            return;
         end
      end
   end
   rnd = 0;
   rnd2 = 0;
   rnd3 = 0;
   //burst = 0;
   //grenade = 0;
   missed = get_sfall_arg_at(0);
end

procedure start begin
   variable sfall_ver_maj;
   variable ver_minor;
   variable ver_build;
   if game_loaded then begin
      MissMod = get_ini_setting("mods\\F2MechanicsMiniRework.ini|MAIN|MissToHit");
      BodyRndHit = get_ini_setting("mods\\F2MechanicsMiniRework.ini|Miss|BodyRndHit");
      //gDifficultAiming = get_ini_setting("mods\\F2MechanicsMiniRework.ini|Miss|DifficultAiming");
      SwingThrustTweak = get_ini_setting("mods\\F2MechanicsMiniRework.ini|MAIN|SwingThrust");
      if MissMod > 0 or BodyRndHit > 0 or SwingThrustTweak > 0 then begin
         gHeadHitMod = get_bodypart_hit_modifier(BODY_HIT_HEAD);
         gEyeHitMod = get_bodypart_hit_modifier(BODY_HIT_EYES);
         //more difficult targeted shots to the head and eyes
         if combat_difficulty >= 2 then begin
            if get_bodypart_hit_modifier(BODY_HIT_HEAD) > BODY_HIT_HEAD_NEW_MOD then
               set_bodypart_hit_modifier(BODY_HIT_HEAD, BODY_HIT_HEAD_NEW_MOD);
            if get_bodypart_hit_modifier(BODY_HIT_EYES) > BODY_HIT_EYES_NEW_MOD then
               set_bodypart_hit_modifier(BODY_HIT_EYES, BODY_HIT_EYES_NEW_MOD);
         end
         sfall_ver_maj = sfall_ver_major;
         ver_minor = sfall_ver_minor;
         ver_build = sfall_ver_build;
         if sfall_ver_maj >= 5 then begin
            if ver_build >= 8 orElse sfall_ver_maj > 5 orElse ver_minor > 0 then begin
               if ver_minor > 0 then begin
                  sfall_510 = 1;
                  unsafe_script;
               end
            end
         end
         new_random_target_array = create_array_map;
         register_hook_proc_spec(HOOK_COMBATDAMAGE, COMBATDAMAGE);
         register_hook_proc_spec(HOOK_AFTERHITROLL, AFTERHITROLL);
         register_hook_proc_spec(HOOK_TOHIT, TOHIT);
         register_hook_proc_spec(HOOK_CALCAPCOST, CALCAPCOST);
         register_hook_proc(HOOK_COMBATTURN, COMBATTURN);
         register_hook_proc(HOOK_GAMEMODECHANGE, GAMEMODECHANGE);
         pyro_bonus = get_ini_setting("sfall\\Perks.ini|PerksTweak|PyromaniacBonus");
         if pyro_bonus < 0 then pyro_bonus = 5;
      end
      set_global_script_type(0);
      set_global_script_repeat(0);
   end
end
